<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>发送数据过程 - PJSIP_STUDY</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="SIP.html"><strong aria-hidden="true">1.</strong> sip协议概述</a></li><li class="chapter-item expanded "><a href="pjsip_doc.html"><strong aria-hidden="true">2.</strong> pjsip文档翻译</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> make call流程</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="State.html"><strong aria-hidden="true">3.1.</strong> 状态机</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> 流程图</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="html/make_call.html"><strong aria-hidden="true">3.2.1.</strong> make call流程图</a></li><li class="chapter-item expanded "><a href="html/pjsip_dlg_create_uac.html"><strong aria-hidden="true">3.2.2.</strong> Create an UAC dialog</a></li><li class="chapter-item expanded "><a href="html/on_make_call_med_tp_complete.html"><strong aria-hidden="true">3.2.3.</strong> Outgoing call callback when media transport creation is completed</a></li><li class="chapter-item expanded "><a href="html/tsx_on_state_null.html"><strong aria-hidden="true">3.2.4.</strong> tsx_on_state_null状态处理</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> pjmedia学习</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="发送数据全流程.html" class="active"><strong aria-hidden="true">4.1.</strong> 发送数据过程</a></li><li class="chapter-item expanded "><a href="数据全流程.html"><strong aria-hidden="true">4.2.</strong> 接收数据过程</a></li><li class="chapter-item expanded "><a href="全流程思考.html"><strong aria-hidden="true">4.3.</strong> 初始化过程</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> 相关数据结构</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ioqueue_epoll.html"><strong aria-hidden="true">4.4.1.</strong> ioqueue_epoll</a></li><li class="chapter-item expanded "><a href="epoll学习.html"><strong aria-hidden="true">4.4.2.</strong> epoll</a></li><li class="chapter-item expanded "><a href="pjmedia_transport.html"><strong aria-hidden="true">4.4.3.</strong> pjmedia_transport</a></li><li class="chapter-item expanded "><a href="Port.html"><strong aria-hidden="true">4.4.4.</strong> pjmedia_port</a></li><li class="chapter-item expanded "><a href="Stream.html"><strong aria-hidden="true">4.4.5.</strong> pjmedia_stream</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 常见数据结构与工具</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="pjsua_call.html"><strong aria-hidden="true">5.1.</strong> pjsua_call</a></li><li class="chapter-item expanded "><a href="pjsua_acc.html"><strong aria-hidden="true">5.2.</strong> pjsua_acc</a></li><li class="chapter-item expanded "><a href="pjsua_data.html"><strong aria-hidden="true">5.3.</strong> pjsua_data</a></li><li class="chapter-item expanded "><a href="SDP.html"><strong aria-hidden="true">5.4.</strong> SDP</a></li><li class="chapter-item expanded "><a href="Dialog.html"><strong aria-hidden="true">5.5.</strong> Dialog</a></li><li class="chapter-item expanded "><a href="Session.html"><strong aria-hidden="true">5.6.</strong> Session</a></li><li class="chapter-item expanded "><a href="transaction.html"><strong aria-hidden="true">5.7.</strong> transaction</a></li><li class="chapter-item expanded "><a href="transport.html"><strong aria-hidden="true">5.8.</strong> transport</a></li><li class="chapter-item expanded "><a href="sendData.html"><strong aria-hidden="true">5.9.</strong> 数据发送数据结构</a></li><li class="chapter-item expanded "><a href="PJSIP_log.html"><strong aria-hidden="true">5.10.</strong> pjsip log</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PJSIP_STUDY</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="发送数据全流程"><a class="header" href="#发送数据全流程">发送数据全流程</a></h1>
<h2 id="1发送的线程在声音设备端直接获取声卡数据"><a class="header" href="#1发送的线程在声音设备端直接获取声卡数据">1、发送的线程（在声音设备端直接获取声卡数据）</a></h2>
<p>先看发送的线程 ca_thread_func，这里我们以alsa_dev为例</p>
<pre><code class="language-c">static int ca_thread_func (void *arg)
{
    struct alsa_stream* stream = (struct alsa_stream*) arg;
    snd_pcm_t* pcm             = stream-&gt;ca_pcm;
    int size                   = stream-&gt;ca_buf_size;
    snd_pcm_uframes_t nframes  = stream-&gt;ca_frames;
    void* user_data            = stream-&gt;user_data;
    char* buf                  = stream-&gt;ca_buf;
    pj_timestamp tstamp;
    int result;
    struct sched_param param;
    pthread_t* thid;

    thid = (pthread_t*) pj_thread_get_os_handle (pj_thread_this());
    param.sched_priority = sched_get_priority_max (SCHED_RR);
    PJ_LOG (5,(THIS_FILE, "ca_thread_func(%u): Set thread priority "
                          "for audio capture thread.",
                          (unsigned)syscall(SYS_gettid)));
    result = pthread_setschedparam (*thid, SCHED_RR, &amp;param);
    if (result) {
        if (result == EPERM)
            PJ_LOG (5,(THIS_FILE, "Unable to increase thread priority, "
                                  "root access needed."));
        else
            PJ_LOG (5,(THIS_FILE, "Unable to increase thread priority, "
                                  "error: %d",
                                  result));
    }

    pj_bzero (buf, size);
    tstamp.u64 = 0;

    TRACE_((THIS_FILE, "ca_thread_func(%u): Started",
            (unsigned)syscall(SYS_gettid)));

    snd_pcm_prepare (pcm);

    while (!stream-&gt;quit) {
        pjmedia_frame frame;

        pj_bzero (buf, size);
        result = snd_pcm_readi (pcm, buf, nframes);
        if (result == -EPIPE) {
            PJ_LOG (4,(THIS_FILE, "ca_thread_func: overrun!"));
            snd_pcm_prepare (pcm);
            continue;
        } else if (result &lt; 0) {
            PJ_LOG (4,(THIS_FILE, "ca_thread_func: error reading data!"));
        }
        if (stream-&gt;quit)
            break;

        frame.type = PJMEDIA_FRAME_TYPE_AUDIO;
        frame.buf = (void*) buf;
        frame.size = size;
        frame.timestamp.u64 = tstamp.u64;
        frame.bit_info = 0;

        result = stream-&gt;ca_cb (user_data, &amp;frame);
        if (result != PJ_SUCCESS || stream-&gt;quit)
            break;

        tstamp.u64 += nframes;
    }
    snd_pcm_drop(pcm);
    TRACE_((THIS_FILE, "ca_thread_func: Stopped"));

    return PJ_SUCCESS;
}
</code></pre>
<p>该线程的主体部分在不停的while循环，我们来看一次循环的内容：</p>
<p>调用 <code>snd_pcm_readi (pcm, buf, nframes);</code> 读网卡的数据到buf中。然后将读出的数据和一系列属性包装成一个frame。然后调用<code>stream-&gt;ca_cb (user_data, &amp;frame);</code></p>
<p>在初始化（pjmedia_aud_stream_create-&gt;f-&gt;op-&gt;create_stream）中我们知道stream-&gt;ca_cb 我们设置为 <code>rec_cb</code> 接下来我们来看<code>rec_cb</code>  在sound_port.c中.</p>
<p>另外我们需要知道<code>ca_cb</code> 中的<code>user_data</code> 到底是什么 这可以看我们之前初始化流程的分析：pjmedia_snd_port_create-》pjmedia_snd_port_create2-》start_sound_device-》pjmedia_aud_stream_create-》f-&gt;op-&gt;create_stream-》alsa_factory_create_stream</p>
<p>到pjmedia_aud_stream_create这步我们看出user_data是我们创建的<code>snd_port</code></p>
<h2 id="2rec_cb-音频流端"><a class="header" href="#2rec_cb-音频流端">2、rec_cb （音频流端）</a></h2>
<pre><code class="language-c">/*
 * The callback called by sound recorder when it has finished capturing a
 * frame.
 */
static pj_status_t rec_cb(void *user_data, pjmedia_frame *frame)
{
    pjmedia_snd_port *snd_port = (pjmedia_snd_port*) user_data;
    pjmedia_port *port;

    pjmedia_clock_src_update(&amp;snd_port-&gt;cap_clocksrc, &amp;frame-&gt;timestamp);

    /* Invoke preview callback */
    if (snd_port-&gt;on_rec_frame)
        (*snd_port-&gt;on_rec_frame)(snd_port-&gt;user_data, frame);

    port = snd_port-&gt;port;
    if (port == NULL)
        return PJ_SUCCESS;

    /* Cancel echo */
    if (snd_port-&gt;ec_state &amp;&amp; !snd_port-&gt;ec_suspended) {
        pjmedia_echo_capture(snd_port-&gt;ec_state, (pj_int16_t*) frame-&gt;buf, 0);
    }

    pjmedia_port_put_frame(port, frame);


    return PJ_SUCCESS;
}
</code></pre>
<p>首先看<code>snd_port-&gt;on_rec_frame</code>这个是可选项，这里没有使用</p>
<p>其次就是最重要的调用pjmedia_port_put_frame，看一下这里的port参数，<code>port = snd_port-&gt;port;</code>  是pjmedia_snd_port类型snd_port中的pjmedia_port类型属性，snd_port-&gt;port是在<code>pjmedia_snd_port_connect</code>中初始化的先看一下pjmedia_snd_port_connect</p>
<pre><code class="language-c">/*
 * Connect a port.
 */
PJ_DEF(pj_status_t) pjmedia_snd_port_connect( pjmedia_snd_port *snd_port,
                                              pjmedia_port *port)
{
    pjmedia_audio_format_detail *afd;

    PJ_ASSERT_RETURN(snd_port &amp;&amp; port, PJ_EINVAL);

    afd = pjmedia_format_get_audio_format_detail(&amp;port-&gt;info.fmt, PJ_TRUE);

    /* Check that port has the same configuration as the sound device
     * port.
     */
    if (afd-&gt;clock_rate != snd_port-&gt;clock_rate)
        return PJMEDIA_ENCCLOCKRATE;

    if (PJMEDIA_AFD_SPF(afd) != snd_port-&gt;samples_per_frame)
        return PJMEDIA_ENCSAMPLESPFRAME;

    if (afd-&gt;channel_count != snd_port-&gt;channel_count)
        return PJMEDIA_ENCCHANNEL;

    if (afd-&gt;bits_per_sample != snd_port-&gt;bits_per_sample)
        return PJMEDIA_ENCBITS;

    /* Port is okay. */
    snd_port-&gt;port = port;
    return PJ_SUCCESS;
}
</code></pre>
<p>注意这里的参数<code>pjmedia_port *port</code>来自pjmedia_stream stream的port，这个port还有一点特殊即port-&gt;port_data.pdata; 其实是指向stream，即stream中有port，port也有办法指向stream，这在put_frame中会遇到。</p>
<p>&lt;::&gt;再回来看pjmedia_port_put_frame该函数其实是port-&gt;put_frame callback的封装，会直接调用port-&gt;put_frame，这个回调函数的初始化在<code>pjmedia_stream_create</code> 完成将port-&gt;put_frame 初始化为 stream-&gt;port.put_frame = &amp;put_frame;，所以接下来我们看put_frame</p>
<pre><code class="language-c">
/**
 * Put a frame to the port (and subsequent downstream ports).
 */
PJ_DEF(pj_status_t) pjmedia_port_put_frame( pjmedia_port *port,
                                            pjmedia_frame *frame )
{
    PJ_ASSERT_RETURN(port &amp;&amp; frame, PJ_EINVAL);

    if (port-&gt;put_frame)
        return port-&gt;put_frame(port, frame);
    else
        return PJ_EINVALIDOP;
}
</code></pre>
<h2 id="3put_frame-port端"><a class="header" href="#3put_frame-port端">3、put_frame （port端）</a></h2>
<pre><code class="language-c">/**
 * put_frame()
 *
 * This callback is called by upstream component when it has PCM frame
 * to transmit. This function encodes the PCM frame, pack it into
 * RTP packet, and transmit to peer.
 */
static pj_status_t put_frame( pjmedia_port *port,
                              pjmedia_frame *frame )
{
    pjmedia_stream *stream = (pjmedia_stream*) port-&gt;port_data.pdata;
    pjmedia_frame tmp_zero_frame;
    unsigned samples_per_frame;

    samples_per_frame = stream-&gt;enc_samples_per_pkt;

    /* https://github.com/pjsip/pjproject/issues/56:
     *  when input is PJMEDIA_FRAME_TYPE_NONE, feed zero PCM frame
     *  instead so that encoder can decide whether or not to transmit
     *  silence frame.
     */
    if (frame-&gt;type == PJMEDIA_FRAME_TYPE_NONE) {
        pj_memcpy(&amp;tmp_zero_frame, frame, sizeof(pjmedia_frame));
        frame = &amp;tmp_zero_frame;

        tmp_zero_frame.buf = NULL;
        tmp_zero_frame.size = samples_per_frame * 2;
        tmp_zero_frame.type = PJMEDIA_FRAME_TYPE_AUDIO;
    }

    /* If VAD is temporarily disabled during creation, enable it
     * after transmitting for VAD_SUSPEND_SEC seconds.
     */
    if (stream-&gt;vad_enabled != stream-&gt;codec_param.setting.vad &amp;&amp;
        (stream-&gt;tx_duration - stream-&gt;ts_vad_disabled) &gt;
           PJMEDIA_PIA_SRATE(&amp;stream-&gt;port.info) *
          PJMEDIA_STREAM_VAD_SUSPEND_MSEC / 1000)
    {
        stream-&gt;codec_param.setting.vad = stream-&gt;vad_enabled;
        pjmedia_codec_modify(stream-&gt;codec, &amp;stream-&gt;codec_param);
        PJ_LOG(4,(stream-&gt;port.info.name.ptr,"VAD re-enabled"));
    }


    /* If encoder has different ptime than decoder, then the frame must
     * be passed through the encoding buffer via rebuffer() function.
     */
    if (stream-&gt;enc_buf != NULL) {
        pjmedia_frame tmp_rebuffer_frame;
        pj_status_t status = PJ_SUCCESS;

        /* Copy original frame to temporary frame since we need
         * to modify it.
         */
        pj_memcpy(&amp;tmp_rebuffer_frame, frame, sizeof(pjmedia_frame));

        /* Loop while we have full frame in enc_buffer */
        for (;;) {
            pj_status_t st;

            /* Run rebuffer() */
            rebuffer(stream, &amp;tmp_rebuffer_frame);

            /* Process this frame */
            st = put_frame_imp(port, &amp;tmp_rebuffer_frame);
            if (st != PJ_SUCCESS)
                status = st;

            /* If we still have full frame in the buffer, re-run
             * rebuffer() with NULL frame.
             */
            if (stream-&gt;enc_buf_count &gt;= stream-&gt;enc_samples_per_pkt) {

                tmp_rebuffer_frame.type = PJMEDIA_FRAME_TYPE_NONE;

            } else {

                /* Otherwise break */
                break;
            }
        }

        return status;

    } else {
        return put_frame_imp(port, frame);
    }
}
</code></pre>
<p>重点看一下<code>put_frame_imp</code> 对frame的处理，函数比较长，我们来分段看一下</p>
<ol>
<li>
<p>函数开始时，从 <code>port</code> 参数中获取了指向 <code>pjmedia_stream</code> 结构的指针 <code>stream</code>，并且从 <code>stream</code> 中获取了编码通道 <code>enc</code>。</p>
<pre><code class="language-c">    pjmedia_stream *stream = (pjmedia_stream*) port-&gt;port_data.pdata;
    pjmedia_channel *channel = stream-&gt;enc;
</code></pre>
</li>
<li>
<p>如果流启用了保活机制，函数会检查距离上次发送数据包的时间间隔，如果超过了指定的保活间隔，会发送一个保活数据包。</p>
</li>
<li>
<p>然后，函数会根据帧的类型计算帧中的样本数 <code>ts_len</code>，并根据是否存在特定的编码器问题来确定 RTP 时间戳的长度 <code>rtp_ts_len</code>。</p>
<pre><code class="language-c">    /* Number of samples in the frame */
    if (frame-&gt;type == PJMEDIA_FRAME_TYPE_AUDIO)
        ts_len = ((unsigned)frame-&gt;size &gt;&gt; 1) /
                 stream-&gt;codec_param.info.channel_cnt;
    else if (frame-&gt;type == PJMEDIA_FRAME_TYPE_EXTENDED)
        ts_len = PJMEDIA_PIA_SPF(&amp;stream-&gt;port.info) /
                 PJMEDIA_PIA_CCNT(&amp;stream-&gt;port.info);
    else
        ts_len = 0;

#if defined(PJMEDIA_HANDLE_G722_MPEG_BUG) &amp;&amp; (PJMEDIA_HANDLE_G722_MPEG_BUG!=0)
    /* Handle special case for audio codec with RTP timestamp inconsistence
     * e.g: G722, MPEG audio.
     */
    if (stream-&gt;has_g722_mpeg_bug)
        rtp_ts_len = stream-&gt;rtp_tx_ts_len_per_pkt;
    else
        rtp_ts_len = ts_len;
#else
    rtp_ts_len = ts_len;
#endif
</code></pre>
</li>
<li>
<p>如果编码通道被暂停，函数会更新 RTP 会话的时间戳，并在需要时发送 RTCP SR/RR 报告。</p>
<pre><code class="language-c">    /* Don't do anything if stream is paused, except updating RTP timestamp */
    if (channel-&gt;paused) {
        stream-&gt;enc_buf_pos = stream-&gt;enc_buf_count = 0;

        /* Update RTP session's timestamp. */
        status = pjmedia_rtp_encode_rtp( &amp;channel-&gt;rtp, 0, 0, 0, rtp_ts_len,
                                         NULL, NULL);

        /* Update RTCP stats with last RTP timestamp. */
        stream-&gt;rtcp.stat.rtp_tx_last_ts = pj_ntohl(channel-&gt;rtp.out_hdr.ts);

        /* Check if now is the time to transmit RTCP SR/RR report.
         * We only do this when the decoder is paused,
         * because otherwise check_tx_rtcp() will be handled by on_rx_rtp().
         */
        if (stream-&gt;dec-&gt;paused) {
            check_tx_rtcp(stream, pj_ntohl(channel-&gt;rtp.out_hdr.ts));
        }

        return PJ_SUCCESS;
    }
</code></pre>
</li>
<li>
<p>接着，函数会增加传输时长，初始化输出帧缓冲区，并检查是否有 DTMF 数字在队列中，如果有则发送数字，否则对音频帧进行编码。</p>
<pre><code class="language-c">	  if (stream-&gt;tx_dtmf_count) {
        int first=0, last=0;

        create_dtmf_payload(stream, &amp;frame_out, 0, &amp;first, &amp;last);

        /* Encapsulate into RTP packet. Note that:
         *  - RTP marker should be set on the beginning of a new event
         *  - RTP timestamp is constant for the same packet.
         */
        status = pjmedia_rtp_encode_rtp( &amp;channel-&gt;rtp,
                                         stream-&gt;tx_event_pt, first,
                                         (int)frame_out.size,
                                         (first ? rtp_ts_len : 0),
                                         (const void**)&amp;rtphdr,
                                         &amp;rtphdrlen);

        if (last) {
            /* This is the last packet for the event.
             * Increment the RTP timestamp of the RTP session, for next
             * RTP packets.
             */
            inc_timestamp = stream-&gt;dtmf_duration +
                            ((DTMF_EBIT_RETRANSMIT_CNT-1) *
                             stream-&gt;rtp_tx_ts_len_per_pkt)
                            - rtp_ts_len;
        }

    } 
</code></pre>
</li>
<li>
<p>如果音频帧的缓冲区为空，则发送一段静音，保持 NAT 绑定。</p>
<pre><code class="language-c">	else if (frame-&gt;type == PJMEDIA_FRAME_TYPE_AUDIO &amp;&amp;
               frame-&gt;buf == NULL &amp;&amp;
               stream-&gt;port.info.fmt.id == PJMEDIA_FORMAT_L16 &amp;&amp;
               (stream-&gt;dir &amp; PJMEDIA_DIR_ENCODING))
    {
        pjmedia_frame silence_frame;

        pj_bzero(&amp;silence_frame, sizeof(silence_frame));
        silence_frame.buf = stream-&gt;zero_frame;
        silence_frame.size = stream-&gt;enc_samples_per_pkt * 2;
        silence_frame.type = PJMEDIA_FRAME_TYPE_AUDIO;
        silence_frame.timestamp.u32.lo = pj_ntohl(stream-&gt;enc-&gt;rtp.out_hdr.ts);

        /* Encode! */
        status = pjmedia_codec_encode( stream-&gt;codec, &amp;silence_frame,
                                       channel-&gt;out_pkt_size -
                                       sizeof(pjmedia_rtp_hdr),
                                       &amp;frame_out);
        if (status != PJ_SUCCESS) {
            LOGERR_((stream-&gt;port.info.name.ptr, status,
                    "Codec encode() error"));
            return status;
        }

        /* Encapsulate. */
        status = pjmedia_rtp_encode_rtp( &amp;channel-&gt;rtp,
                                         channel-&gt;pt, 0,
                                         (int)frame_out.size, rtp_ts_len,
                                         (const void**)&amp;rtphdr,
                                         &amp;rtphdrlen);

    
} 
</code></pre>
</li>
<li>
<p>如果音频帧不为空，则对音频帧进行编码，并将 RTP 头封装到输出包中。</p>
<pre><code class="language-c">else if ((frame-&gt;type == PJMEDIA_FRAME_TYPE_AUDIO &amp;&amp;
                frame-&gt;buf != NULL) ||
               (frame-&gt;type == PJMEDIA_FRAME_TYPE_EXTENDED))
    {
        /* Encode! */
        status = pjmedia_codec_encode( stream-&gt;codec, frame,
                                       channel-&gt;out_pkt_size -
                                       sizeof(pjmedia_rtp_hdr),
                                       &amp;frame_out);
        if (status != PJ_SUCCESS) {
            LOGERR_((stream-&gt;port.info.name.ptr, status,
                    "Codec encode() error"));
            return status;
        }

        /* Encapsulate. */
        status = pjmedia_rtp_encode_rtp( &amp;channel-&gt;rtp,
                                         channel-&gt;pt, 0,
                                         (int)frame_out.size, rtp_ts_len,
                                         (const void**)&amp;rtphdr,
                                         &amp;rtphdrlen);

    } 
</code></pre>
</li>
<li>
<p>最后，函数会根据当前是否正在流式传输来设置 RTP 标记位，并将 RTP 包发送到传输层。</p>
<pre><code class="language-c">
    /* Copy RTP header to the beginning of packet */
    pj_memcpy(channel-&gt;out_pkt, rtphdr, sizeof(pjmedia_rtp_hdr));

    /* Special case for DTMF: timestamp remains constant for
     * the same event, and is only updated after a complete event
     * has been transmitted.
     */
    if (inc_timestamp) {
        pjmedia_rtp_encode_rtp( &amp;channel-&gt;rtp, stream-&gt;tx_event_pt, 0,
                                0, inc_timestamp, NULL, NULL);
    }

    /* Set RTP marker bit if currently not streaming */
    if (stream-&gt;is_streaming == PJ_FALSE) {
        pjmedia_rtp_hdr *rtp = (pjmedia_rtp_hdr*) channel-&gt;out_pkt;

        rtp-&gt;m = 1;
        PJ_LOG(5,(stream-&gt;port.info.name.ptr,"Start talksprut.."));
    }

    stream-&gt;is_streaming = PJ_TRUE;

    /* Send the RTP packet to the transport. */
    status = pjmedia_transport_send_rtp(stream-&gt;transport, channel-&gt;out_pkt,
                                        frame_out.size +
                                            sizeof(pjmedia_rtp_hdr));
</code></pre>
</li>
<li>
<p>在发送 RTP 包之后，函数会更新一些统计信息，并且如果启用了保活机制，则记录最后发送数据包的时间。</p>
</li>
</ol>
<p>我们来仔细梳理一下rtp包发送的流程</p>
<p>（1）先设置frame_out.buf 对应的偏置 <code>((char*)channel-&gt;out_pkt) + sizeof(pjmedia_rtp_hdr);</code></p>
<p>（2）调用pjmedia_codec_encode，对frame编码结果输出到frame_out中，此时frame_out.buf获取到rtp payload，相应地(char*)channel-&gt;out_pkt) + sizeof(pjmedia_rtp_hdr处获取到rtp payload</p>
<p>（3）添加rtp头部，调用pjmedia_rtp_encode_rtp，hannel-&gt;rtp-&gt;out_hdr，并将头部拷贝至(char*)channel-&gt;out_pkt)处，至此channel-&gt;out_pkt存放地为编码后的rtp包</p>
<p>（4）Send the RTP packet to the transport. 调用pjmedia_transport_send_rtp</p>
<p>我们就主要看pjmedia_transport_send_rtp了，其实就是op-&gt;send_rtp 的封装，由初始化可知send_rtp为transport_send_rtcp</p>
<pre><code class="language-c">PJ_INLINE(pj_status_t) pjmedia_transport_send_rtp(pjmedia_transport *tp,
                                                  const void *pkt,
                                                  pj_size_t size)
{
    return (*tp-&gt;op-&gt;send_rtp)(tp, pkt, size);
}

</code></pre>
<h2 id="4transport_send_rtp"><a class="header" href="#4transport_send_rtp">4、transport_send_rtp</a></h2>
<p>直接调用transport_send_rtcp2</p>
<pre><code class="language-c">/* Called by application to send RTP packet */
static pj_status_t transport_send_rtp( pjmedia_transport *tp,
                                       const void *pkt,
                                       pj_size_t size)
{
    struct transport_udp *udp = (struct transport_udp*)tp;
    pj_ssize_t sent;
    unsigned id;
    struct pending_write *pw;
    pj_status_t status;

    /* Must be attached */
    //PJ_ASSERT_RETURN(udp-&gt;attached, PJ_EINVALIDOP);

    /* Check that the size is supported */
    PJ_ASSERT_RETURN(size &lt;= PJMEDIA_MAX_MTU, PJ_ETOOBIG);

    if (!udp-&gt;started) {
        return PJ_SUCCESS;
    }

    /* Simulate packet lost on TX direction */
    if (udp-&gt;tx_drop_pct) {
        if ((pj_rand() % 100) &lt;= (int)udp-&gt;tx_drop_pct) {
            PJ_LOG(5,(udp-&gt;base.name, 
                      "TX RTP packet dropped because of pkt lost "
                      "simulation"));
            return PJ_SUCCESS;
        }
    }


    id = udp-&gt;rtp_write_op_id;
    pw = &amp;udp-&gt;rtp_pending_write[id];
    if (pw-&gt;is_pending) {
        /* There is still currently pending operation for this buffer. */
        PJ_LOG(4,(udp-&gt;base.name, "Too many pending write operations"));
        return PJ_EBUSY;
    }
    pw-&gt;is_pending = PJ_TRUE;

    /* We need to copy packet to our buffer because when the
     * operation is pending, caller might write something else
     * to the original buffer.
     */
    pj_memcpy(pw-&gt;buffer, pkt, size);

    sent = size;
    status = pj_ioqueue_sendto( udp-&gt;rtp_key, 
                                &amp;udp-&gt;rtp_pending_write[id].op_key,
                                pw-&gt;buffer, &amp;sent, 0,
                                &amp;udp-&gt;rem_rtp_addr, 
                                udp-&gt;addr_len);

    if (status != PJ_EPENDING) {
        /* Send operation has completed immediately. Clear the flag. */
        pw-&gt;is_pending = PJ_FALSE;
    }

    udp-&gt;rtp_write_op_id = (udp-&gt;rtp_write_op_id + 1) %
                           PJ_ARRAY_SIZE(udp-&gt;rtp_pending_write);

    if (status==PJ_SUCCESS || status==PJ_EPENDING)
        return PJ_SUCCESS;

    return status;
}
</code></pre>
<p>udp-&gt;rtp_write_op_id;是当前write操作可用的id，udp-&gt;rtp_pending_write是Pending write对象用于指示udp-&gt;rtp_pending_write[udp-&gt;rtp_write_op_id]是否有pending的write 操作如果有pending 返回。没有的话将该id处置为pending <code>pw-&gt;is_pending = PJ_TRUE; </code> 调用pj_ioqueue_sendto  最后需要将id+1</p>
<h2 id="5pj_ioqueue_sendto"><a class="header" href="#5pj_ioqueue_sendto">5、pj_ioqueue_sendto</a></h2>
<p>参数key来着 udp-&gt;rtp_key 在 pj_ioqueue_register_sock2中初始化，绑定到rtp socket</p>
<p>参数op_key来自 transport_udp::udp-&gt;rtp_pending_write[id].op_key，在transport_media_start中设置为空</p>
<p>如果key对应的writelist不为空，直接发送调用pj_sock_sendto</p>
<pre><code class="language-c">	 if (pj_list_empty(&amp;key-&gt;write_list)) {
        /*
         * See if data can be sent immediately.
         */
        sent = *length;
        status = pj_sock_sendto(key-&gt;fd, data, &amp;sent, flags, addr, addrlen);
        
    }
</code></pre>
<p>否则初始化write_operation:: write_op 主要需要将要发送的rtp数据保存在write_op中，然后挂在key对应的writelist队列上</p>
<pre><code class="language-c">		write_op-&gt;op = PJ_IOQUEUE_OP_SEND_TO;
    write_op-&gt;buf = (char*)data;
    write_op-&gt;size = *length;
    write_op-&gt;written = 0;
    write_op-&gt;flags = flags;
    pj_memcpy(&amp;write_op-&gt;rmt_addr, addr, addrlen);
    write_op-&gt;rmt_addrlen = addrlen;
    
    pj_ioqueue_lock_key(key);
    /* Check again. Handle may have been closed after the previous check
     * in multithreaded app. If we add bad handle to the set it will
     * corrupt the ioqueue set. See #913
     */
    if (IS_CLOSING(key)) {
        pj_ioqueue_unlock_key(key);
        return PJ_ECANCELLED;
    }
    pj_list_insert_before(&amp;key-&gt;write_list, write_op);
</code></pre>
<p>调用ioqueue_add_to_set进而调用ioqueue_add_to_set2</p>
<pre><code class="language-c">static void ioqueue_add_to_set2(pj_ioqueue_t *ioqueue,
                                pj_ioqueue_key_t *key,
                                unsigned event_types )
{
    pj_uint32_t events = key-&gt;ev.events;

    if (event_types &amp; READABLE_EVENT)
        events |= EPOLLIN;
    if (event_types &amp; WRITEABLE_EVENT)
        events |= EPOLLOUT;
    if (event_types &amp; EXCEPTION_EVENT)
        events |= EPOLLERR;

    if (events != key-&gt;ev.events)
        update_epoll_event_set(ioqueue, key, events);
}
</code></pre>
<p>根据 event_types 设置 events 调用 update_epoll_event_set  这里event_types是WRITEABLE_EVENT</p>
<pre><code class="language-c">static void update_epoll_event_set(pj_ioqueue_t *ioqueue,
                                   pj_ioqueue_key_t *key,
                                   pj_uint32_t events)
{
    int rc;
    /* From epoll_ctl(2):
     * EPOLLEXCLUSIVE may be used only in an EPOLL_CTL_ADD operation;
     * attempts to employ it with EPOLL_CTL_MOD yield an error.
     */
    if (key-&gt;ev.events &amp; EPOLLEXCLUSIVE) {
        rc = os_epoll_ctl(ioqueue-&gt;epfd, EPOLL_CTL_DEL, key-&gt;fd, &amp;key-&gt;ev);
        key-&gt;ev.events = events;
        rc = os_epoll_ctl(ioqueue-&gt;epfd, EPOLL_CTL_ADD, key-&gt;fd, &amp;key-&gt;ev);
    } else {
        key-&gt;ev.events = events;
        rc = os_epoll_ctl(ioqueue-&gt;epfd, EPOLL_CTL_MOD, key-&gt;fd, &amp;key-&gt;ev);
    }

    if (rc != 0) {
        pj_status_t status = pj_get_os_error();
        PJ_PERROR(1,(THIS_FILE, status,
                     "epol_ctl(MOD) error (events=0x%x)", events));
    }
}
</code></pre>
<p>这里修改监测rtp socket事件EPOLL_CTL_MOD修改为EPOLLOUT 触发</p>
<h2 id="6ioqueue_epoll参与"><a class="header" href="#6ioqueue_epoll参与">6、ioqueue_epoll参与</a></h2>
<p>这里不一定是上述追踪的rtp包</p>
<p>当pj_ioqueue_poll工作线程 调用os_epoll_wait 发现监测的EPOLLOUT写触发，调用ioqueue_dispatch_write_event写操作，在ioqueue_dispatch_write_event中先看key write_list上有没有pending_write,有的话，从write_list取出，根据write_list的 write_op确定写大小，要写入的数据，将数据写入调用pj_sock_send函数Transmit data to the socket.，最后调用on_write_complete，回调函数已在pj_ioqueue_register_sock2时设置过，传入write_op为on_rtp_data_sent</p>
<pre><code class="language-c">if (h-&gt;cb.on_write_complete &amp;&amp; !IS_CLOSING(h)) {
                (*h-&gt;cb.on_write_complete)(h, 
                                           (pj_ioqueue_op_key_t*)write_op,
                                           write_op-&gt;written);
            }
</code></pre>
<pre><code class="language-c">static void on_rtp_data_sent(pj_ioqueue_key_t *key, 
                             pj_ioqueue_op_key_t *op_key, 
                             pj_ssize_t bytes_sent)
{
    struct transport_udp *udp;
    unsigned i;

    PJ_UNUSED_ARG(bytes_sent);

    udp = (struct transport_udp*) pj_ioqueue_get_user_data(key);

    for (i = 0; i &lt; PJ_ARRAY_SIZE(udp-&gt;rtp_pending_write); ++i) {
        if (&amp;udp-&gt;rtp_pending_write[i].op_key == op_key) {
            udp-&gt;rtp_pending_write[i].is_pending = PJ_FALSE;
            break;
        }
    }
}
</code></pre>
<p>遍历transport_udp udp中的rtp_pending_write 找到与目标 op_key一致的位置，将is_pending置为false完成</p>
<h2 id="附相互指向关系"><a class="header" href="#附相互指向关系">附：相互指向关系</a></h2>
<p>stream.user_data-》snd_port，</p>
<p>snd_port.port-》port</p>
<p>port-&gt;port_data.pdata;-》stream</p>
<p>stream-&gt;transport-》pjmedia_transport</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="html/tsx_on_state_null.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="数据全流程.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="html/tsx_on_state_null.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="数据全流程.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
