<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PJSIP_STUDY</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="SIP.html"><strong aria-hidden="true">1.</strong> sip协议概述</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> 原理机制</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="State.html"><strong aria-hidden="true">2.1.</strong> 状态机</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.</strong> 流程图</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="make_call.html"><strong aria-hidden="true">2.2.1.</strong> make call流程图</a></li><li class="chapter-item expanded "><a href="pjsip_dlg_create_uac.html"><strong aria-hidden="true">2.2.2.</strong> Create an UAC dialog</a></li><li class="chapter-item expanded "><a href="on_make_call_med_tp_complete.html"><strong aria-hidden="true">2.2.3.</strong> Outgoing call callback when media transport creation is completed</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 常见数据结构与工具</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="pjsua_call.html"><strong aria-hidden="true">3.1.</strong> pjsua_call</a></li><li class="chapter-item expanded "><a href="pjsua_acc.html"><strong aria-hidden="true">3.2.</strong> pjsua_acc</a></li><li class="chapter-item expanded "><a href="pjsua_data.html"><strong aria-hidden="true">3.3.</strong> pjsua_data</a></li><li class="chapter-item expanded "><a href="SDP.html"><strong aria-hidden="true">3.4.</strong> SDP</a></li><li class="chapter-item expanded "><a href="Dialog.html"><strong aria-hidden="true">3.5.</strong> Dialog</a></li><li class="chapter-item expanded "><a href="Session.html"><strong aria-hidden="true">3.6.</strong> Session</a></li><li class="chapter-item expanded "><a href="transaction.html"><strong aria-hidden="true">3.7.</strong> transaction</a></li><li class="chapter-item expanded "><a href="transport.html"><strong aria-hidden="true">3.8.</strong> transport</a></li><li class="chapter-item expanded "><a href="sendData.html"><strong aria-hidden="true">3.9.</strong> 数据发送数据结构</a></li><li class="chapter-item expanded "><a href="PJSIP_log.html"><strong aria-hidden="true">3.10.</strong> pjsip log</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PJSIP_STUDY</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="总述"><a class="header" href="#总述">总述</a></h2>
<ol>
<li>软电话A 向 B 发送一个 SIP消息 INVITE， 邀请B通话</li>
<li>软电话B振铃，向A 回复一个SIP消息 RING, 通知 A 正在振铃中，请A等待</li>
<li>软电话B提机，向A发一个SIP消息 OK, 通知 A 可以通话了</li>
<li>软电话A 向 B 回复一个回应消息 ACK，正式启动通话</li>
<li>接下来，双方通话</li>
<li>软电话B挂机，向 A 发一个SIP消息 BYE, 通知 A 通话结束</li>
<li>软电话A 向 B 回复一个消息 OK, 通话结束</li>
</ol>
<p>含有代理服务器</p>
<ul>
<li>代理服务器接收到了 INVITE 请求，然后发送了一个 100 (Trying) 响应给 Alice 的软电话。这个 100 (Trying) 响应表示这个 INVITE 已经被收到，代理正在通过路由设置路由这个 INVITE 到其目的地。</li>
<li>atlanta.com代理服务器定位到这个代理服务器在 biloxi.com，它可能执行一个特别的 DNS 查询来找到服务 biloxi.com 域的 SIP 服务器。获得 biloxi.com 代理服务器的 IP 地址，然后转发或者在这里代理其 INVITE 请求。在转发这个请求之前，这个 atlanta.com 代理服务器添加另外一个 Via 头字段，这个头字段包含自己的地址（这个 INVITE 已经在第一个 Via 包含了 Alice 的地址）</li>
<li>biloxi.com代理服务器收到这个 INVITE 消息后，然后回复一个带 100 (Trying) 响应消息到
atlanta.com 代理服务器，表示它已经收到了这个 INVITE 消息，正在处理这个请求。</li>
<li>代理服务器会查询一个定位服务器，我们称之为定位服务，定位服务包含当前 Bob 的IP 地址。biloxi.com 代理服务器会添加另外一个 Via header ，并且携带自己的 IP 地址，这个地址是针对这个 INVITE 请求的，代理转发这个请求到 Bob 的 SIP 软电话。</li>
<li>Bob 决定是否应答这个呼叫，这里 Bob 的软电话会产生振铃提示。Bob 的软电话提示 180 振铃，这个响应消息会路由根据相反的方向回到两个代理服务器。每个代理使用 Via header 域值来决定发送响应的地址方向，并且从顶部路由记录中删除自己的地址。因此，尽管要求 DNS 和定位服务查询 路由这个初始的 INVITE 请求，180（Ringing）响应返回到呼叫方时可以没有查询消息或没有代理服务器中所保持的状态。</li>
<li>Bob 决定应答这个呼叫。当他拿起电话听筒时，他的 SIP 电话会发送一个 200 (OK) 响应消息来表示这个呼叫已经应答。这个 200 (OK) 包含了一个消息体，这个消息体带了这个呼叫会话的媒体描述类型，这个媒体描述中说明了 Bob 希望和Alice 创建会话。</li>
<li>最后，Alice 软电话发送一个确认消息 ACK，这个消息发送到 Bob 软电话来确认最终响应 (200 (OK))已收到。在这个示例中，这个 ACK 是通过 Alice 软电话直接被发送到了 Bob 软电话，发送过程绕开了两个代理服务器。这样处理的原因就是因为两个终端已经通过互相学习知道对方的地址，双方地址是通过 INVITE/200（OK）交互时的 Contact 头获得，当然这个地址在初始时的 INVITE 是双方都不知道的。两个代理服务器的查询服务也不需要，因此，代理服务器则会退出这个呼叫流程。</li>
<li>Alice 或 Bob 任何一方都可以有权决定修改媒体会话的属性。修改会话属性是通过发送一个 re-INVITE 消息，在此消息中包含一个新的媒体描述来实现。这个 re-INVITE 涉及到了已存在的 dialog,因此其他的参与方知道这个消息是修改了现在的会话，而不是重新建立的新会话。其他方发送一个 200（ok）接受这个修改。请求方对 200（ok）发送一个 ACK。如果其他方不能接受这个修改的话，它会发生一个错误响应，例如 488 (Not Acceptable Here)，同样也接收一个 ACK 确认消息。但是，这个 re-INVITE 失败不会导致目前的呼叫失败-这个会话仍然会继续使用以前协商的属性。</li>
<li>在呼叫结束后，Bob 首先挂机(hangs up)，并且生成一个 BYE 消息。这个 BYE 会直接
路由返回到 Alice 的软电话，这里仍然绕过了代理。 Alice 确认了 BYE 接收，发送一个
200（ok），结束这个会话和 BYE 消息事务。</li>
<li>Bob 软电话基于初始化处理，在一定周期内 Bob 软电话对在biloxi.com 的服务器发送 REGISTER 消息，我们称之为 SIP registrar 或者 SIP 注册。REGISTER 消息关联 Bob 的 SIP 软电话或者 SIPS URI (sip:bob@biloxi.com)，这个机器是当前 Bob 写入记录的地址（它在 Contact 头中传输 SIP 或者 SIP URL）。 这个注册会写入此关联，也被称之为在数据库中的绑定或者定位服务，此定位服务可以使用在biloxi.com 域的代理中。经常，对于一个域的注册服务器需要和这个域的代理协同工作。这里一定要注意，区分不同类型的 SIP 服务器功能概念是非常重要的，它们区别是在于逻辑处理的不同，而不是物理上，形体上的不同</li>
</ul>
<h2 id="structure-of-the-protocol"><a class="header" href="#structure-of-the-protocol">Structure of the Protocol</a></h2>
<ol>
<li>SIP 结构的最低层是语法和解码层。解码是通过增强的 Backus-Naur Form grammar(BNF)语法来实现的。</li>
<li>第二层是传输层。它定义了用户如何发送请求，如何接收响应和服务器如何通过网络接收请求和发送响应。所有 SIP 网元都包含一个传输层。</li>
<li>第三层是事务层。事务是 SIP 的基础核心模块。事务是一个由用户端事务对服务器端事务发送的请求，用户端使用传输层对服务器端发送事务请求，所有的服务器端事务所携带响应消息返回到客户端。事务层处理应用层的重传，对请求响应的匹配和应用层超时管理。 任何由用户代理（UAC）完成的任务通过使用一系列的事务来触发。 用户代理包含了一个事务层，就像是一个状态代理。 无状态代理没有包含事务层。事务层有一个用户端模块（称之为用户事
务）和一个服务器端事务模块（称之为服务器端模块），每个模块通过各自的有限状态机来呈现，状态机来处理每个特别的请求</li>
<li>在事务层上面的是事务用户（TU）。每个 SIP 实体，除了无状态代理都是一个事务用户。<strong>当一个 TU 希望发送一个请求时，它会创建一个用户事务实例，然后把这个实例传递给这个请求，并且携带目的地 IP 地址，端口和传输请求</strong>。一个创建了用户事务的TU 也可以取消这个用户事务。当用户取消了一个事务时，它会请求服务器停止进一步的处理，变换到退出的状态，这个状态是这个事务初始化前的退出状态，并且生成对这个事务生成错误响应消息。 这个处理过程是通过一个 CANCEL 请求来处理，它构成了属于自己的事务，但是仅针对这个被取消的事务</li>
</ol>
<h2 id="术语"><a class="header" href="#术语">术语</a></h2>
<h3 id="outbound-proxy"><a class="header" href="#outbound-proxy">Outbound Proxy</a></h3>
<p>它是一个代理，负责接收从客户端发出的请求，即使它可能不是一个通过 Request-URI 解析度服务器。 通常情况下，一个 UA 可以通过 outbound proxy手动配置，或通过自动配置协议进行学习。</p>
<h3 id="location-service"><a class="header" href="#location-service">Location Service</a></h3>
<p>定位服务用来支持一个 SIP 重定位或代理服务器来获得关于被呼叫方可能存在的地址信息。它包含一个绑定的 address-of-record 列表数值，这些从从零个到多个 contact 地址。这个绑定关系可以通过多种方式来创建或者删除；此协议细节中定义了一个 REGISTER method 来更新绑定关系。</p>
<h3 id="redirect-server"><a class="header" href="#redirect-server">Redirect Server</a></h3>
<p>重定向服务器是一个用户代理服务器，它会对接收的请求产生 3xx 响应，重新定向用户，让用户联系其他可选的 URL 列表中的 URI 地址。</p>
<h3 id="request"><a class="header" href="#request">Request</a></h3>
<p>请求是一个由用户端发送到服务器的 SIP 消息，请求的目的是触发一个特别的操作。</p>
<h3 id="response"><a class="header" href="#response">Response</a></h3>
<p>响应是一个由服务器端发送到用户端的 SIP 消息，其目的是说明请求发送后服务器端回复的状态。</p>
<h3 id="route-set"><a class="header" href="#route-set">Route Set</a></h3>
<p>路由集是一组有序 SIP 或者 SIPS URI 的集和，它用来表示当发送 一个特别的请求时所经过的代理列表。 路由集通过路由头，例如 Record-Route 或者经过配置后获得。</p>
<h3 id="stateful-proxy"><a class="header" href="#stateful-proxy">Stateful Proxy</a></h3>
<p>状态代理是一个逻辑实体，它按照规范中请求处理的流程保持用户端和服务器端之间的事务状态机的处理状态，也就是所谓的事务状态代理。状态代理的执行在第 16 章做了进一步的说明。状态代理（事务）和呼叫状态代理是不同的。</p>
<h3 id="stateless-proxy"><a class="header" href="#stateless-proxy">Stateless Proxy</a></h3>
<p>无状态代理是一个逻辑实体，它不会保持用户端和服务器端之间的事务状态机。无状态代理前转从下游收到的每个请求，前转从上游收到的每一个响应。</p>
<h2 id="报文结构"><a class="header" href="#报文结构">报文结构</a></h2>
<pre><code>start-line
message-header
CRLF   //一个表示头结束的空行
[ message-body ]
</code></pre>
<h3 id="requests"><a class="header" href="#requests">Requests</a></h3>
<p>![image-20231227103252240](/Users/huanghaochen/Library/Application Support/typora-user-images/image-20231227103252240.png)</p>
<p>Method: 此规范定义了六个方法: REGISTER 支持注册联系消息，INVITE，ACK，和CANCEL 支持会话创建，BYE 支持结束会话，OPTIONS 支持对服务器的能力查询。SIP 拓展中定义了其他的方法。</p>
<h3 id="responses"><a class="header" href="#responses">Responses</a></h3>
<p>![image-20231227103448441](/Users/huanghaochen/Library/Application Support/typora-user-images/image-20231227103448441.png)</p>
<h4 id="首行start-line"><a class="header" href="#首行start-line"><strong>首行（start-line）</strong></a></h4>
<p>分请求行(Requests)和状态行(Responses)</p>
<ul>
<li><strong>请求行</strong>: 由<strong>请求类型、请求目的地址和协议版本号</strong>构成。请求类型有：INVITE,ACK,OPTIONS,BYE,CANCEL和REGISTER。</li>
<li><strong>状态行</strong>: 是被叫方向主叫方返回的状态信息，如1xx，2xx，3xx，4xx，5xx，6xx。</li>
</ul>
<h5 id="请求类型"><a class="header" href="#请求类型">请求类型</a></h5>
<ul>
<li><strong>INVITE</strong>：用于发起呼叫请求。INVITE消息包括消息头和数据区两部分。INVITE 消息头包含主、被呼叫的地址，呼叫主题和呼叫优先级等信息。数据区则是关于会话媒体的信息，可由会话描述协议SDP 来实现。</li>
<li><strong>BYE</strong>：当一个用户决定中止会话时，可以使用BYE 来结束会话。</li>
<li><strong>OPTIONS</strong>：用于询问被叫端的能力信息，但OPTIONS 本身并不能发起呼叫。</li>
<li><strong>ACK</strong>： 对已收到的消息进行确认应答。</li>
<li><strong>REGISTER</strong>：用于用户向SIP服务器传送位置信息或地址信息。</li>
<li><strong>CANCEL</strong>：取消当前的请求，但它并不能中止已经建立的连接。</li>
</ul>
<h5 id="状态类型"><a class="header" href="#状态类型">状态类型</a></h5>
<p>![image-20231228150803886](/Users/huanghaochen/Library/Application Support/typora-user-images/image-20231228150803886.png)</p>
<ul>
<li>1xx：临时消息：表示表示请求消息已经收到，后面将继续处理该请求。</li>
<li>2xx：成功消息：表示请求已经被成功的理解、接受或执行。</li>
<li>3xx：重定向消息：表示为了完成请求还需采取更进一步的动作。</li>
<li>4xx：客户机错误：表示该请求含有语法错误或在这个服务器上不能被满足。</li>
<li>5xx：服务器错误：表示该服务器不能处理一个明显有效的请求。</li>
<li>6xx：全局性故障：表示该请求在任何服务器上都不能被实现。</li>
</ul>
<h4 id="消息头message-header"><a class="header" href="#消息头message-header"><strong>消息头（message-header）</strong></a></h4>
<ul>
<li><strong>TO</strong>： 格式：<code>TO: 显示名&lt;接收者URI&gt;;tag=n</code>,显示名和tag可选。接收者URI是SIP网络种唯一标识接收终端的标识符。例：<code>TO: Name&lt;SIP:caller@WORK.COM&gt;;TAG=11111</code>或 <code>TO: sip:caller@work.com</code></li>
<li><strong>FROM</strong>: 给出标识会话发起者的URI。比如：FROM: <code>sip:caller@work.com;tag=hyh8</code> <code>tag</code>是必需的。</li>
<li><strong>CALL-ID</strong>: 用于全局唯一标识正在建立的会话的标识符。 随机数加UAC标识信息。</li>
<li><strong>CSeq</strong>: 用于标识同一会话中不同事务的序号，通常由一个用作序号的整型数和消息类型组成。整个会话操作过程由不同的事务组成，每一事务所涉及的消息的CSeq序号必须相同。</li>
<li><strong>Via</strong>: 为响应消息提供传输路径，当请求消息经过每一跳节点时，每一跳节点都把自身的IP地址信息放入顶层Via中。响应消息则沿着请求消息记录下的传输路径反向传输，首先移走指明自身IP地址信息的顶层消息头</li>
</ul>
<h4 id="消息体"><a class="header" href="#消息体"><strong>消息体</strong></a></h4>
<p>SIP协议一个最主要的作用就是协商媒体信息。媒体信息通过message-body携带，基于SDP会话描述协议。对于PSTN语音编码格式，主要有G711A、G711U、G729等。</p>
<p>SIP协商中主叫方会带上自己支持的所有音频编码列表到被叫方，被叫方一般在回铃时从主叫支持的类型中选出一种或多种自己支持的编码，返回主叫后，双人按顺序选出第一个支持的编码。</p>
<h3 id="invite-消息"><a class="header" href="#invite-消息">INVITE 消息</a></h3>
<h4 id="1起始行start-line"><a class="header" href="#1起始行start-line">(1)起始行(start-line)：</a></h4>
<pre><code>&lt;Method&gt; &lt;URI&gt; &lt;SIP_VERSION&gt;
INVITE sip:some@192.168.31.131:50027 SIP/2.0
</code></pre>
<ul>
<li>Method是请求方法，本例是INVITE, SIP协议规定的Method有六种: INVITE, ACK, CANCEL用于创建对话，BYE用于结束对话, REGISTER用于登记,OPTIONS用于查询服务器能力</li>
<li>URI表示所请求的用户或服务器, 也支持 “tel” URI， 本例是sip:some@192.168.31.131:50027,</li>
<li>SIP_VERSION是 SIP版本号，本例是 SIP/2.0</li>
</ul>
<h4 id="2消息头部header"><a class="header" href="#2消息头部header">(2)消息头部(header)</a></h4>
<p>一个请求消息头部至少要包含六个字段：Via, To, From, CSeq, Caller-ID, Max-Forwards</p>
<p>name : value ; value;</p>
<h5 id="i-via字段"><a class="header" href="#i-via字段">I. Via字段</a></h5>
<pre><code>Via: SIP/2.0/UDP 192.168.31.131:51971;rport;branch=z9hG4bKiYblddPPX
</code></pre>
<ul>
<li>
<p>Via头字段保存所经过SIP网元(客户端或Proxy)的主机名或网络地址（可能还有端口号），消息中的所有Via头字段对请求消息而言，从下至上依次表示到当前所在SIP网元为止，请求消息所经过的路径；对响应消息而言，从上至下依次表示从当前网元开始，响应所应遵循的路径。</p>
</li>
<li>
<p>Via字段包含SIP协议版本以及消息传输所用的传输协议, 此例为: SIP/2.0/UDP</p>
</li>
<li>
<p>branch参数:</p>
<ul>
<li>在SIP网元（UAC或Proxy）发出或转发请求消息时，在其插入的Via字段中必须包含branch参数，该参数用于标识此请求消息所创建的事务。</li>
<li>branch 参数可以用做loop detection，这时参数必须被分成两部分：第一部分符合一般的原则（对于RFC3261，z9hG4bK），第二部分(此例为iYblddPPX)被用来实现loop detection以用来区分loop和spiral。</li>
<li>loop和spiral均指Proxy收到一个请求后转发，然后此转发的请求又重新到达该Proxy，区别是loop中请求的Request-URI以及其他影响Proxy处理的头字段均不变，而Spiral请求中这些部分必需有某个发生改变，spiral发生的典型情况是Request-URI发生改变。Proxy在插入Via字段前，其branch 参数的loop.</li>
<li>detection部分依据以下元素编码：To Tag，From Tag，Call-ID字段，Request-URI，Topmost Via字段，Cseq的序号部分（即与request method无关），以及proxy-require字段，proxy authorization字段。注意：request method不能用于计算branch参数，比如CANCEL以及非2XX response的ACK与其所cancel的request或对应的INVITE属于同一个事务，即其branch参数相同。见RFC3261 P22 P25 P39 P95 P105</li>
</ul>
</li>
</ul>
<h5 id="ii-max-forwards-字段"><a class="header" href="#ii-max-forwards-字段">II. Max-Forwards 字段</a></h5>
<pre><code class="language-shell">    Max-Forwards: 70
</code></pre>
<ul>
<li>Max-Forwards 字段表示request到达UAS的跳数的限制。是一个整数，经过每一跳时减去一。如果Max-Forwards已经是零，可是request还没有到达目的地，则就会产生一个483(too many hops)响应</li>
</ul>
<h5 id="iii-to字段"><a class="header" href="#iii-to字段">III. To字段</a></h5>
<pre><code class="language-shell">   To: &lt;sip:some@192.168.31.131:50027&gt;
</code></pre>
<ul>
<li>To字段表示消息的接收者</li>
<li>To 字段可以有一个tag参数，to tag代表dialog的对等参与者（peer）。在UAC发出一个初始Dialog的请求（如INVITE）时，即发出out-of-dialog请求时，由于dialog还没有建立，不含to tag参数。当UAS收到INVITE请求时，在其发出的2xx或101-199响应中设置to tag参数，与UAC设置的From Tag参数以及Call-ID（呼叫唯一标识）一起作为一个Dialog ID（对话唯一标识，包含To tag，From Tag，Call-ID）的一个部分。RFC3261规定只有INVITE请求与2xx或101-199响应可以建立Dialog（由101-199响应创建的Dialog称为early dialog）。见RFC3261 P70</li>
</ul>
<h5 id="iv-from字段"><a class="header" href="#iv-from字段">IV. From字段</a></h5>
<pre><code class="language-shell">   From: &lt;sip:null@null&gt;;tag=Prf3c3Xc
</code></pre>
<ul>
<li>From字段表示消息的发送者</li>
<li>From字段必须包含tag参数，在UAC发出一个out-of-dialog请求（对话建立请求）时，必须设置一个唯一的tag参数，作为Dialog ID的一个部分。</li>
</ul>
<h5 id="v-call-id字段"><a class="header" href="#v-call-id字段">V. Call-ID字段</a></h5>
<p>邀请id</p>
<pre><code class="language-shell">   Call-ID: cenXTa4i-1423587756904@appletekiAir
</code></pre>
<ul>
<li>是一个邀请(Invitation)或来自同一个UAC用户的所有登记请求(Registeration，包括更新登记，取消登记)以及由此产生的一组响应的唯一标识。<strong>一个邀请可以建立多个Dialog</strong>（当被叫用户有多个联系方式时），这成为Forking，因而Call-ID只是一次呼叫邀请的唯一标识，Call-ID与UAC在发出请求中设置的From Tag字段以及UAS在其相映中设置的To Tag字段三者一起作为一个Dialog-ID。</li>
<li>在一个Dialog中，所有的requests和responses的Call-ID必须一致 同一UA的每一个register 的Call-ID必须一致。</li>
</ul>
<h5 id="vi-cseq-字段"><a class="header" href="#vi-cseq-字段">VI. CSeq 字段</a></h5>
<pre><code class="language-shell">   CSeq: 1 INVITE
</code></pre>
<ul>
<li>用于在同一个Dialog中标识及排序事务（transaction）以及区分新的请求 与请求的重发。</li>
<li>CSeq包括顺序号和方法（method），方法必须和它所对应的request相匹配。对于out-of-dialog的非<strong>register request，取值任意</strong>。</li>
<li>对于dialog内的每一个新的request（如BYE,re-INVITE,OPTION），Cseq的序号加1。但是对于CANCEL,ACK除外。对于ACK而言，Cseq的序号必须与其所对应的request相同。对于CANCEL而言，Cseq的序号也必须与其cancel掉的request相同。</li>
<li>注意：在同一个对话中的UAC和UAS分别维护自己的CSeq序号，他们发出请求的CSeq序号是不相关的。</li>
</ul>
<h5 id="vii-contact-字段"><a class="header" href="#vii-contact-字段">VII. Contact 字段</a></h5>
<pre><code class="language-shell">Contact: &lt;sip:null@192.168.31.131:51971;transport=UDP&gt;
</code></pre>
<ul>
<li>对于非Register事务，Contact header field 主要提供了UAC或UAS的 直接联系SIP URI，UAC在发出的对话建立（out-of-dialog）INVITE请求的Contact字段中提供自己的直接联系SIP URI，在UAS收到该请求后在其发出响应的Contact字段中提供自己的直接联系SIP URI，这样在建立对话后，<strong>UA间可以通过对方的直接联系SIP URI绕过Proxy直接发送请求。</strong></li>
<li>对于Register事务，表示地址绑定中的contact address（vs. address-of-record）</li>
<li>Contact header field contains IP address and port on which the sender is awaiting further requests sent by callee. Other header fields are not important and will be not described here.</li>
</ul>
<h5 id="viii-content-type字段"><a class="header" href="#viii-content-type字段">VIII. Content-Type字段</a></h5>
<pre><code class="language-shell'">     Content-Type: application/sdp
</code></pre>
<ul>
<li>主要表示发给接收器的消息体的媒体类型。如果消息体不是空的，则Content-type header field一定要存在。如果Content-type header field存在，而消息体是空的，表明该类型的媒体流长度是0。</li>
</ul>
<h5 id="viiii-content-length字段"><a class="header" href="#viiii-content-length字段">VIIII. Content-Length字段</a></h5>
<pre><code class="language-shell">    Content-Length: 215
</code></pre>
<p>表示消息体的长度。是十进制数。</p>
<h4 id="3消息体message-body"><a class="header" href="#3消息体message-body">(3)消息体(message body)</a></h4>
<pre><code>v=0            //版本号为0
o=user1 685988692 621323255 IN IP4 192.168.31.131 //建立者用户名＋会话ID＋版本＋网络类型＋地址类型＋地址 
s=-            //会话名
c=IN IP4 192.168.31.131  //连接信息：网络类型＋地址类型＋地址
t=0 0         //会话活动时间 起始时间＋终止时间
m=audio 49432 RTP/AVP 0 8 101   //媒体描述：媒体＋端口＋传送＋格式列表
																	音频 ＋ 端口49432 ＋ 传输协议RTP ＋ 格式AVP，有效负荷0（u率PCM编码） 
																	
a=rtpmap:0 PCMU/8000  //0或多个会话属性： 属性 ＋ 有效负荷＋ 编码名称 ＋ 抽样频率。

a=rtpmap:8 PCMA/8000  // rtpmap ＋   0型  ＋  PCMU  ＋  8KHz 

a=rtpmap:101 telephone-event/8000

a=sendrecv  //a 可以有多个， 见SDP协议


</code></pre>
<h1 id="register"><a class="header" href="#register">REGISTER</a></h1>
<p>allows a central server (registrar) to s<strong>tore the location of a SIP User-Agent.</strong></p>
<p><img src="https://www.kamailio.org/docs/tutorials/sip-introduction/figures/registrar.png" alt="Picture showing a typical registrar" /></p>
<p><img src="https://blog.wildix.com/wp-content/uploads/2018/07/Register-message.jpg" alt="img" /></p>
<pre><code>REGISTER sip:10.10.1.99 SIP/2.0
CSeq: 1 REGISTER
Via: SIP/2.0/UDP 10.10.1.13:5060;
 branch=z9hG4bK78946131-99e1-de11-8845-080027608325;rport
User-Agent: MySipClient/4.0.0
From: &lt;sip:13@10.10.1.99&gt;
 ;tag=d60e6131-99e1-de11-8845-080027608325
Call-ID: e4ec6031-99e1
To: &lt;sip:13@10.10.1.99&gt;
Contact: &lt;sip:13@10.10.1.13&gt;;q=1
Allow: INVITE,ACK,OPTIONS,BYE,CANCEL,SUBSCRIBE,NOTIFY,REFER,MESSAGE,
 INFO,PING
Expires: 3600
Content-Length: 0
Max-Forwards: 70
</code></pre>
<ul>
<li>User-Agent: indicates the SIP Client connecting; most devices will indicate here the manufacturer – product name – software version and other information, such as the MAC address</li>
<li>To: similar to <em>From</em>, in the case of the registration this field is usually the same as <em>From</em>. The tag is missing here but will be filled up by the SIP Server during the reply to the <em>REGISTER</em></li>
<li>Contact: usually indicates where the reply should go to, if rport was not set</li>
<li>Expires: the desired registration duration in seconds</li>
</ul>
<p><a href="https://blog.csdn.net/m0_37915666/article/details/115026427">SIP：松散路由与严格路由-CSDN博客</a></p>
<h2 id="ok"><a class="header" href="#ok">OK</a></h2>
<pre><code>SIP/2.0 200 OK
Via: SIP/2.0/UDP 192.168.1.30:5060;received=66.87.48.68
From: sip:sip2@iptel.org
To: sip:sip2@iptel.org;tag=794fe65c16edfdf45da4fc39a5d2867c.b713
Call-ID: 2443936363@192.168.1.30
CSeq: 63629 REGISTER
Contact: Msip:sip2@66.87.48.68:5060;transport=udp&gt;;q=0.00;expires=120
Server: Sip EXpress router (0.8.11pre21xrc (i386/linux))
Content-Length: 0
Warning: 392 195.37.77.101:5060 &quot;Noisy feedback tells:  
  pid=5110 req_src_ip=66.87.48.68 req_src_port=5060 in_uri=sip:iptel.org 
  out_uri=sip:iptel.org via_cnt==1&quot;
</code></pre>
<h3 id="bye"><a class="header" href="#bye">BYE</a></h3>
<pre><code>BYE sip:info@hypotenuse.example.org SIP/2.0
Via: SIP/2.0/TCP port443.hotmail.example.com:54212;branch=z9hG4bK312bc
Max-Forwards:70
To: &lt;sip:info@hypotenuse.example.org&gt;;tag=63124
From: &lt;sip:pythag42@hotmail.example.com&gt;;tag=9341123
Call-ID: 34283291273
CSeq: 47 BYE
Content-Length: 0
</code></pre>
<p>应答只能由对端UA生成。如果UA收到未知的BYE请求，那么它应答回应481 Dialog/Transaction Does Not Exist</p>
<h3 id="ack"><a class="header" href="#ack">ACK</a></h3>
<pre><code>ACK sip:laplace@mathematica.example.org SIP/2.0
Via: SIP/2.0/TCP 128.5.2.1:5060;branch=z9hG4bK1834
Max-Forwards:70
To: Marquis de Laplace &lt;sip:laplace@mathematica.example.org&gt; ;tag=90210
From: Nathaniel Bowditch &lt;sip:n.bowditch@salem.example.com&gt; ;tag=887865
Call-ID: 152-45-32-N-32-23-47-W
CSeq: 3 ACK
Content-Type: application/sdp
Content-Length: ...
 
v=0
o=bowditch 2590844326 2590944532 IN IP4
s=Bearing
c=IN IP4 salem.example.org t=0 0
m=audio 32852 RTP/AVP 96 0
a=rtpmap:96 SPEEX/8000
a=rtpmap:0 PCMU/8000
</code></pre>
<p>​    ACK方法用于确认收到INVITE请求的最终应答。其它请求方法不需要确认。</p>
<p>​    ACK的CSeq<strong>序号不变</strong>，但方法描述变成ACK。这有助于UAS匹配对应的INVITE事务。</p>
<p>​    ACK消息可以携带application/sdp消息体。如果初始INVITE没有携带SDP信息，就允许在ACK消息中携带。如果INVITE带了SDP消息体，那么就不应该在ACK消息中携带SDP消息体。不能用ACK方法变更初始INVITE所描述的媒体信息，如果需要变更，必须使用re-INVITE或UPDATE方法。在ACK中携带SDP的方式常用于与其它协议交互的场景，特别是在发初始INVITE时不能获取媒体特征的场景。</p>
<p>​</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state"><a class="header" href="#state">State</a></h1>
<p>转载：<a href="https://blog.csdn.net/croop520/article/details/78666799">sip信令超时时间调整_pjsip的最长呼叫等待时间-CSDN博客</a></p>
<p><strong>UAC （呼叫方）状态机转换如下：</strong></p>
<p><img src="https://img-blog.csdn.net/20171129164001702?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Jvb3A1MjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" /></p>
<p>刚开始呼叫时，sip_transaction的状态机处于tsx_on_state_null状态，拨打电话发出INVITE信令后，状态机转为Calling状态，处理函数：tsx_on_state_calling，应用可以收到Calling的状态通知。</p>
<p>之后会收到被叫方发来的100 try信令，状态机转为Processing状态，处理函数：tsx_on_state_proceeding_uac</p>
<p>在收到180 ringing的信令后，还是在tsx_on_state_proceeding_uac中处理，应用会收到Early的状态通知。</p>
<p>如果被叫方接听了该呼叫，会收到被叫方的200 OK信令，状态机会转为Terminated状态，处理函数：tsx_on_state_terminated，应用会收到Connecting的状态通知，之后会通过timeout方式，把状态转为Destroyed。Call的状态也转为Confirmed。</p>
<p><strong>Bye信令状态转换：</strong></p>
<p><img src="https://img-blog.csdn.net/20171129165213239?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Jvb3A1MjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" /></p>
<p>发出Bye信令时，状态机转为Calling状态（tsx_on_state_calling），在收到200OK信令时，转为Completed状态（tsx_on_state_completed_uac），应用会收到Disconnected的状态通知</p>
<p>，之后通过timeout的方式，状态转为Terminated和Destroyed</p>
<p><strong>UAS（被叫方）状态机转换如下：</strong></p>
<p><em><strong>*<img src="https://img-blog.csdn.net/20171129170550757?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Jvb3A1MjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" />*</strong></em></p>
<p>Bye状态转换：</p>
<p><img src="https://img-blog.csdn.net/20171129170759124?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Jvb3A1MjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" /></p>
<p>被叫方的转换和呼叫方类似。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="make_call"><a class="header" href="#make_call">make_call</a></h2>
<p><a href="../html/make_call.html">make_call流程图</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pjsip_dlg_create_uac"><a class="header" href="#pjsip_dlg_create_uac">pjsip_dlg_create_uac</a></h2>
<p><a href="../html/pjsip_dlg_create_uac.html">pjsip_dlg_create_uac</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="on_make_call_med_tp_complete"><a class="header" href="#on_make_call_med_tp_complete">on_make_call_med_tp_complete</a></h2>
<p><a href="../html/on_make_call_med_tp_complete.html">on_make_call_med_tp_complete</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pjsua_call"><a class="header" href="#pjsua_call">pjsua_call</a></h2>
<pre><code class="language-c">/** 
 * Structure to be attached to invite dialog. 
 * Given a dialog &quot;dlg&quot;, application can retrieve this structure
 * by accessing dlg-&gt;mod_data[pjsua.mod.id].
 */
struct pjsua_call
{
    unsigned             index;     /**&lt; Index in pjsua array.              */
    pjsua_call_setting   opt;       /**&lt; Call setting.                      */
    pj_bool_t            opt_inited;/**&lt; Initial call setting has been set,
                                         to avoid different opt in answer.  */
    pjsip_inv_session   *inv;       /**&lt; The invite session.                */
    void                *user_data; /**&lt; User/application data.             */
    pjsip_status_code    last_code; /**&lt; Last status code seen.             */
    pj_str_t             last_text; /**&lt; Last status text seen.             */
    pj_time_val          start_time;/**&lt; First INVITE sent/received.        */
    pj_time_val          res_time;  /**&lt; First response sent/received.      */
    pj_time_val          conn_time; /**&lt; Connected/confirmed time.          */
    pj_time_val          dis_time;  /**&lt; Disconnect time.                   */
    pjsua_acc_id         acc_id;    /**&lt; Account index being used.          */
    int                  secure_level;/**&lt; Signaling security level.        */
    pjsua_call_hold_type call_hold_type; /**&lt; How to do call hold.          */
    pj_bool_t            local_hold;/**&lt; Flag for call-hold by local.       */
    void                *hold_msg;  /**&lt; Outgoing hold tx_data.             */
    pj_str_t             cname;     /**&lt; RTCP CNAME.                        */
    char                 cname_buf[16];/**&lt; cname buffer.                   */

    unsigned             med_cnt;   /**&lt; Number of media in SDP.            */
    pjsua_call_media     media[PJSUA_MAX_CALL_MEDIA]; /**&lt; Array of media   */
    unsigned             med_prov_cnt;/**&lt; Number of provisional media.     */
    pjsua_call_media     media_prov[PJSUA_MAX_CALL_MEDIA];
                                    /**&lt; Array of provisional media.        */
    pj_bool_t            med_update_success;
                                    /**&lt; Is media update successful?        */
    pj_bool_t            hanging_up;/**&lt; Is call in the process of hangup?  */

    int                  audio_idx; /**&lt; First active audio media.          */
    pj_mutex_t          *med_ch_mutex;/**&lt; Media channel callback's mutex.  */
    pjsua_med_tp_state_cb   med_ch_cb;/**&lt; Media channel callback.          */
    pjsua_med_tp_state_info med_ch_info;/**&lt; Media channel info.            */

    pjsip_evsub         *xfer_sub;  /**&lt; Xfer server subscription, if this
                                         call was triggered by xfer.        */
    pj_stun_nat_type     rem_nat_type; /**&lt; NAT type of remote endpoint.    */

    char    last_text_buf_[128];    /**&lt; Buffer for last_text.              */

    struct {
        int              retry_cnt;  /**&lt; Retry count.                      */
    } lock_codec;                    /**&lt; Data for codec locking when answer
                                          contains multiple codecs.         */

    struct {
        pjsip_dialog        *dlg;    /**&lt; Call dialog.                      */
        pjmedia_sdp_session *rem_sdp;/**&lt; Remote SDP.                       */
        pj_pool_t           *pool_prov;/**&lt; Provisional pool.               */
        pj_bool_t            med_ch_deinit;/**&lt; Media channel de-init-ed?   */
        union {
            struct {
                pjsua_msg_data  *msg_data;/**&lt; Headers for outgoing INVITE. */
                pj_bool_t        hangup;  /**&lt; Call is hangup?              */
            } out_call;
            struct {            
                call_answer      answers;/**&lt; A list of call answers.       */
                pj_bool_t        hangup;/**&lt; Call is hangup?                */
                pjsip_dialog    *replaced_dlg; /**&lt; Replaced dialog.        */
            } inc_call;
        } call_var;
    } async_call;                      /**&lt; Temporary storage for async
                                            outgoing/incoming call.         */

    pj_bool_t            rem_offerer;  /**&lt; Was remote SDP offerer?         */
    unsigned             rem_aud_cnt;  /**&lt; No of active audio in last remote
                                            offer.                          */
    unsigned             rem_vid_cnt;  /**&lt; No of active video in last remote
                                            offer.                          */
    
    pj_bool_t            rx_reinv_async;/**&lt; on_call_rx_reinvite() async.   */
    pj_timer_entry       reinv_timer;  /**&lt; Reinvite retry timer.           */
    pj_bool_t            reinv_pending;/**&lt; Pending until CONFIRMED state.  */
    pj_bool_t            reinv_ice_sent;/**&lt; Has reinvite for ICE upd sent? */
    pjsip_rx_data       *incoming_data;/**&lt; Cloned incoming call rdata.
                                            On pjsua2, when handling incoming 
                                            call, onCreateMediaTransport() will
                                            not be called since the call isn't
                                            created yet. This temporary 
                                            variable is used to handle such 
                                            case, see ticket #1916.         */

    struct {
        pj_bool_t        enabled;
        pj_bool_t        remote_sup;
        pj_bool_t        remote_dlg_est;
        pjsua_op_state   trickling;
        int              retrans18x_count;
        pj_bool_t        pending_info;
        pj_timer_entry   timer;
    } trickle_ice;

    pj_timer_entry       hangup_timer;  /**&lt; Hangup retry timer.            */
    unsigned             hangup_retry;  /**&lt; Number of hangup retries.      */
    unsigned             hangup_code;   /**&lt; Hangup code.                   */
    pj_str_t             hangup_reason; /**&lt; Hangup reason.                 */
    pjsua_msg_data      *hangup_msg_data;/**&lt; Hangup message data.          */
};
</code></pre>
<h3 id="pjsua_call_hold_type"><a class="header" href="#pjsua_call_hold_type">pjsua_call_hold_type</a></h3>
<pre><code class="language-c">/**
 * This enumeration specifies how we should offer call hold request to
 * remote peer. The default value is set by compile time constant
 * PJSUA_CALL_HOLD_TYPE_DEFAULT, and application may control the setting
 * on per-account basis by manipulating \a call_hold_type field in
 * #pjsua_acc_config.
 */
typedef enum pjsua_call_hold_type
{
    /**
     * This will follow RFC 3264 recommendation to use a=sendonly,
     * a=recvonly, and a=inactive attribute as means to signal call
     * hold status. This is the correct value to use.
     */
    PJSUA_CALL_HOLD_TYPE_RFC3264,

    /**
     * This will use the old and deprecated method as specified in RFC 2543,
     * and will offer c=0.0.0.0 in the SDP instead. Using this has many
     * drawbacks such as inability to keep the media transport alive while
     * the call is being put on hold, and should only be used if remote
     * does not understand RFC 3264 style call hold offer.
     */
    PJSUA_CALL_HOLD_TYPE_RFC2543

} pjsua_call_hold_type;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pjsua_acc"><a class="header" href="#pjsua_acc">pjsua_acc</a></h2>
<pre><code class="language-c">/**
 * Account
 */
typedef struct pjsua_acc
{
    pj_pool_t       *pool;          /**&lt; Pool for this account.         */
    pjsua_acc_config cfg;           /**&lt; Account configuration.         */
    pj_bool_t        valid;         /**&lt; Is this account valid?         */

    int              index;         /**&lt; Index in accounts array.       */
    pj_str_t         display;       /**&lt; Display name, if any.          */
    pj_str_t         user_part;     /**&lt; User part of local URI.        */
    pj_bool_t        is_sips;       /**&lt; Local URI uses &quot;sips&quot;?         */
    pj_str_t         contact;       /**&lt; Our Contact header.            */
    pj_str_t         reg_contact;   /**&lt; Contact header for REGISTER.
                                         It may be different than acc
                                         contact if outbound is used    */
    pj_bool_t        contact_rewritten;
                                    /**&lt; Contact rewrite has been done? */
    pjsip_host_port  via_addr;      /**&lt; Address for Via header         */
    pjsip_transport *via_tp;        /**&lt; Transport associated with
                                         the Via address                */

    pj_str_t         srv_domain;    /**&lt; Host part of reg server.       */
    int              srv_port;      /**&lt; Port number of reg server.     */

    pjsip_regc      *regc;          /**&lt; Client registration session.   */
    pj_status_t      reg_last_err;  /**&lt; Last registration error.       */
    int              reg_last_code; /**&lt; Last status last register.     */

    pj_str_t         reg_mapped_addr;/**&lt; Our addr as seen by reg srv.
                                          Only if allow_sdp_nat_rewrite
                                          is set                        */

    struct {
        pj_bool_t        active;    /**&lt; Flag of reregister status.     */
        pj_timer_entry   timer;     /**&lt; Timer for reregistration.      */
        void            *reg_tp;    /**&lt; Transport for registration.    */
        unsigned         attempt_cnt; /**&lt; Attempt counter.             */
    } auto_rereg;                   /**&lt; Reregister/reconnect data.     */

    pj_timer_entry   ka_timer;      /**&lt; Keep-alive timer for UDP.      */
    pjsip_transport *ka_transport;  /**&lt; Transport for keep-alive.      */
    pj_sockaddr      ka_target;     /**&lt; Destination address for K-A    */
    unsigned         ka_target_len; /**&lt; Length of ka_target.           */

    pjsip_route_hdr  route_set;     /**&lt; Complete route set inc. outbnd.*/
    pj_uint32_t      global_route_crc; /** CRC of global route setting. */
    pj_uint32_t      local_route_crc;  /** CRC of account route setting.*/

    unsigned         rfc5626_status;/**&lt; SIP outbound status:
                                           0: not used
                                           1: requested
                                           2: acknowledged by servers   */
    pj_str_t         rfc5626_instprm;/**&lt; SIP outbound instance param.  */
    pj_str_t         rfc5626_regprm;/**&lt; SIP outbound reg param.        */
    unsigned         rfc5626_flowtmr;/**&lt; SIP outbound flow timer.      */

    unsigned         cred_cnt;      /**&lt; Number of credentials.         */
    pjsip_cred_info  cred[PJSUA_ACC_MAX_PROXIES]; /**&lt; Complete creds.  */

    pj_bool_t        online_status; /**&lt; Our online status.             */
    pjrpid_element   rpid;          /**&lt; RPID element information.      */
    pjsua_srv_pres   pres_srv_list; /**&lt; Server subscription list.      */
    pjsip_publishc  *publish_sess;  /**&lt; Client publication session.    */
    pj_bool_t        publish_state; /**&lt; Last published online status   */

    pjsip_evsub     *mwi_sub;       /**&lt; MWI client subscription        */
    pjsip_dialog    *mwi_dlg;       /**&lt; Dialog for MWI sub.            */

    pj_uint16_t      next_rtp_port; /**&lt; Next RTP port to be used.      */
    pjsip_transport_type_e tp_type; /**&lt; Transport type (for local acc or
                                         transport binding)             */
    pjsua_ip_change_op ip_change_op;/**&lt; IP change process progress.    */
} pjsua_acc;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pjsua_data--pjsua_var"><a class="header" href="#pjsua_data--pjsua_var">pjsua_data  pjsua_var</a></h2>
<pre><code class="language-c">/**
 * Global pjsua application data.
 */
struct pjsua_data
{

    /* Control: */
    pj_caching_pool      cp;        /**&lt; Global pool factory.           */
    pj_pool_t           *pool;      /**&lt; pjsua's private pool.          */
    pj_pool_t           *timer_pool;/**&lt; pjsua's timer pool.            */
    pj_mutex_t          *mutex;     /**&lt; Mutex protection for this data */
    unsigned             mutex_nesting_level; /**&lt; Mutex nesting level. */
    pj_thread_t         *mutex_owner; /**&lt; Mutex owner.                 */
    pjsua_state          state;     /**&lt; Library state.                 */

    /* Logging: */
    pjsua_logging_config log_cfg;   /**&lt; Current logging config.        */
    pj_oshandle_t        log_file;  /**&lt;Output log file handle          */

    /* SIP: */
    pjsip_endpoint      *endpt;     /**&lt; Global endpoint.               */
    pjsip_module         mod;       /**&lt; pjsua's PJSIP module.          */
    pjsua_transport_data tpdata[8]; /**&lt; Array of transports.           */
    pjsip_tp_state_callback old_tp_cb; /**&lt; Old transport callback.     */

    /* Threading: */
    pj_bool_t            thread_quit_flag;  /**&lt; Thread quit flag.      */
    pj_thread_t         *thread[4];         /**&lt; Array of threads.      */

    /* STUN and resolver */
    pj_stun_config       stun_cfg;  /**&lt; Global STUN settings.          */
    pj_sockaddr          stun_srv;  /**&lt; Resolved STUN server address   */
    pj_status_t          stun_status; /**&lt; STUN server status.          */
    pjsua_stun_resolve   stun_res;  /**&lt; List of pending STUN resolution*/
    unsigned             stun_srv_idx; /**&lt; Resolved STUN server index  */
    unsigned             stun_opt;  /**&lt; STUN resolution option.        */
    pj_dns_resolver     *resolver;  /**&lt; DNS resolver.                  */   

    /* UPnP */
    pj_status_t          upnp_status; /**&lt; UPnP status.                 */

    /* Detected NAT type */
    pj_stun_nat_type     nat_type;      /**&lt; NAT type.                  */
    pj_status_t          nat_status;    /**&lt; Detection status.          */
    pj_bool_t            nat_in_progress; /**&lt; Detection in progress    */

    /* List of outbound proxies: */
    pjsip_route_hdr      outbound_proxy;

    /* Account: */
    unsigned             acc_cnt;            /**&lt; Number of accounts.   */
    pjsua_acc_id         default_acc;        /**&lt; Default account ID    */
    pjsua_acc            acc[PJSUA_MAX_ACC]; /**&lt; Account array.        */
    pjsua_acc_id         acc_ids[PJSUA_MAX_ACC]; /**&lt; Acc sorted by prio*/

    /* Calls: */
    pjsua_config         ua_cfg;                /**&lt; UA config.         */
    unsigned             call_cnt;              /**&lt; Call counter.      */
    pjsua_call           calls[PJSUA_MAX_CALLS];/**&lt; Calls array.       */
    pjsua_call_id        next_call_id;          /**&lt; Next call id to use*/

    /* Buddy; */
    unsigned             buddy_cnt;                 /**&lt; Buddy count.   */
    pjsua_buddy          buddy[PJSUA_MAX_BUDDIES];  /**&lt; Buddy array.   */

    /* Presence: */
    pj_timer_entry       pres_timer;/**&lt; Presence refresh timer.        */

    /* Media: */
    pjsua_media_config   media_cfg; /**&lt; Media config.                  */
    pjmedia_endpt       *med_endpt; /**&lt; Media endpoint.                */
    pjsua_conf_setting   mconf_cfg; /**&lt; Additionan conf. bridge. param */
    pjmedia_conf        *mconf;     /**&lt; Conference bridge.             */
    pj_bool_t            is_mswitch;/**&lt; Are we using audio switchboard
                                         (a.k.a APS-Direct)             */

    /* Sound device */
    pjmedia_aud_dev_index cap_dev;  /**&lt; Capture device ID.             */
    pjmedia_aud_dev_index play_dev; /**&lt; Playback device ID.            */
    pj_uint32_t          aud_svmask;/**&lt; Which settings to save         */
    pjmedia_aud_param    aud_param; /**&lt; User settings to sound dev     */
    pj_bool_t            aud_open_cnt;/**&lt; How many # device is opened  */
    pj_bool_t            no_snd;    /**&lt; No sound (app will manage it)  */
    pj_pool_t           *snd_pool;  /**&lt; Sound's private pool.          */
    pjmedia_snd_port    *snd_port;  /**&lt; Sound port.                    */
    pj_timer_entry       snd_idle_timer;/**&lt; Sound device idle timer.   */
    pjmedia_master_port *null_snd;  /**&lt; Master port for null sound.    */
    pjmedia_port        *null_port; /**&lt; Null port.                     */
    pj_bool_t            snd_is_on; /**&lt; Media flow is currently active */
    unsigned             snd_mode;  /**&lt; Sound device mode.             */

    /* Video device */
    pjmedia_vid_dev_index vcap_dev;  /**&lt; Capture device ID.            */
    pjmedia_vid_dev_index vrdr_dev;  /**&lt; Playback device ID.           */

    /* For keeping video device settings */
#if PJSUA_HAS_VIDEO
    pjmedia_vid_conf     *vid_conf;
    pj_uint32_t           vid_caps[PJMEDIA_VID_DEV_MAX_DEVS];
    pjmedia_vid_dev_param vid_param[PJMEDIA_VID_DEV_MAX_DEVS];
#endif

    /* File players: */
    unsigned             player_cnt;/**&lt; Number of file players.        */
    pjsua_file_data      player[PJSUA_MAX_PLAYERS];/**&lt; Array of players.*/

    /* File recorders: */
    unsigned             rec_cnt;   /**&lt; Number of file recorders.      */
    pjsua_file_data      recorder[PJSUA_MAX_RECORDERS];/**&lt; Array of recs.*/

    /* Video windows */
#if PJSUA_HAS_VIDEO
    pjsua_vid_win        win[PJSUA_MAX_VID_WINS]; /**&lt; Array of windows */
#endif

    /* Timer entry and event list */
    pjsua_timer_list     active_timer_list;
    pjsua_timer_list     timer_list;
    pjsua_event_list     event_list;
    pj_mutex_t          *timer_mutex;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sdp"><a class="header" href="#sdp">SDP</a></h2>
<h3 id="pjmedia_sdp_session"><a class="header" href="#pjmedia_sdp_session">pjmedia_sdp_session</a></h3>
<pre><code class="language-c">/**
 * This structure describes SDP session description. A SDP session descriptor
 * contains complete information about a session, and normally is exchanged
 * with remote media peer using signaling protocol such as SIP.
 */
struct pjmedia_sdp_session
{
    /** Session origin (o= line) */
    struct
    {
        pj_str_t    user;           /**&lt; User                           */
        pj_uint_t   id;             /**&lt; Session ID                     */
        pj_uint_t   version;        /**&lt; Session version                */
        pj_str_t    net_type;       /**&lt; Network type (&quot;IN&quot;)            */
        pj_str_t    addr_type;      /**&lt; Address type (&quot;IP4&quot;, &quot;IP6&quot;)    */
        pj_str_t    addr;           /**&lt; The address.                   */
    } origin;

    pj_str_t           name;        /**&lt; Subject line (s=)              */
    pjmedia_sdp_conn  *conn;        /**&lt; Connection line (c=)           */
    unsigned           bandw_count; /**&lt; Number of bandwidth info (b=)  */
    pjmedia_sdp_bandw *bandw[PJMEDIA_MAX_SDP_BANDW];
                                    /**&lt; Bandwidth info array (b=)      */
    
    /** Session time (t= line)  */
    struct
    {
        pj_uint_t start;            /**&lt; Start time.                    */
        pj_uint_t stop;             /**&lt; Stop time.                     */
    } time;

    unsigned           attr_count;              /**&lt; Number of attributes.  */
    pjmedia_sdp_attr  *attr[PJMEDIA_MAX_SDP_ATTR]; /**&lt; Attributes array.   */

    unsigned           media_count;             /**&lt; Number of media.       */
    pjmedia_sdp_media *media[PJMEDIA_MAX_SDP_MEDIA];    /**&lt; Media array.   */

};

</code></pre>
<h3 id="pjmedia_sdp_attr"><a class="header" href="#pjmedia_sdp_attr">pjmedia_sdp_attr</a></h3>
<pre><code class="language-c">/** 
 * Generic representation of attribute.
 */
struct pjmedia_sdp_attr
{
    pj_str_t            name;       /**&lt; Attribute name.    */
    pj_str_t            value;      /**&lt; Attribute value.   */
};

</code></pre>
<h3 id="pjmedia_sdp_media"><a class="header" href="#pjmedia_sdp_media">pjmedia_sdp_media</a></h3>
<pre><code class="language-c">/**
 * This structure describes SDP media descriptor. A SDP media descriptor
 * starts with &quot;m=&quot; line and contains the media attributes and optional
 * connection line.
 */
struct pjmedia_sdp_media
{
    /** Media descriptor line (&quot;m=&quot; line) */
    struct
    {
        pj_str_t    media;              /**&lt; Media type (&quot;audio&quot;, &quot;video&quot;)  */
        pj_uint16_t port;               /**&lt; Port number.                   */
        unsigned    port_count;         /**&lt; Port count, used only when &gt;2  */
        pj_str_t    transport;          /**&lt; Transport (&quot;RTP/AVP&quot;)          */
        unsigned    fmt_count;          /**&lt; Number of formats.             */
        pj_str_t    fmt[PJMEDIA_MAX_SDP_FMT];       /**&lt; Media formats.     */
    } desc;

    pjmedia_sdp_conn   *conn;           /**&lt; Optional connection info.      */
    unsigned            bandw_count;    /**&lt; Number of bandwidth info.      */
    pjmedia_sdp_bandw  *bandw[PJMEDIA_MAX_SDP_BANDW]; /**&lt; Bandwidth info.  */
    unsigned            attr_count;     /**&lt; Number of attributes.          */
    pjmedia_sdp_attr   *attr[PJMEDIA_MAX_SDP_ATTR];   /**&lt; Attributes.      */

};
</code></pre>
<h3 id="pjmedia_sdp_conn"><a class="header" href="#pjmedia_sdp_conn">pjmedia_sdp_conn</a></h3>
<pre><code class="language-c">/**
 * This structure describes SDP connection info (&quot;c=&quot; line). 
 */
struct pjmedia_sdp_conn
{
    pj_str_t    net_type;       /**&lt; Network type (&quot;IN&quot;).               */
    pj_str_t    addr_type;      /**&lt; Address type (&quot;IP4&quot;, &quot;IP6&quot;).       */
    pj_str_t    addr;           /**&lt; The address.                       */
    pj_uint8_t  ttl;            /**&lt; Multicast address TTL              */
    pj_uint8_t  no_addr;        /**&lt; Multicast number of addresses      */
};
</code></pre>
<h3 id="pjmedia_sdp_bandw"><a class="header" href="#pjmedia_sdp_bandw">pjmedia_sdp_bandw</a></h3>
<pre><code class="language-c">/**
 * This structure describes SDP bandwidth info (&quot;b=&quot; line). 
 */
typedef struct pjmedia_sdp_bandw
{
    pj_str_t    modifier;       /**&lt; Bandwidth modifier.                */
    pj_uint32_t value;          /**&lt; Bandwidth value.                   */
} pjmedia_sdp_bandw;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dialog"><a class="header" href="#dialog"><strong>Dialog</strong></a></h2>
<p><img src="../img/dialog.png" alt="img" /></p>
<h3 id="dialog-structure"><a class="header" href="#dialog-structure"><strong>Dialog Structure</strong></a></h3>
<pre><code class="language-c"> // This structure is used to describe dialog's participants, local and remote party.
struct pjsip_dlg_party
{
    pjsip_fromto_hdr *info; // From/To header, inc tag
    pj_uint32_t tag_hval; // Hashed value of the tag
    pjsip_contact_hdr *contact; // Contact header.
    pj_int32_t first_cseq; // First CSeq seen.
    pj_int32_t cseq; // Next sequence number.
};
// This structure describes basic dialog.
struct pjsip_dialog
{
    PJ_DECL_LIST_MEMBER(pjsip_dialog); // List node in dialog set.
// Static properties:
   char obj_name[PJ_MAX_OBJ_NAME]; // Log identification
    pj_pool_t *pool; // Dialog’s memory pool.
    pj_mutex_t *mutex; // Dialog's mutex.
    pjsip_user_agent *ua; // User agent instance.
    void *dlg_set; // The dialog set.
// Dialog session properties.
    pjsip_uri *target; // Current target.
    pjsip_dlg_party local; // Local party info.
    pjsip_dlg_party remote; // Remote party info.
    pjsip_role_e role; // Initial role.
    pj_bool_t secure; // Use secure transport?
    pjsip_cid_hdr *call_id; // Call-ID header.
    pjsip_route_hdr route_set; // Route set list.
    pjsip_auth_clt_sess auth_sess; // Client authentication session.
// Session Management
    int sess_count; // Session counter.
    int tsx_count; // Active transaction counter.
// Dialog usages
    unsigned usage_cnt; // Number of registered usages.
    pjsip_module *usage[PJSIP_MAX_MODULE]; // Usages, priority sorted
// Module specific data.
    void *mod_data[PJSIP_M AX_MODULE];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="session"><a class="header" href="#session">Session</a></h2>
<h3 id="invite-session"><a class="header" href="#invite-session">invite session</a></h3>
<pre><code class="language-c">/**
 * This structure describes the invite session.
 *
 * Note regarding the invite session's pools. The inv_sess used to have
 * only one pool, which is just a pointer to the dialog's pool. Ticket
 * https://github.com/pjsip/pjproject/issues/877 has found that the memory
 * usage will grow considerably everytime re-INVITE or UPDATE is
 * performed.
 *
 * Ticket #877 then created two more memory pools for the inv_sess, so
 * now we have three memory pools:
 *  - pool: to be used to allocate long term data for the session
 *  - pool_prov and pool_active: this is a flip-flop pools to be used
 *     interchangably during re-INVITE and UPDATE. pool_prov is
 *     &quot;provisional&quot; pool, used to allocate SDP offer or answer for
 *     the re-INVITE and UPDATE. Once SDP negotiation is done, the
 *     provisional pool will be made as the active pool, then the
 *     existing active pool will be reset, to release the memory
 *     back to the OS. So these pool's lifetime is synchronized to
 *     the SDP offer-answer negotiation.
 *
 * Higher level application such as PJSUA-LIB has been modified to
 * make use of these flip-flop pools, i.e. by creating media objects
 * from the provisional pool rather than from the long term pool.
 *
 * Other applications that want to use these pools must understand
 * that the flip-flop pool's lifetimes are synchronized to the
 * SDP offer-answer negotiation.
 *
 * The lifetime of this session is controlled by the reference counter in this
 * structure, which is manipulated by calling #pjsip_inv_add_ref and
 * #pjsip_inv_dec_ref. When the reference counter has reached zero, then
 * this session will be destroyed.
 */
struct pjsip_inv_session
{
    char                 obj_name[PJ_MAX_OBJ_NAME]; /**&lt; Log identification */
    pj_pool_t           *pool;                      /**&lt; Long term pool.    */
    pj_pool_t           *pool_prov;                 /**&lt; Provisional pool   */
    pj_pool_t           *pool_active;               /**&lt; Active/current pool*/
    pjsip_inv_state      state;                     /**&lt; Invite sess state. */
    pj_bool_t            cancelling;                /**&lt; CANCEL requested   */
    pj_bool_t            pending_cancel;            /**&lt; Wait to send CANCEL*/
    pjsip_tx_data       *pending_bye;               /**&lt; BYE to send later  */
    pjsip_status_code    cause;                     /**&lt; Disconnect cause.  */
    pj_str_t             cause_text;                /**&lt; Cause text.        */
    pj_bool_t            notify;                    /**&lt; Internal.          */
    pj_bool_t            sdp_done_early_rel;        /**&lt; Nego done in early
                                                         med was reliable?  */
    unsigned             cb_called;                 /**&lt; Cb has been called */
    pjsip_dialog        *dlg;                       /**&lt; Underlying dialog. */
    pjsip_role_e         role;                      /**&lt; Invite role.       */
    unsigned             options;                   /**&lt; Options in use.    */
    pjmedia_sdp_neg     *neg;                       /**&lt; Negotiator.        */
    unsigned             sdp_neg_flags;             /**&lt; SDP neg flags.     */
    pjsip_transaction   *invite_tsx;                /**&lt; 1st invite tsx.    */
    pjsip_tx_data       *invite_req;                /**&lt; Saved invite req   */
    pjsip_tx_data       *last_answer;               /**&lt; Last INVITE resp.  */
    pjsip_tx_data       *last_ack;                  /**&lt; Last ACK request   */
    pj_int32_t           last_ack_cseq;             /**&lt; CSeq of last ACK   */
    void                *mod_data[PJSIP_MAX_MODULE];/**&lt; Modules data.      */
    struct pjsip_timer  *timer;                     /**&lt; Session Timers.    */
    pj_bool_t            following_fork;            /**&lt; Internal, following
                                                         forked media?      */
    pj_atomic_t         *ref_cnt;                   /**&lt; Reference counter. */
    pj_bool_t            updated_sdp_answer;        /**&lt; SDP answer just been
                                                         updated?           */
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="transaction"><a class="header" href="#transaction">transaction</a></h2>
<h3 id="invite-session-data-to-be-attached-to-transaction"><a class="header" href="#invite-session-data-to-be-attached-to-transaction">Invite session data to be attached to transaction.</a></h3>
<pre><code class="language-c">/* Invite session data to be attached to transaction. */
struct tsx_inv_data
{
    pjsip_inv_session   *inv;       /* The invite session                   */
    pj_bool_t            sdp_done;  /* SDP negotiation done for this tsx?   */
    pj_bool_t            retrying;  /* Resend (e.g. due to 401/407)         */
    pj_str_t             done_tag;  /* To tag in RX response with answer    */
    pj_bool_t            done_early;/* Negotiation was done for early med?  */
    pj_bool_t            done_early_rel;/* Early med was realiable?         */
    pj_bool_t            has_sdp;   /* Message with SDP?                    */
};

</code></pre>
<h3 id="pjsip_transaction"><a class="header" href="#pjsip_transaction">pjsip_transaction</a></h3>
<pre><code class="language-c">/**
 * This structure describes SIP transaction object. The transaction object
 * is used to handle both UAS and UAC transaction.
 */
struct pjsip_transaction
{
    /*
     * Administrivia
     */
    pj_pool_t                  *pool;           /**&lt; Pool owned by the tsx. */
    pjsip_module               *tsx_user;       /**&lt; Transaction user.      */
    pjsip_endpoint             *endpt;          /**&lt; Endpoint instance.     */
    pj_bool_t                   terminating;    /**&lt; terminate() was called */
    pj_grp_lock_t              *grp_lock;       /**&lt; Transaction grp lock.  */
    pj_mutex_t                 *mutex_b;        /**&lt; Second mutex to avoid
                                                     deadlock. It is used to
                                                     protect timer.         */

    /*
     * Transaction identification.
     */
    char                        obj_name[PJ_MAX_OBJ_NAME];  /**&lt; Log info.  */
    pjsip_role_e                role;           /**&lt; Role (UAS or UAC)      */
    pjsip_method                method;         /**&lt; The method.            */
    pj_int32_t                  cseq;           /**&lt; The CSeq               */
    pj_str_t                    transaction_key;/**&lt; Hash table key.        */
    pj_str_t                    transaction_key2;/**&lt; Hash table key (2)   
                                                     for merged requests
                                                     tsx lookup.            */
    pj_uint32_t                 hashed_key;     /**&lt; Key's hashed value.    */
    pj_uint32_t                 hashed_key2;    /**&lt; Key's hashed value (2).*/
    pj_str_t                    branch;         /**&lt; The branch Id.         */

    /*
     * State and status.
     */
    int                         status_code;    /**&lt; Last status code seen. */
    pj_str_t                    status_text;    /**&lt; Last reason phrase.    */
    pjsip_tsx_state_e           state;          /**&lt; State.                 */
    int                         handle_200resp; /**&lt; UAS 200/INVITE  retrsm.*/
    int                         tracing;        /**&lt; Tracing enabled?       */

    /** Handler according to current state. */
    pj_status_t (*state_handler)(struct pjsip_transaction *, pjsip_event *);

    /*
     * Transport.
     */
    pjsip_transport            *transport;      /**&lt; Transport to use.      */
    pj_bool_t                   is_reliable;    /**&lt; Transport is reliable. */
    pj_sockaddr                 addr;           /**&lt; Destination address.   */
    int                         addr_len;       /**&lt; Address length.        */
    pjsip_response_addr         res_addr;       /**&lt; Response address.      */
    unsigned                    transport_flag; /**&lt; Miscelaneous flag.     */
    pj_status_t                 transport_err;  /**&lt; Internal error code.   */
    pjsip_tpselector            tp_sel;         /**&lt; Transport selector.    */
    pjsip_tx_data              *pending_tx;     /**&lt; Tdata which caused
                                                     pending transport flag
                                                     to be set on tsx.      */
    pjsip_tp_state_listener_key *tp_st_key;     /**&lt; Transport state listener
                                                     key.                   */

    /*
     * Messages and timer.
     */
    pjsip_tx_data              *last_tx;        /**&lt; Msg kept for retrans.  */
    int                         retransmit_count;/**&lt; Retransmission count. */
    pj_timer_entry              retransmit_timer;/**&lt; Retransmit timer.     */
    pj_timer_entry              timeout_timer;  /**&lt; Timeout timer.         */

    /** Module specific data. */
    void                       *mod_data[PJSIP_MAX_MODULE];
};
</code></pre>
<pre><code class="language-mermaid">graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="transport"><a class="header" href="#transport">transport</a></h2>
<pre><code class="language-c">/**
 * This structure represent the &quot;public&quot; interface of a SIP transport.
 * Applications normally extend this structure to include transport
 * specific members.
 */
struct pjsip_transport
{
    char                    obj_name[PJ_MAX_OBJ_NAME];  /**&lt; Name. */

    pj_pool_t              *pool;           /**&lt; Pool used by transport.    */
    pj_atomic_t            *ref_cnt;        /**&lt; Reference counter.         */
    pj_lock_t              *lock;           /**&lt; Lock object.               */
    pj_grp_lock_t          *grp_lock;       /**&lt; Group lock for sync with
                                                 ioqueue and timer.         */
    pj_bool_t               tracing;        /**&lt; Tracing enabled?           */
    pj_bool_t               is_shutdown;    /**&lt; Being shutdown?            */
    pj_bool_t               is_destroying;  /**&lt; Destroy in progress?       */

    /** Key for indexing this transport in hash table. */
    pjsip_transport_key     key;

    char                   *type_name;      /**&lt; Type name.                 */
    unsigned                flag;           /**&lt; #pjsip_transport_flags_e   */
    char                   *info;           /**&lt; Transport info/description.*/

    int                     addr_len;       /**&lt; Length of addresses.       */
    pj_sockaddr             local_addr;     /**&lt; Bound address.             */
    pjsip_host_port         local_name;     /**&lt; Published name (eg. STUN). */
    pjsip_host_port         remote_name;    /**&lt; Remote address name.       */
    pjsip_transport_dir     dir;            /**&lt; Connection direction.      */
    
    pjsip_endpoint         *endpt;          /**&lt; Endpoint instance.         */
    pjsip_tpmgr            *tpmgr;          /**&lt; Transport manager.         */
    pjsip_tpfactory        *factory;        /**&lt; Factory instance. Note: it
                                                 may be invalid/shutdown.   */
    pj_timer_entry          idle_timer;     /**&lt; Timer when ref cnt is zero.*/

    pj_timestamp            last_recv_ts;   /**&lt; Last time receiving data.  */
    pj_size_t               last_recv_len;  /**&lt; Last received data length. */

    void                   *data;           /**&lt; Internal transport data.   */
    unsigned                initial_timeout;/**&lt; Initial timeout interval
                                                 to be applied to incoming
                                                 TCP/TLS transports when no
                                                 valid data received after
                                                 a successful connection.   */

    /**
     * Function to be called by transport manager to send SIP message.
     *
     * @param transport     The transport to send the message.
     * @param packet        The buffer to send.
     * @param length        The length of the buffer to send.
     * @param op_key        Completion token, which will be supplied to
     *                      caller when pending send operation completes.
     * @param rem_addr      The remote destination address.
     * @param addr_len      Size of remote address.
     * @param callback      If supplied, the callback will be called
     *                      once a pending transmission has completed. If
     *                      the function completes immediately (i.e. return
     *                      code is not PJ_EPENDING), the callback will not
     *                      be called.
     *
     * @return              Should return PJ_SUCCESS only if data has been
     *                      succesfully queued to operating system for 
     *                      transmission. Otherwise it may return PJ_EPENDING
     *                      if the underlying transport can not send the
     *                      data immediately and will send it later, which in
     *                      this case caller doesn't have to do anything 
     *                      except wait the calback to be called, if it 
     *                      supplies one.
     *                      Other return values indicate the error code.
     */
    pj_status_t (*send_msg)(pjsip_transport *transport, 
                            pjsip_tx_data *tdata,
                            const pj_sockaddr_t *rem_addr,
                            int addr_len,
                            void *token,
                            pjsip_transport_callback callback);

    /**
     * Instruct the transport to initiate graceful shutdown procedure.
     * After all objects release their reference to this transport,
     * the transport will be deleted.
     *
     * Note that application MUST use #pjsip_transport_shutdown() instead.
     *
     * @param transport     The transport.
     *
     * @return              PJ_SUCCESS on success.
     */
    pj_status_t (*do_shutdown)(pjsip_transport *transport);

    /**
     * Forcefully destroy this transport regardless whether there are
     * objects that currently use this transport. This function should only
     * be called by transport manager or other internal objects (such as the
     * transport itself) who know what they're doing. Application should use
     * #pjsip_transport_shutdown() instead.
     *
     * @param transport     The transport.
     *
     * @return              PJ_SUCCESS on success.
     */
    pj_status_t (*destroy)(pjsip_transport *transport);

    /*
     * Application may extend this structure..
     */
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="data-structure-for-sending-outgoing-message"><a class="header" href="#data-structure-for-sending-outgoing-message">Data structure for sending outgoing message</a></h2>
<pre><code class="language-c">/**
 * Data structure for sending outgoing message. Application normally creates
 * this buffer by calling #pjsip_endpt_create_tdata.
 *
 * The lifetime of this buffer is controlled by the reference counter in this
 * structure, which is manipulated by calling #pjsip_tx_data_add_ref and
 * #pjsip_tx_data_dec_ref. When the reference counter has reached zero, then
 * this buffer will be destroyed.
 *
 * A transaction object normally will add reference counter to this buffer
 * when application calls #pjsip_tsx_send_msg, because it needs to keep the
 * message for retransmission. The transaction will release the reference
 * counter once its state has reached final state.
 */
struct pjsip_tx_data
{
    /** This is for transmission queue; it's managed by transports. */
    PJ_DECL_LIST_MEMBER(struct pjsip_tx_data);

    /** Memory pool for this buffer. */
    pj_pool_t           *pool;

    /** A name to identify this buffer. */
    char                 obj_name[PJ_MAX_OBJ_NAME];

    /** Short information describing this buffer and the message in it. 
     *  Application should use #pjsip_tx_data_get_info() instead of
     *  directly accessing this member.
     */
    char                *info;

    /** For response message, this contains the reference to timestamp when 
     *  the original request message was received. The value of this field
     *  is set when application creates response message to a request by
     *  calling #pjsip_endpt_create_response.
     */
    pj_time_val          rx_timestamp;

    /** The transport manager for this buffer. */
    pjsip_tpmgr         *mgr;

    /** Ioqueue asynchronous operation key. */
    pjsip_tx_data_op_key op_key;

    /** Lock object. */
    pj_lock_t           *lock;

    /** The message in this buffer. */
    pjsip_msg           *msg;

    /** Strict route header saved by #pjsip_process_route_set(), to be
     *  restored by #pjsip_restore_strict_route_set().
     */
    pjsip_route_hdr     *saved_strict_route;

    /** Buffer to the printed text representation of the message. When the
     *  content of this buffer is set, then the transport will send the content
     *  of this buffer instead of re-printing the message structure. If the
     *  message structure has changed, then application must invalidate this
     *  buffer by calling #pjsip_tx_data_invalidate_msg.
     */
    pjsip_buffer         buf;

    /** Reference counter. */
    pj_atomic_t         *ref_cnt;

    /** Being processed by transport? */
    int                  is_pending;

    /** Transport manager internal. */
    void                *token;

    /** Callback to be called when this tx_data has been transmitted.   */
    void               (*cb)(void*, pjsip_tx_data*, pj_ssize_t);

    /** Destination information, to be used to determine the network address
     *  of the message. For a request, this information is  initialized when
     *  the request is sent with #pjsip_endpt_send_request_stateless() and
     *  network address is resolved. For CANCEL request, this information
     *  will be copied from the original INVITE to make sure that the CANCEL
     *  request goes to the same physical network address as the INVITE
     *  request.
     */
    struct
    {
        /** Server name. 
         */
        pj_str_t                 name;

        /** Server addresses resolved. 
         */
        pjsip_server_addresses   addr;

        /** Current server address being tried. 
         */
        unsigned cur_addr;

    } dest_info;

    /** Transport information, only valid during on_tx_request() and 
     *  on_tx_response() callback.
     */
    struct
    {
        pjsip_transport     *transport;     /**&lt; Transport being used.  */
        pj_sockaddr          dst_addr;      /**&lt; Destination address.   */
        int                  dst_addr_len;  /**&lt; Length of address.     */
        char                 dst_name[PJ_INET6_ADDRSTRLEN]; /**&lt; Destination address.   */
        int                  dst_port;      /**&lt; Destination port.      */
    } tp_info;

    /** 
     * Transport selector, to specify which transport to be used. 
     * The value here must be set with pjsip_tx_data_set_transport(),
     * to allow reference counter to be set properly.
     */
    pjsip_tpselector        tp_sel;

    /**
     * Special flag to indicate that this transmit data is a request that has
     * been updated with proper authentication response and is ready to be
     * sent for retry.
     */
    pj_bool_t               auth_retry;

    /**
     * Arbitrary data attached by PJSIP modules.
     */
    void                    *mod_data[PJSIP_MAX_MODULE];

    /**
     * If via_addr is set, it will be used as the &quot;sent-by&quot; field of the
     * Via header for outgoing requests as long as the request uses via_tp
     * transport. Normally application should not use or access these fields.
     */
    pjsip_host_port          via_addr;      /**&lt; Via address.           */
    const void              *via_tp;        /**&lt; Via transport.         */
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pjsip-log"><a class="header" href="#pjsip-log">PJSIP log</a></h1>
<p><strong>日志用法</strong></p>
<p>使用之前需要初始化日志，但这一步是内部函数pj_init自己调用的，应用程序无需显示调用。</p>
<pre><code class="language-cpp">/**
 * Internal function to be called by pj_init()
 */

pj_status_t pj_log_init(void);
*   PJ_LOG(3, (&quot;main.c&quot;, &quot;Starting hello...&quot;));

*   PJ_LOG(3, (&quot;main.c&quot;, &quot;Hello world from process %d&quot;, pj_getpid()));
</code></pre>
<p>3表示日志级别，级别越高值越小，main.c表示日志发送者，即写日志的模块，类似于tag，后面就是格式化字符串。</p>
<p><strong>日志API</strong></p>
<pre><code class="language-cpp">#define PJ_LOG(level,arg)	do { \

				    if (level &lt;= pj_log_get_level()) { \

						pj_log_wrapper_##level(arg); \

				    } \
				    
				} while (0)
</code></pre>
<p>日志一般使用上面的宏，该宏会判断输入等级是否高于设置的等级（等级越高值越小，所以是&lt;=），是则调用对应的等级函数。</p>
<p>pj_log_wrapper_1到pj_log_wrapper_6最终都是调用最底层的函数pj_log。</p>
<pre><code class="language-cpp">/**
 * Write to log.
 *
 * @param sender    Source of the message.
 * @param level	    Verbosity level.
 * @param format    Format.
 * @param marker    Marker.
 */

PJ_DECL(void) pj_log(const char *sender, int level, const char *format, va_list marker);
</code></pre>
<p>pj_log根据样式的配置组织字符串，最后调用log_writer写入不同的对象。</p>
<p><strong>日志配置</strong></p>
<p>日志的配置非常灵活，有哪些配置呢</p>
<pre><code class="language-cpp">/**
 * Log decoration flag, to be specified with #pj_log_set_decor().
 */

enum pj_log_decoration
{

    PJ_LOG_HAS_DAY_NAME   =    1, /**&lt; Include day name [default: no] 	      */

    PJ_LOG_HAS_YEAR       =    2, /**&lt; Include year digit [no]		      */

    PJ_LOG_HAS_MONTH	  =    4, /**&lt; Include month [no]		      */

    PJ_LOG_HAS_DAY_OF_MON =    8, /**&lt; Include day of month [no]	      */

    PJ_LOG_HAS_TIME	  =   16, /**&lt; Include time [yes]		      */

    PJ_LOG_HAS_MICRO_SEC  =   32, /**&lt; Include microseconds [yes]             */

    PJ_LOG_HAS_SENDER	  =   64, /**&lt; Include sender in the log [yes] 	      */

    PJ_LOG_HAS_NEWLINE	  =  128, /**&lt; Terminate each call with newline [yes] */

    PJ_LOG_HAS_CR	  =  256, /**&lt; Include carriage return [no] 	      */

    PJ_LOG_HAS_SPACE	  =  512, /**&lt; Include two spaces before log [yes]    */

    PJ_LOG_HAS_COLOR	  = 1024, /**&lt; Colorize logs [yes on win32]	      */

    PJ_LOG_HAS_LEVEL_TEXT = 2048, /**&lt; Include level text string [no]	      */

    PJ_LOG_HAS_THREAD_ID  = 4096, /**&lt; Include thread identification [no]     */

    PJ_LOG_HAS_THREAD_SWC = 8192, /**&lt; Add mark when thread has switched [yes]*/

    PJ_LOG_HAS_INDENT     =16384  /**&lt; Indentation. Say yes! [yes]            */

};
</code></pre>
<p>从上面看，比较重要的有时间格式，发送者tag，和线程名字，可以通过pj_log_set_decor接口设置，比如。</p>
<pre><code class="language-cpp">int param_log_decor = PJ_LOG_HAS_NEWLINE | PJ_LOG_HAS_TIME | PJ_LOG_HAS_MICRO_SEC;

pj_log_set_decor(param_log_decor);
</code></pre>
<p>设置日志等级</p>
<pre><code class="language-cpp">PJ_DECL(void) pj_log_set_level(int level);
</code></pre>
<p>设置颜色</p>
<pre><code class="language-cpp">PJ_DECL(void) pj_log_set_color(int level, pj_color_t color);
</code></pre>
<p>设置缩进排版</p>
<pre><code class="language-cpp">/**
 * Add indentation to log message. Indentation will add PJ_LOG_INDENT_CHAR
 * before the message, and is useful to show the depth of function calls.
 *
 * @param indent    The indentation to add or substract. Positive value
 * 		    adds current indent, negative value subtracts current
 * 		    indent.
 */

PJ_DECL(void) pj_log_add_indent(int indent);

/**
 * Push indentation to the right by default value (PJ_LOG_INDENT).
 */

PJ_DECL(void) pj_log_push_indent(void);

/**
 * Pop indentation (to the left) by default value (PJ_LOG_INDENT).
 */

PJ_DECL(void) pj_log_pop_indent(void);
</code></pre>
<p><strong>输出对象</strong></p>
<p>pj_log最终调用log_writer写到输出对象，log_writer是一个函数回调指针</p>
<pre><code class="language-cpp">/**
 * Signature for function to be registered to the logging subsystem to
 * write the actual log message to some output device.
 *
 * @param level	    Log level.
 * @param data	    Log message, which will be NULL terminated.
 * @param len	    Message length.
 */

typedef void pj_log_func(int level, const char *data, int len);

static pj_log_func *log_writer = &amp;pj_log_write;
</code></pre>
<p>pj_log_write则在编译时指定编译为printk、printf等。对应log_write_printk.c、log_write_stdout.c，可以看出，如果我们想把日志保存的文件，自己实现一个pj_log_write函数，在函数里写到文件即可。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
