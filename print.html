<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PJSIP_STUDY</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="SIP.html"><strong aria-hidden="true">1.</strong> sip协议概述</a></li><li class="chapter-item expanded "><a href="pjsip_doc.html"><strong aria-hidden="true">2.</strong> pjsip文档翻译</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> make call流程</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="State.html"><strong aria-hidden="true">3.1.</strong> 状态机</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> 流程图</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="html/make_call.html"><strong aria-hidden="true">3.2.1.</strong> make call流程图</a></li><li class="chapter-item expanded "><a href="html/pjsip_dlg_create_uac.html"><strong aria-hidden="true">3.2.2.</strong> Create an UAC dialog</a></li><li class="chapter-item expanded "><a href="html/on_make_call_med_tp_complete.html"><strong aria-hidden="true">3.2.3.</strong> Outgoing call callback when media transport creation is completed</a></li><li class="chapter-item expanded "><a href="html/tsx_on_state_null.html"><strong aria-hidden="true">3.2.4.</strong> tsx_on_state_null状态处理</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> pjmedia学习</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="发送数据全流程.html"><strong aria-hidden="true">4.1.</strong> 发送数据过程</a></li><li class="chapter-item expanded "><a href="数据全流程.html"><strong aria-hidden="true">4.2.</strong> 接收数据过程</a></li><li class="chapter-item expanded "><a href="全流程思考.html"><strong aria-hidden="true">4.3.</strong> 初始化过程</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> 相关数据结构</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ioqueue_epoll.html"><strong aria-hidden="true">4.4.1.</strong> ioqueue_epoll</a></li><li class="chapter-item expanded "><a href="epoll学习.html"><strong aria-hidden="true">4.4.2.</strong> epoll</a></li><li class="chapter-item expanded "><a href="pjmedia_transport.html"><strong aria-hidden="true">4.4.3.</strong> pjmedia_transport</a></li><li class="chapter-item expanded "><a href="Port.html"><strong aria-hidden="true">4.4.4.</strong> pjmedia_port</a></li><li class="chapter-item expanded "><a href="Stream.html"><strong aria-hidden="true">4.4.5.</strong> pjmedia_stream</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 常见数据结构与工具</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="pjsua_call.html"><strong aria-hidden="true">5.1.</strong> pjsua_call</a></li><li class="chapter-item expanded "><a href="pjsua_acc.html"><strong aria-hidden="true">5.2.</strong> pjsua_acc</a></li><li class="chapter-item expanded "><a href="pjsua_data.html"><strong aria-hidden="true">5.3.</strong> pjsua_data</a></li><li class="chapter-item expanded "><a href="SDP.html"><strong aria-hidden="true">5.4.</strong> SDP</a></li><li class="chapter-item expanded "><a href="Dialog.html"><strong aria-hidden="true">5.5.</strong> Dialog</a></li><li class="chapter-item expanded "><a href="Session.html"><strong aria-hidden="true">5.6.</strong> Session</a></li><li class="chapter-item expanded "><a href="transaction.html"><strong aria-hidden="true">5.7.</strong> transaction</a></li><li class="chapter-item expanded "><a href="transport.html"><strong aria-hidden="true">5.8.</strong> transport</a></li><li class="chapter-item expanded "><a href="sendData.html"><strong aria-hidden="true">5.9.</strong> 数据发送数据结构</a></li><li class="chapter-item expanded "><a href="PJSIP_log.html"><strong aria-hidden="true">5.10.</strong> pjsip log</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PJSIP_STUDY</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="总述"><a class="header" href="#总述">总述</a></h2>
<ol>
<li>软电话A 向 B 发送一个 SIP消息 INVITE， 邀请B通话</li>
<li>软电话B振铃，向A 回复一个SIP消息 RING, 通知 A 正在振铃中，请A等待</li>
<li>软电话B提机，向A发一个SIP消息 OK, 通知 A 可以通话了</li>
<li>软电话A 向 B 回复一个回应消息 ACK，正式启动通话</li>
<li>接下来，双方通话</li>
<li>软电话B挂机，向 A 发一个SIP消息 BYE, 通知 A 通话结束</li>
<li>软电话A 向 B 回复一个消息 OK, 通话结束</li>
</ol>
<p>含有代理服务器</p>
<ul>
<li>代理服务器接收到了 INVITE 请求，然后发送了一个 100 (Trying) 响应给 Alice 的软电话。这个 100 (Trying) 响应表示这个 INVITE 已经被收到，代理正在通过路由设置路由这个 INVITE 到其目的地。</li>
<li>atlanta.com代理服务器定位到这个代理服务器在 biloxi.com，它可能执行一个特别的 DNS 查询来找到服务 biloxi.com 域的 SIP 服务器。获得 biloxi.com 代理服务器的 IP 地址，然后转发或者在这里代理其 INVITE 请求。在转发这个请求之前，这个 atlanta.com 代理服务器添加另外一个 Via 头字段，这个头字段包含自己的地址（这个 INVITE 已经在第一个 Via 包含了 Alice 的地址）</li>
<li>biloxi.com代理服务器收到这个 INVITE 消息后，然后回复一个带 100 (Trying) 响应消息到
atlanta.com 代理服务器，表示它已经收到了这个 INVITE 消息，正在处理这个请求。</li>
<li>代理服务器会查询一个定位服务器，我们称之为定位服务，定位服务包含当前 Bob 的IP 地址。biloxi.com 代理服务器会添加另外一个 Via header ，并且携带自己的 IP 地址，这个地址是针对这个 INVITE 请求的，代理转发这个请求到 Bob 的 SIP 软电话。</li>
<li>Bob 决定是否应答这个呼叫，这里 Bob 的软电话会产生振铃提示。Bob 的软电话提示 180 振铃，这个响应消息会路由根据相反的方向回到两个代理服务器。每个代理使用 Via header 域值来决定发送响应的地址方向，并且从顶部路由记录中删除自己的地址。因此，尽管要求 DNS 和定位服务查询 路由这个初始的 INVITE 请求，180（Ringing）响应返回到呼叫方时可以没有查询消息或没有代理服务器中所保持的状态。</li>
<li>Bob 决定应答这个呼叫。当他拿起电话听筒时，他的 SIP 电话会发送一个 200 (OK) 响应消息来表示这个呼叫已经应答。这个 200 (OK) 包含了一个消息体，这个消息体带了这个呼叫会话的媒体描述类型，这个媒体描述中说明了 Bob 希望和Alice 创建会话。</li>
<li>最后，Alice 软电话发送一个确认消息 ACK，这个消息发送到 Bob 软电话来确认最终响应 (200 (OK))已收到。在这个示例中，这个 ACK 是通过 Alice 软电话直接被发送到了 Bob 软电话，发送过程绕开了两个代理服务器。这样处理的原因就是因为两个终端已经通过互相学习知道对方的地址，双方地址是通过 INVITE/200（OK）交互时的 Contact 头获得，当然这个地址在初始时的 INVITE 是双方都不知道的。两个代理服务器的查询服务也不需要，因此，代理服务器则会退出这个呼叫流程。</li>
<li>Alice 或 Bob 任何一方都可以有权决定修改媒体会话的属性。修改会话属性是通过发送一个 re-INVITE 消息，在此消息中包含一个新的媒体描述来实现。这个 re-INVITE 涉及到了已存在的 dialog,因此其他的参与方知道这个消息是修改了现在的会话，而不是重新建立的新会话。其他方发送一个 200（ok）接受这个修改。请求方对 200（ok）发送一个 ACK。如果其他方不能接受这个修改的话，它会发生一个错误响应，例如 488 (Not Acceptable Here)，同样也接收一个 ACK 确认消息。但是，这个 re-INVITE 失败不会导致目前的呼叫失败-这个会话仍然会继续使用以前协商的属性。</li>
<li>在呼叫结束后，Bob 首先挂机(hangs up)，并且生成一个 BYE 消息。这个 BYE 会直接
路由返回到 Alice 的软电话，这里仍然绕过了代理。 Alice 确认了 BYE 接收，发送一个
200（ok），结束这个会话和 BYE 消息事务。</li>
<li>Bob 软电话基于初始化处理，在一定周期内 Bob 软电话对在biloxi.com 的服务器发送 REGISTER 消息，我们称之为 SIP registrar 或者 SIP 注册。REGISTER 消息关联 Bob 的 SIP 软电话或者 SIPS URI (sip:bob@biloxi.com)，这个机器是当前 Bob 写入记录的地址（它在 Contact 头中传输 SIP 或者 SIP URL）。 这个注册会写入此关联，也被称之为在数据库中的绑定或者定位服务，此定位服务可以使用在biloxi.com 域的代理中。经常，对于一个域的注册服务器需要和这个域的代理协同工作。这里一定要注意，区分不同类型的 SIP 服务器功能概念是非常重要的，它们区别是在于逻辑处理的不同，而不是物理上，形体上的不同</li>
</ul>
<h2 id="structure-of-the-protocol"><a class="header" href="#structure-of-the-protocol">Structure of the Protocol</a></h2>
<ol>
<li>SIP 结构的最低层是语法和解码层。解码是通过增强的 Backus-Naur Form grammar(BNF)语法来实现的。</li>
<li>第二层是传输层。它定义了用户如何发送请求，如何接收响应和服务器如何通过网络接收请求和发送响应。所有 SIP 网元都包含一个传输层。</li>
<li>第三层是事务层。事务是 SIP 的基础核心模块。事务是一个由用户端事务对服务器端事务发送的请求，用户端使用传输层对服务器端发送事务请求，所有的服务器端事务所携带响应消息返回到客户端。事务层处理应用层的重传，对请求响应的匹配和应用层超时管理。 任何由用户代理（UAC）完成的任务通过使用一系列的事务来触发。 用户代理包含了一个事务层，就像是一个状态代理。 无状态代理没有包含事务层。事务层有一个用户端模块（称之为用户事
务）和一个服务器端事务模块（称之为服务器端模块），每个模块通过各自的有限状态机来呈现，状态机来处理每个特别的请求</li>
<li>在事务层上面的是事务用户（TU）。每个 SIP 实体，除了无状态代理都是一个事务用户。<strong>当一个 TU 希望发送一个请求时，它会创建一个用户事务实例，然后把这个实例传递给这个请求，并且携带目的地 IP 地址，端口和传输请求</strong>。一个创建了用户事务的TU 也可以取消这个用户事务。当用户取消了一个事务时，它会请求服务器停止进一步的处理，变换到退出的状态，这个状态是这个事务初始化前的退出状态，并且生成对这个事务生成错误响应消息。 这个处理过程是通过一个 CANCEL 请求来处理，它构成了属于自己的事务，但是仅针对这个被取消的事务</li>
</ol>
<h2 id="术语"><a class="header" href="#术语">术语</a></h2>
<h3 id="outbound-proxy"><a class="header" href="#outbound-proxy">Outbound Proxy</a></h3>
<p>它是一个代理，负责接收从客户端发出的请求，即使它可能不是一个通过 Request-URI 解析度服务器。 通常情况下，一个 UA 可以通过 outbound proxy手动配置，或通过自动配置协议进行学习。</p>
<h3 id="location-service"><a class="header" href="#location-service">Location Service</a></h3>
<p>定位服务用来支持一个 SIP 重定位或代理服务器来获得关于被呼叫方可能存在的地址信息。它包含一个绑定的 address-of-record 列表数值，这些从从零个到多个 contact 地址。这个绑定关系可以通过多种方式来创建或者删除；此协议细节中定义了一个 REGISTER method 来更新绑定关系。</p>
<h3 id="redirect-server"><a class="header" href="#redirect-server">Redirect Server</a></h3>
<p>重定向服务器是一个用户代理服务器，它会对接收的请求产生 3xx 响应，重新定向用户，让用户联系其他可选的 URL 列表中的 URI 地址。</p>
<h3 id="request"><a class="header" href="#request">Request</a></h3>
<p>请求是一个由用户端发送到服务器的 SIP 消息，请求的目的是触发一个特别的操作。</p>
<h3 id="response"><a class="header" href="#response">Response</a></h3>
<p>响应是一个由服务器端发送到用户端的 SIP 消息，其目的是说明请求发送后服务器端回复的状态。</p>
<h3 id="route-set"><a class="header" href="#route-set">Route Set</a></h3>
<p>路由集是一组有序 SIP 或者 SIPS URI 的集和，它用来表示当发送 一个特别的请求时所经过的代理列表。 路由集通过路由头，例如 Record-Route 或者经过配置后获得。</p>
<h3 id="stateful-proxy"><a class="header" href="#stateful-proxy">Stateful Proxy</a></h3>
<p>状态代理是一个逻辑实体，它按照规范中请求处理的流程保持用户端和服务器端之间的事务状态机的处理状态，也就是所谓的事务状态代理。状态代理的执行在第 16 章做了进一步的说明。状态代理（事务）和呼叫状态代理是不同的。</p>
<h3 id="stateless-proxy"><a class="header" href="#stateless-proxy">Stateless Proxy</a></h3>
<p>无状态代理是一个逻辑实体，它不会保持用户端和服务器端之间的事务状态机。无状态代理前转从下游收到的每个请求，前转从上游收到的每一个响应。</p>
<h2 id="报文结构"><a class="header" href="#报文结构">报文结构</a></h2>
<pre><code>start-line
message-header
CRLF   //一个表示头结束的空行
[ message-body ]
</code></pre>
<h3 id="requests"><a class="header" href="#requests">Requests</a></h3>
<p>![image-20231227103252240](/Users/huanghaochen/Library/Application Support/typora-user-images/image-20231227103252240.png)</p>
<p>Method: 此规范定义了六个方法: REGISTER 支持注册联系消息，INVITE，ACK，和CANCEL 支持会话创建，BYE 支持结束会话，OPTIONS 支持对服务器的能力查询。SIP 拓展中定义了其他的方法。</p>
<h3 id="responses"><a class="header" href="#responses">Responses</a></h3>
<p>![image-20231227103448441](/Users/huanghaochen/Library/Application Support/typora-user-images/image-20231227103448441.png)</p>
<h4 id="首行start-line"><a class="header" href="#首行start-line"><strong>首行（start-line）</strong></a></h4>
<p>分请求行(Requests)和状态行(Responses)</p>
<ul>
<li><strong>请求行</strong>: 由<strong>请求类型、请求目的地址和协议版本号</strong>构成。请求类型有：INVITE,ACK,OPTIONS,BYE,CANCEL和REGISTER。</li>
<li><strong>状态行</strong>: 是被叫方向主叫方返回的状态信息，如1xx，2xx，3xx，4xx，5xx，6xx。</li>
</ul>
<h5 id="请求类型"><a class="header" href="#请求类型">请求类型</a></h5>
<ul>
<li><strong>INVITE</strong>：用于发起呼叫请求。INVITE消息包括消息头和数据区两部分。INVITE 消息头包含主、被呼叫的地址，呼叫主题和呼叫优先级等信息。数据区则是关于会话媒体的信息，可由会话描述协议SDP 来实现。</li>
<li><strong>BYE</strong>：当一个用户决定中止会话时，可以使用BYE 来结束会话。</li>
<li><strong>OPTIONS</strong>：用于询问被叫端的能力信息，但OPTIONS 本身并不能发起呼叫。</li>
<li><strong>ACK</strong>： 对已收到的消息进行确认应答。</li>
<li><strong>REGISTER</strong>：用于用户向SIP服务器传送位置信息或地址信息。</li>
<li><strong>CANCEL</strong>：取消当前的请求，但它并不能中止已经建立的连接。</li>
</ul>
<h5 id="状态类型"><a class="header" href="#状态类型">状态类型</a></h5>
<p>![image-20231228150803886](/Users/huanghaochen/Library/Application Support/typora-user-images/image-20231228150803886.png)</p>
<ul>
<li>1xx：临时消息：表示表示请求消息已经收到，后面将继续处理该请求。</li>
<li>2xx：成功消息：表示请求已经被成功的理解、接受或执行。</li>
<li>3xx：重定向消息：表示为了完成请求还需采取更进一步的动作。</li>
<li>4xx：客户机错误：表示该请求含有语法错误或在这个服务器上不能被满足。</li>
<li>5xx：服务器错误：表示该服务器不能处理一个明显有效的请求。</li>
<li>6xx：全局性故障：表示该请求在任何服务器上都不能被实现。</li>
</ul>
<h4 id="消息头message-header"><a class="header" href="#消息头message-header"><strong>消息头（message-header）</strong></a></h4>
<ul>
<li><strong>TO</strong>： 格式：<code>TO: 显示名&lt;接收者URI&gt;;tag=n</code>,显示名和tag可选。接收者URI是SIP网络种唯一标识接收终端的标识符。例：<code>TO: Name&lt;SIP:caller@WORK.COM&gt;;TAG=11111</code>或 <code>TO: sip:caller@work.com</code></li>
<li><strong>FROM</strong>: 给出标识会话发起者的URI。比如：FROM: <code>sip:caller@work.com;tag=hyh8</code> <code>tag</code>是必需的。</li>
<li><strong>CALL-ID</strong>: 用于全局唯一标识正在建立的会话的标识符。 随机数加UAC标识信息。</li>
<li><strong>CSeq</strong>: 用于标识同一会话中不同事务的序号，通常由一个用作序号的整型数和消息类型组成。整个会话操作过程由不同的事务组成，每一事务所涉及的消息的CSeq序号必须相同。</li>
<li><strong>Via</strong>: 为响应消息提供传输路径，当请求消息经过每一跳节点时，每一跳节点都把自身的IP地址信息放入顶层Via中。响应消息则沿着请求消息记录下的传输路径反向传输，首先移走指明自身IP地址信息的顶层消息头</li>
</ul>
<h4 id="消息体"><a class="header" href="#消息体"><strong>消息体</strong></a></h4>
<p>SIP协议一个最主要的作用就是协商媒体信息。媒体信息通过message-body携带，基于SDP会话描述协议。对于PSTN语音编码格式，主要有G711A、G711U、G729等。</p>
<p>SIP协商中主叫方会带上自己支持的所有音频编码列表到被叫方，被叫方一般在回铃时从主叫支持的类型中选出一种或多种自己支持的编码，返回主叫后，双人按顺序选出第一个支持的编码。</p>
<h3 id="invite-消息"><a class="header" href="#invite-消息">INVITE 消息</a></h3>
<h4 id="1起始行start-line"><a class="header" href="#1起始行start-line">(1)起始行(start-line)：</a></h4>
<pre><code>&lt;Method&gt; &lt;URI&gt; &lt;SIP_VERSION&gt;
INVITE sip:some@192.168.31.131:50027 SIP/2.0
</code></pre>
<ul>
<li>Method是请求方法，本例是INVITE, SIP协议规定的Method有六种: INVITE, ACK, CANCEL用于创建对话，BYE用于结束对话, REGISTER用于登记,OPTIONS用于查询服务器能力</li>
<li>URI表示所请求的用户或服务器, 也支持 “tel” URI， 本例是sip:some@192.168.31.131:50027,</li>
<li>SIP_VERSION是 SIP版本号，本例是 SIP/2.0</li>
</ul>
<h4 id="2消息头部header"><a class="header" href="#2消息头部header">(2)消息头部(header)</a></h4>
<p>一个请求消息头部至少要包含六个字段：Via, To, From, CSeq, Caller-ID, Max-Forwards</p>
<p>name : value ; value;</p>
<h5 id="i-via字段"><a class="header" href="#i-via字段">I. Via字段</a></h5>
<pre><code>Via: SIP/2.0/UDP 192.168.31.131:51971;rport;branch=z9hG4bKiYblddPPX
</code></pre>
<ul>
<li>
<p>Via头字段保存所经过SIP网元(客户端或Proxy)的主机名或网络地址（可能还有端口号），消息中的所有Via头字段对请求消息而言，从下至上依次表示到当前所在SIP网元为止，请求消息所经过的路径；对响应消息而言，从上至下依次表示从当前网元开始，响应所应遵循的路径。</p>
</li>
<li>
<p>Via字段包含SIP协议版本以及消息传输所用的传输协议, 此例为: SIP/2.0/UDP</p>
</li>
<li>
<p>branch参数:</p>
<ul>
<li>在SIP网元（UAC或Proxy）发出或转发请求消息时，在其插入的Via字段中必须包含branch参数，该参数用于标识此请求消息所创建的事务。</li>
<li>branch 参数可以用做loop detection，这时参数必须被分成两部分：第一部分符合一般的原则（对于RFC3261，z9hG4bK），第二部分(此例为iYblddPPX)被用来实现loop detection以用来区分loop和spiral。</li>
<li>loop和spiral均指Proxy收到一个请求后转发，然后此转发的请求又重新到达该Proxy，区别是loop中请求的Request-URI以及其他影响Proxy处理的头字段均不变，而Spiral请求中这些部分必需有某个发生改变，spiral发生的典型情况是Request-URI发生改变。Proxy在插入Via字段前，其branch 参数的loop.</li>
<li>detection部分依据以下元素编码：To Tag，From Tag，Call-ID字段，Request-URI，Topmost Via字段，Cseq的序号部分（即与request method无关），以及proxy-require字段，proxy authorization字段。注意：request method不能用于计算branch参数，比如CANCEL以及非2XX response的ACK与其所cancel的request或对应的INVITE属于同一个事务，即其branch参数相同。见RFC3261 P22 P25 P39 P95 P105</li>
</ul>
</li>
</ul>
<h5 id="ii-max-forwards-字段"><a class="header" href="#ii-max-forwards-字段">II. Max-Forwards 字段</a></h5>
<pre><code class="language-shell">    Max-Forwards: 70
</code></pre>
<ul>
<li>Max-Forwards 字段表示request到达UAS的跳数的限制。是一个整数，经过每一跳时减去一。如果Max-Forwards已经是零，可是request还没有到达目的地，则就会产生一个483(too many hops)响应</li>
</ul>
<h5 id="iii-to字段"><a class="header" href="#iii-to字段">III. To字段</a></h5>
<pre><code class="language-shell">   To: &lt;sip:some@192.168.31.131:50027&gt;
</code></pre>
<ul>
<li>To字段表示消息的接收者</li>
<li>To 字段可以有一个tag参数，to tag代表dialog的对等参与者（peer）。在UAC发出一个初始Dialog的请求（如INVITE）时，即发出out-of-dialog请求时，由于dialog还没有建立，不含to tag参数。当UAS收到INVITE请求时，在其发出的2xx或101-199响应中设置to tag参数，与UAC设置的From Tag参数以及Call-ID（呼叫唯一标识）一起作为一个Dialog ID（对话唯一标识，包含To tag，From Tag，Call-ID）的一个部分。RFC3261规定只有INVITE请求与2xx或101-199响应可以建立Dialog（由101-199响应创建的Dialog称为early dialog）。见RFC3261 P70</li>
</ul>
<h5 id="iv-from字段"><a class="header" href="#iv-from字段">IV. From字段</a></h5>
<pre><code class="language-shell">   From: &lt;sip:null@null&gt;;tag=Prf3c3Xc
</code></pre>
<ul>
<li>From字段表示消息的发送者</li>
<li>From字段必须包含tag参数，在UAC发出一个out-of-dialog请求（对话建立请求）时，必须设置一个唯一的tag参数，作为Dialog ID的一个部分。</li>
</ul>
<h5 id="v-call-id字段"><a class="header" href="#v-call-id字段">V. Call-ID字段</a></h5>
<p>邀请id</p>
<pre><code class="language-shell">   Call-ID: cenXTa4i-1423587756904@appletekiAir
</code></pre>
<ul>
<li>是一个邀请(Invitation)或来自同一个UAC用户的所有登记请求(Registeration，包括更新登记，取消登记)以及由此产生的一组响应的唯一标识。<strong>一个邀请可以建立多个Dialog</strong>（当被叫用户有多个联系方式时），这成为Forking，因而Call-ID只是一次呼叫邀请的唯一标识，Call-ID与UAC在发出请求中设置的From Tag字段以及UAS在其相映中设置的To Tag字段三者一起作为一个Dialog-ID。</li>
<li>在一个Dialog中，所有的requests和responses的Call-ID必须一致 同一UA的每一个register 的Call-ID必须一致。</li>
</ul>
<h5 id="vi-cseq-字段"><a class="header" href="#vi-cseq-字段">VI. CSeq 字段</a></h5>
<pre><code class="language-shell">   CSeq: 1 INVITE
</code></pre>
<ul>
<li>用于在同一个Dialog中标识及排序事务（transaction）以及区分新的请求 与请求的重发。</li>
<li>CSeq包括顺序号和方法（method），方法必须和它所对应的request相匹配。对于out-of-dialog的非<strong>register request，取值任意</strong>。</li>
<li>对于dialog内的每一个新的request（如BYE,re-INVITE,OPTION），Cseq的序号加1。但是对于CANCEL,ACK除外。对于ACK而言，Cseq的序号必须与其所对应的request相同。对于CANCEL而言，Cseq的序号也必须与其cancel掉的request相同。</li>
<li>注意：在同一个对话中的UAC和UAS分别维护自己的CSeq序号，他们发出请求的CSeq序号是不相关的。</li>
</ul>
<h5 id="vii-contact-字段"><a class="header" href="#vii-contact-字段">VII. Contact 字段</a></h5>
<pre><code class="language-shell">Contact: &lt;sip:null@192.168.31.131:51971;transport=UDP&gt;
</code></pre>
<ul>
<li>对于非Register事务，Contact header field 主要提供了UAC或UAS的 直接联系SIP URI，UAC在发出的对话建立（out-of-dialog）INVITE请求的Contact字段中提供自己的直接联系SIP URI，在UAS收到该请求后在其发出响应的Contact字段中提供自己的直接联系SIP URI，这样在建立对话后，<strong>UA间可以通过对方的直接联系SIP URI绕过Proxy直接发送请求。</strong></li>
<li>对于Register事务，表示地址绑定中的contact address（vs. address-of-record）</li>
<li>Contact header field contains IP address and port on which the sender is awaiting further requests sent by callee. Other header fields are not important and will be not described here.</li>
</ul>
<h5 id="viii-content-type字段"><a class="header" href="#viii-content-type字段">VIII. Content-Type字段</a></h5>
<pre><code class="language-shell&#39;">     Content-Type: application/sdp
</code></pre>
<ul>
<li>主要表示发给接收器的消息体的媒体类型。如果消息体不是空的，则Content-type header field一定要存在。如果Content-type header field存在，而消息体是空的，表明该类型的媒体流长度是0。</li>
</ul>
<h5 id="viiii-content-length字段"><a class="header" href="#viiii-content-length字段">VIIII. Content-Length字段</a></h5>
<pre><code class="language-shell">    Content-Length: 215
</code></pre>
<p>表示消息体的长度。是十进制数。</p>
<h4 id="3消息体message-body"><a class="header" href="#3消息体message-body">(3)消息体(message body)</a></h4>
<pre><code>v=0            //版本号为0
o=user1 685988692 621323255 IN IP4 192.168.31.131 //建立者用户名＋会话ID＋版本＋网络类型＋地址类型＋地址 
s=-            //会话名
c=IN IP4 192.168.31.131  //连接信息：网络类型＋地址类型＋地址
t=0 0         //会话活动时间 起始时间＋终止时间
m=audio 49432 RTP/AVP 0 8 101   //媒体描述：媒体＋端口＋传送＋格式列表
																	音频 ＋ 端口49432 ＋ 传输协议RTP ＋ 格式AVP，有效负荷0（u率PCM编码） 
																	
a=rtpmap:0 PCMU/8000  //0或多个会话属性： 属性 ＋ 有效负荷＋ 编码名称 ＋ 抽样频率。

a=rtpmap:8 PCMA/8000  // rtpmap ＋   0型  ＋  PCMU  ＋  8KHz 

a=rtpmap:101 telephone-event/8000

a=sendrecv  //a 可以有多个， 见SDP协议


</code></pre>
<h1 id="register"><a class="header" href="#register">REGISTER</a></h1>
<p>allows a central server (registrar) to s<strong>tore the location of a SIP User-Agent.</strong></p>
<p><img src="https://www.kamailio.org/docs/tutorials/sip-introduction/figures/registrar.png" alt="Picture showing a typical registrar" /></p>
<p><img src="https://blog.wildix.com/wp-content/uploads/2018/07/Register-message.jpg" alt="img" /></p>
<pre><code>REGISTER sip:10.10.1.99 SIP/2.0
CSeq: 1 REGISTER
Via: SIP/2.0/UDP 10.10.1.13:5060;
 branch=z9hG4bK78946131-99e1-de11-8845-080027608325;rport
User-Agent: MySipClient/4.0.0
From: &lt;sip:13@10.10.1.99&gt;
 ;tag=d60e6131-99e1-de11-8845-080027608325
Call-ID: e4ec6031-99e1
To: &lt;sip:13@10.10.1.99&gt;
Contact: &lt;sip:13@10.10.1.13&gt;;q=1
Allow: INVITE,ACK,OPTIONS,BYE,CANCEL,SUBSCRIBE,NOTIFY,REFER,MESSAGE,
 INFO,PING
Expires: 3600
Content-Length: 0
Max-Forwards: 70
</code></pre>
<ul>
<li>User-Agent: indicates the SIP Client connecting; most devices will indicate here the manufacturer – product name – software version and other information, such as the MAC address</li>
<li>To: similar to <em>From</em>, in the case of the registration this field is usually the same as <em>From</em>. The tag is missing here but will be filled up by the SIP Server during the reply to the <em>REGISTER</em></li>
<li>Contact: usually indicates where the reply should go to, if rport was not set</li>
<li>Expires: the desired registration duration in seconds</li>
</ul>
<p><a href="https://blog.csdn.net/m0_37915666/article/details/115026427">SIP：松散路由与严格路由-CSDN博客</a></p>
<h2 id="ok"><a class="header" href="#ok">OK</a></h2>
<pre><code>SIP/2.0 200 OK
Via: SIP/2.0/UDP 192.168.1.30:5060;received=66.87.48.68
From: sip:sip2@iptel.org
To: sip:sip2@iptel.org;tag=794fe65c16edfdf45da4fc39a5d2867c.b713
Call-ID: 2443936363@192.168.1.30
CSeq: 63629 REGISTER
Contact: Msip:sip2@66.87.48.68:5060;transport=udp&gt;;q=0.00;expires=120
Server: Sip EXpress router (0.8.11pre21xrc (i386/linux))
Content-Length: 0
Warning: 392 195.37.77.101:5060 "Noisy feedback tells:  
  pid=5110 req_src_ip=66.87.48.68 req_src_port=5060 in_uri=sip:iptel.org 
  out_uri=sip:iptel.org via_cnt==1"
</code></pre>
<h3 id="bye"><a class="header" href="#bye">BYE</a></h3>
<pre><code>BYE sip:info@hypotenuse.example.org SIP/2.0
Via: SIP/2.0/TCP port443.hotmail.example.com:54212;branch=z9hG4bK312bc
Max-Forwards:70
To: &lt;sip:info@hypotenuse.example.org&gt;;tag=63124
From: &lt;sip:pythag42@hotmail.example.com&gt;;tag=9341123
Call-ID: 34283291273
CSeq: 47 BYE
Content-Length: 0
</code></pre>
<p>应答只能由对端UA生成。如果UA收到未知的BYE请求，那么它应答回应481 Dialog/Transaction Does Not Exist</p>
<h3 id="ack"><a class="header" href="#ack">ACK</a></h3>
<pre><code>ACK sip:laplace@mathematica.example.org SIP/2.0
Via: SIP/2.0/TCP 128.5.2.1:5060;branch=z9hG4bK1834
Max-Forwards:70
To: Marquis de Laplace &lt;sip:laplace@mathematica.example.org&gt; ;tag=90210
From: Nathaniel Bowditch &lt;sip:n.bowditch@salem.example.com&gt; ;tag=887865
Call-ID: 152-45-32-N-32-23-47-W
CSeq: 3 ACK
Content-Type: application/sdp
Content-Length: ...
 
v=0
o=bowditch 2590844326 2590944532 IN IP4
s=Bearing
c=IN IP4 salem.example.org t=0 0
m=audio 32852 RTP/AVP 96 0
a=rtpmap:96 SPEEX/8000
a=rtpmap:0 PCMU/8000
</code></pre>
<p>​    ACK方法用于确认收到INVITE请求的最终应答。其它请求方法不需要确认。</p>
<p>​    ACK的CSeq<strong>序号不变</strong>，但方法描述变成ACK。这有助于UAS匹配对应的INVITE事务。</p>
<p>​    ACK消息可以携带application/sdp消息体。如果初始INVITE没有携带SDP信息，就允许在ACK消息中携带。如果INVITE带了SDP消息体，那么就不应该在ACK消息中携带SDP消息体。不能用ACK方法变更初始INVITE所描述的媒体信息，如果需要变更，必须使用re-INVITE或UPDATE方法。在ACK中携带SDP的方式常用于与其它协议交互的场景，特别是在发初始INVITE时不能获取媒体特征的场景。</p>
<p>​</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="总体"><a class="header" href="#总体">总体</a></h2>
<p><img src="img/%E6%80%BB%E4%BD%93.png" alt="img" /></p>
<p><img src="img/%E6%80%BB%E4%BD%93%E7%B1%BB%E5%9B%BE.png" alt="img" /></p>
<h2 id="the-endpoint"><a class="header" href="#the-endpoint"><strong>The Endpoint</strong></a></h2>
<h3 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h3>
<p><strong>pjsip_endpoint</strong></p>
<h3 id="功能"><a class="header" href="#功能">功能</a></h3>
<h4 id="1pool-factory"><a class="header" href="#1pool-factory">1、pool factory</a></h4>
<p>All memory allocations for the SIP components</p>
<ul>
<li>pjsip_endpt_create_pool(),</li>
<li>pjsip_endpt_release_pool().</li>
</ul>
<p>When the endpoint is created (pjsip_endpt_create()), application MUST specify</p>
<p>the pool factory that will be used by the endpoint. Endpoint keeps this pool</p>
<p>factory pointer throughout its lifetime, and will use this to create and release</p>
<p>memory pools. 创建之前必须指定pool factory</p>
<h4 id="2timer-management"><a class="header" href="#2timer-management">2、<strong>Timer Management</strong></a></h4>
<p>a single timer heap instance to manage timerss, and all timer creation and scheduling by all SIP components will be done via the endpoint.</p>
<ul>
<li>
<p>pjsip_endpt_schedule_timer(),</p>
</li>
<li>
<p>pjsip_endpt_cancel_timer().</p>
</li>
</ul>
<h4 id="3transport-manager-instance"><a class="header" href="#3transport-manager-instance">3、Transport manager instance</a></h4>
<p>The transport manager has SIP transports and controls message parsing and printing.</p>
<h4 id="4single-instance-of-pjlibs-ioqueue"><a class="header" href="#4single-instance-of-pjlibs-ioqueue">4、Single instance of PJLIB’s ioqueue</a></h4>
<h4 id="5thread-safe-polling-function"><a class="header" href="#5thread-safe-polling-function">5、Thread safe polling function</a></h4>
<p>application’s threads can poll for timer and socket events</p>
<ul>
<li>
<p>(pjsip_endpt_handle_events()</p>
<p>check the occurrence of timer and network events</p>
</li>
</ul>
<h4 id="6manages-pjsip-modules"><a class="header" href="#6manages-pjsip-modules">6、Manages PJSIP modules</a></h4>
<h4 id="7receives-incoming-sip-messages"><a class="header" href="#7receives-incoming-sip-messages">7、Receives incoming SIP messages</a></h4>
<p>It receives incoming SIP messages from transport manager and distributes the message to modules.</p>
<h2 id="module"><a class="header" href="#module"><strong>Module</strong></a></h2>
<h3 id="数据结构-1"><a class="header" href="#数据结构-1">数据结构</a></h3>
<p><strong>pjsip_module</strong></p>
<pre><code class="language-c">/**
 * @defgroup PJSIP_MOD Modules
 * @ingroup PJSIP_CORE_CORE
 * @brief Modules are the primary means to extend PJSIP!
 * @{
 * Modules are the primary means to extend PJSIP. Without modules, PJSIP
 * would not know how to handle messages, and will simply discard all
 * incoming messages.
 *
 * Modules are registered by creating and initializing #pjsip_module 
 * structure, and register the structure to PJSIP with 
 * #pjsip_endpt_register_module().
 *
 * The &lt;A HREF="/en/latest/api/pjsip/guide.html"&gt;PJSIP Developer's Guide&lt;/A&gt;
 * has a thorough discussion on this subject, and readers are encouraged
 * to read the document for more information.
 */

/**
 * The declaration for SIP module. This structure would be passed to
 * #pjsip_endpt_register_module() to register the module to PJSIP.
 */
struct pjsip_module
{
    /** To allow chaining of modules in the endpoint. */
    PJ_DECL_LIST_MEMBER(struct pjsip_module);

    /**
     * Module name to identify the module.
     *
     * This field MUST be initialized before registering the module.
     */
    pj_str_t name;

    /**
     * Module ID. Application must initialize this field with -1 before
     * registering the module to PJSIP. After the module is registered,
     * this field will contain a unique ID to identify the module.
     */
    int id;

    /**
     * Integer number to identify module initialization and start order with
     * regard to other modules. Higher number will make the module gets
     * initialized later.
     *
     * This field MUST be initialized before registering the module.
     */
    int priority;

    /**
     * Optional function to be called to initialize the module. This function
     * will be called by endpoint during module registration. If the value
     * is NULL, then it's equal to returning PJ_SUCCESS.
     *
     * @param endpt     The endpoint instance.
     * @return          Module should return PJ_SUCCESS to indicate success.
     */
    pj_status_t (*load)(pjsip_endpoint *endpt);

    /**
     * Optional function to be called to start the module. This function
     * will be called by endpoint during module registration. If the value
     * is NULL, then it's equal to returning PJ_SUCCESS.
     *
     * @return          Module should return zero to indicate success.
     */
    pj_status_t (*start)(void);

    /**
     * Optional function to be called to deinitialize the module before
     * it is unloaded. This function will be called by endpoint during 
     * module unregistration. If the value is NULL, then it's equal to 
     * returning PJ_SUCCESS.
     *
     * @return          Module should return PJ_SUCCESS to indicate success.
     */
    pj_status_t (*stop)(void);

    /**
     * Optional function to be called to deinitialize the module before
     * it is unloaded. This function will be called by endpoint during 
     * module unregistration. If the value is NULL, then it's equal to 
     * returning PJ_SUCCESS.
     *
     * @param mod       The module.
     *
     * @return          Module should return PJ_SUCCESS to indicate success.
     */
    pj_status_t (*unload)(void);

    /**
     * Optional function to be called to process incoming request message.
     *
     * @param rdata     The incoming message.
     *
     * @return          Module should return PJ_TRUE if it handles the request,
     *                  or otherwise it should return PJ_FALSE to allow other
     *                  modules to handle the request.
     */
    pj_bool_t (*on_rx_request)(pjsip_rx_data *rdata);

    /**
     * Optional function to be called to process incoming response message.
     *
     * @param rdata     The incoming message.
     *
     * @return          Module should return PJ_TRUE if it handles the 
     *                  response, or otherwise it should return PJ_FALSE to 
     *                  allow other modules to handle the response.
     */
    pj_bool_t (*on_rx_response)(pjsip_rx_data *rdata);

    /**
     * Optional function to be called when transport layer is about to
     * transmit outgoing request message.
     *
     * @param tdata     The outgoing request message.
     *
     * @return          Module should return PJ_SUCCESS in all cases. 
     *                  If non-zero is returned, the message 
     *                  will not be sent.
     */
    pj_status_t (*on_tx_request)(pjsip_tx_data *tdata);

    /**
     * Optional function to be called when transport layer is about to
     * transmit outgoing response message.
     *
     * @param tdata     The outgoing response message.
     *
     * @return          Module should return PJ_SUCCESS in all cases. 
     *                  If non-zero is returned, the message 
     *                  will not be sent.
     */
    pj_status_t (*on_tx_response)(pjsip_tx_data *tdata);

    /**
     * Optional function to be called when this module is acting as 
     * transaction user for the specified transaction, when the 
     * transaction's state has changed.
     *
     * @param tsx       The transaction.
     * @param event     The event which has caused the transaction state
     *                  to change.
     */
    void (*on_tsx_state)(pjsip_transaction *tsx, pjsip_event *event);

};
</code></pre>
<h3 id="概述"><a class="header" href="#概述">概述</a></h3>
<p>For incoming messages, the endpoint (pjsip_endpoint) distributes the message to all modules starting from module with highest priority, until one of them says that it has processed the message. For outgoing messages, the endpoint distributes the outgoing messages before they are transmitted to the wire, to allow modules to put last modification on the message if they wish.</p>
<h3 id="api"><a class="header" href="#api">API</a></h3>
<p>endpoint调用改变模块调用：The four function pointers <strong>load</strong>, <strong>start</strong>, <strong>stop</strong>, and <strong>unload</strong> are called by endpoint to control the module state.</p>
<img src="img/Module_State.png" alt="img" style="zoom:50%;" />
<p><code>pjsip_endpt_register_module()</code> register the module to PJSIP endpoint</p>
<p><code>on_rx_request() and on_rx_response()</code> : endpoint按照优先级从高到低发给模块，调用这两个函数，返回值不为0，表示模块处理了，停止发送</p>
<ul>
<li>module to receive SIP messages from endpoint (<em>pjsip_endpt</em>) or from other modules.</li>
<li>The return value of these callbacks is important. <strong>If a callback has returned non-zero</strong> (i.e. true condition), it semantically means that the module has taken care the message; in this case, the endpoint will stop distributing the message to other modules.</li>
</ul>
<p><code>on_tx_request() and on_tx_response()</code></p>
<ul>
<li>function pointers are called by <strong>transport manager</strong> before a message is transmitted.</li>
<li>This gives an opportunity for some types of modules (e.g. sigcomp, message signing) chance to <strong>make last modification to the message before transmitt</strong>.</li>
<li>All modules MUST return PJ_SUCCESS (i.e. zero status), or otherwise the transmission will be cancelled.</li>
</ul>
<p><code>on_tsx_state()</code></p>
<p>receive notification every time a transaction state has changed, which can be caused by receipt of message, transmission of message, timer events, or transport error event. 每次事务状态发生变化时接收通知，这种变化可能是由消息的接收、消息的传输、计时器事件或传输错误事件引起的。</p>
<h3 id="212-module-priorities"><a class="header" href="#212-module-priorities"><strong>2.1.2 Module Priorities</strong></a></h3>
<p>Module priority specifies the order of which modules are called first to process the callback. Module with higher priority (i.e. lower priority <em>number</em>) will have their on_rx_request() and on_rx_response() called <strong>first</strong>, and on_tx_request() and on_tx_response() called <strong>last</strong>.</p>
<pre><code class="language-c">/**
 * Module priority guidelines.
 */
enum pjsip_module_priority
{
    /** 
     * This is the priority used by transport layer.
     */
    PJSIP_MOD_PRIORITY_TRANSPORT_LAYER  = 8,

    /**
     * This is the priority used by transaction layer.
     */
    PJSIP_MOD_PRIORITY_TSX_LAYER        = 16,

    /**
     * This is the priority used by the user agent and proxy layer.
     */
    PJSIP_MOD_PRIORITY_UA_PROXY_LAYER   = 32,

    /**
     * This is the priority used by the dialog usages.
     */
    PJSIP_MOD_PRIORITY_DIALOG_USAGE     = 48,

    /**
     * This is the recommended priority to be used by applications.
     */
    PJSIP_MOD_PRIORITY_APPLICATION      = 64
};

</code></pre>
<p><strong>PJSIP_MOD_PRIORITY_TRANSPORT_LAYER</strong></p>
<ul>
<li>transport manager 的优先级</li>
<li>低于这个的优先级，可以在transport layer之前调用on_tx_request()/on_tx_response() ；高于这个优先级，可以在transport layer处理完后继续处理</li>
<li>This priority currently is only used to control message transmission, i.e. <strong>module with lower priority than this</strong> (that means higher priority number!) will have the on_tx_request()/on_tx_response() called <strong>before</strong> the message is processed by transport layer (e.g. destination is calculated, message is printed to contiguous buffer), while module with higher priority than this will have the callback called <strong>after</strong> the message has been processed by transport layer.</li>
</ul>
<p><strong>PJSIP_MOD_PRIORITY_TSX_LAYER</strong></p>
<ul>
<li>
<p>transaction layer优先级</p>
</li>
<li>
<p>The transaction layer absorbs all incoming messages that belong to a transaction.</p>
</li>
</ul>
<p><strong>PJSIP_MOD_PRIORITY_UA_PROXY_LAYER</strong></p>
<ul>
<li>priority used by UA layer (i.e.dialog framework) or proxy layer.</li>
<li>The UA layer absorbs all incoming messages that belong to a dialog set (this means forked responses as well).</li>
</ul>
<p><strong>PJSIP_MOD_PRIORITY_DIALOG_USAGE</strong></p>
<ul>
<li>for dialog usages.</li>
<li>Currently PJSIP implements two types of dialog usages: invite sesssion and event subscriptionsession (including REFER subscription). The dialog usage absorbs messages inside a dialog that belong to particular session.</li>
</ul>
<p><strong>PJSIP_MOD_PRIORITY_APPLICATION</strong></p>
<ul>
<li>for typical application modules, when they want to utilize transactions, dialogs, and dialog usages.</li>
</ul>
<h3 id="213-incoming-message-processing-by-modules"><a class="header" href="#213-incoming-message-processing-by-modules">2.1.3 <strong>Incoming Message Processing by Modules</strong></a></h3>
<img src="img/income_example.png" alt="img" style="zoom:50%;" />
<ol>
<li>incoming message arrives, it is represented as receive message buffer (<strong>struct pjsip_rx_data</strong>, see section 5.1 “Receive Data Buffer”).</li>
<li>Transport manager parses the message, put the parsed data structures in the receive message buffer</li>
<li>pass the message to the endpoint.</li>
<li>The endpoint distributes the receive message buffer to each registered module by calling <strong>on_rx_request()</strong> or <strong>on_rx_response()</strong> callback, starting from module with highest priority (i.e. lowest priority <em>number</em>) until one of them returns non-zero. When one of the module has returned non-zero, endpoint stops distributing the message to the remaining of the modules, because it assumes that the module has taken care about the processing of the message.</li>
<li>The module which returns non-zero on the callback itself may further distribute the message to other modules. i.e</li>
</ol>
<img src="img/Incoming_Message.png" alt="img" style="zoom:50%;" />
<h3 id="214-outgoing-message-processing-by-modules"><a class="header" href="#214-outgoing-message-processing-by-modules">2.1.4 <strong>Outgoing Message Processing by Modules</strong></a></h3>
<ol>
<li>
<p>An outgoing request or response message is represented by a transmit data buffer (<strong>pjsip_tx_data</strong>), which among other things, contains the message structure itself, memory pool, contiguous buffer, and transport info.</p>
</li>
<li>
<p>When <strong>pjsip_transport_send()</strong> is called to send a message, transport manager calls <strong>on_tx_request()</strong> or <strong>on_tx_response()</strong> for all modules, starting with modules with lowest priority (i.e. highest priority number).</p>
</li>
<li>
<p>When these callbacks are called, the message may have or have not been processed by the transport layer. The transport layer is responsible for managing these information inside a transmit buffer:</p>
<ul>
<li>
<p>transport info, and</p>
</li>
<li>
<p>printing the message structure to contiguous buffer.</p>
<p>If modules want to modify the message <em>structure</em> before it is printed to buffer, then it must set its priority <em>number</em> higher than transport layer priority. If modules want to see the actual packet bytes as they are transmitted to the wire (e.g. for logging purpose), then it should set its priority <em>number</em> to lower than transport layer.</p>
</li>
</ul>
</li>
</ol>
<h3 id="215-transaction-user-and-state-callback"><a class="header" href="#215-transaction-user-and-state-callback">2.1.5 <strong>Transaction User and State Callback</strong></a></h3>
<ul>
<li>
<p>transaction 状态变化，接收notification from a particular transaction</p>
</li>
<li>
<p>This callback is unique because transaction state may change because of non message related events (e.g. timer timeout and transport error).</p>
</li>
<li>
<p>This callback will only be called after the module has been registered as transaction user for a particular transaction. Only one transaction user is allowed per transaction. Transaction user can be set to transaction on per transaction basis.</p>
</li>
</ul>
<p>For transactions created within a dialog, the transaction user is set to the UA layer module on behalf of a particular dialog. When applications creates the transaction manually, they may set themselves as the transaction user.</p>
<h3 id="216-module-specific-data"><a class="header" href="#216-module-specific-data">2.1.6 <strong>Module Specific Data</strong></a></h3>
<p><strong>mod_data</strong> container：modules can put module specific data in that component</p>
<p>The <strong>mod_data</strong> array is indexed by module ID</p>
<p>Application can retrieve the value calling <strong>pjsip_rdata_get_tsx()</strong> or <strong>pjsip_rdata_get_dlg()</strong>,</p>
<h3 id="221-module-management-api"><a class="header" href="#221-module-management-api"><strong>2.2.1 Module Management API</strong></a></h3>
<pre><code class="language-c">pj_status_t pjsip_endpt_register_module( pjsip_endpoint *endpt,
																					pjsip_module *module );
</code></pre>
<p>Register a module to the endpoint. The endpoint will then call the load and start function in the module to properly initialize the module, and assign a unique module ID for the module.</p>
<pre><code class="language-c">pj_status_t pjsip_endpt_unregister_module( pjsip_endpoint *endpt,

																						pjsip_module *module );
</code></pre>
<p>Unregister a module from the endpoint. The endpoint will then call the stop and unload function in the module to properly shutdown the module.</p>
<h3 id="222-module-capabilities"><a class="header" href="#222-module-capabilities"><strong>2.2.2 Module Capabilities</strong></a></h3>
<p>Currently the endpoint manages these capabilities</p>
<ul>
<li>allowed SIP methods (Allow header field),</li>
<li>supported SIP extensions (Supported header field).</li>
<li>supported content type (Accept header field).</li>
</ul>
<p>These header fields will be added to outgoing requests or responses automatically, where appropriate.</p>
<p>A module declares new capability by calling <strong>pjsip_endpt_add_capability()</strong> function.</p>
<h2 id="message-elements"><a class="header" href="#message-elements"><strong>Message Elements</strong></a></h2>
<h3 id="31-uniform-resource-indicator-uri"><a class="header" href="#31-uniform-resource-indicator-uri"><strong>3.1 Uniform Resource Indicator (URI)</strong></a></h3>
<p><img src="img/URI.png" alt="img" /></p>
<h3 id="312-uri-context"><a class="header" href="#312-uri-context"><strong>3.1.2 URI Context</strong></a></h3>
<p>URI context 指明哪里使用URI，指明什么元素可以出现在context</p>
<pre><code class="language-c">/**
 * URI context.
 */
typedef enum pjsip_uri_context_e
{
    PJSIP_URI_IN_REQ_URI,       /**&lt; The URI is in Request URI. */
    PJSIP_URI_IN_FROMTO_HDR,    /**&lt; The URI is in From/To header. */
    PJSIP_URI_IN_CONTACT_HDR,   /**&lt; The URI is in Contact header. */
    PJSIP_URI_IN_ROUTING_HDR,   /**&lt; The URI is in Route/Record-Route header. */
    PJSIP_URI_IN_OTHER          /**&lt; Other context (web page, business card, etc.) */
} pjsip_uri_context_e;
</code></pre>
<h3 id="313-base-uri"><a class="header" href="#313-base-uri"><strong>3.1.3 Base URI</strong></a></h3>
<pre><code class="language-c">struct pjsip_uri
{
		pjsip_uri_vptr *vptr;
};
</code></pre>
<p><strong>pjsip_uri_vptr</strong> 虚函数表，由各类url自行定义</p>
<pre><code class="language-c">/**
 * URI 'virtual' function table.
 * All types of URI in this library (such as sip:, sips:, tel:, and name-addr) 
 * will have pointer to this table as their first struct member. This table
 * provides polimorphic behaviour to the URI.
 */
typedef struct pjsip_uri_vptr
{
    /** 
     * Get URI scheme. 
     * @param uri the URI (self).
     * @return the URI scheme.
     */
    const pj_str_t* (*p_get_scheme)(const void *uri);

    /**
     * Get the URI object contained by this URI, or the URI itself if
     * it doesn't contain another URI.
     * @param uri the URI (self).
     */
    void* (*p_get_uri)(void *uri);

    /**
     * Print URI components to the buffer, following the rule of which 
     * components are allowed for the context.
     * @param context the context where the URI will be placed.
     * @param uri the URI (self).
     * @param buf the buffer.
     * @param size the size of the buffer.
     * @return the length printed.
     */
    pj_ssize_t (*p_print)(pjsip_uri_context_e context,
                          const void *uri, 
                          char *buf, pj_size_t size);

    /** 
     * Compare two URIs according to the context.
     * @param context the context.
     * @param uri1 the first URI (self).
     * @param uri2 the second URI.
     * @return PJ_SUCCESS if equal, or otherwise the error status which
     *              should point to the mismatch part.
     */
    pj_status_t (*p_compare)(pjsip_uri_context_e context, 
                             const void *uri1, const void *uri2);

    /** 
     * Clone URI. 
     * @param pool the pool.
     * @param the URI to clone (self).
     * @return new URI.
     */
    void *(*p_clone)(pj_pool_t *pool, const void *uri);

} pjsip_uri_vptr;
</code></pre>
<p>以下的一些函数可以应用在所有类型的url上作为pjsip_uri_vptr虚函数表的初始化</p>
<p><code>const pj_str_t\* pjsip_uri_get_scheme( const pjsip_uri \*uri );</code></p>
<p>Get the URI scheme string (e.g. “sip”, “sips”, “tel”, etc.).</p>
<p><code>pjsip_uri\* pjsip_uri_get_uri( pjsip_uri \*uri );</code></p>
<p>Get the URI object. Normally all URI objects will return itself except name address which will return the URI inside the name address object.</p>
<pre><code class="language-c">pj_status_t pjsip_uri_cmp( pjsip_uri_context_e context, 
											const pjsip_uri \*uri1, 
											const pjsip_uri \*uri2);
</code></pre>
<p>Compare <em>uri1</em> and <em>uri2</em> according to the specified <em>context</em>. Parameters which are not allowed to appear in the specified context will be ignored in the comparison. It will return PJ_SUCCESS is both URIs are equal.</p>
<pre><code class="language-c">int pjsip_uri_print( 
		pjsip_uri_context_e context, 
		const pjsip_uri \*uri,
		char \*buffer, 
		pj_size_t max_size);
</code></pre>
<p>Print <em>uri</em> to the specified <em>buffer</em> according to the specified <em>context</em>. Parameters which are not allowed to appear in the specified context will not be included in the printing.</p>
<p><code>pjsip_uri* pjsip_uri_clone( pj_pool_t *pool, const pjsip_uri *uri );</code></p>
<p>Create a deep clone of <em>uri</em> using the specified pool.</p>
<h3 id="314-sip-and-sips-uri"><a class="header" href="#314-sip-and-sips-uri"><strong>3.1.4 SIP and SIPS URI</strong></a></h3>
<pre><code class="language-c">/**
 * @}
 */

/**
 * @defgroup PJSIP_SIP_URI SIP URI Scheme and Name address
 * @ingroup PJSIP_URI
 * @brief SIP URL structure ("sip:" and "sips:")
 * @{
 */


/**
 * SIP and SIPS URL scheme.
 */
typedef struct pjsip_sip_uri
{
    pjsip_uri_vptr *vptr;               /**&lt; Pointer to virtual function table.*/
    pj_str_t        user;               /**&lt; Optional user part. */
    pj_str_t        passwd;             /**&lt; Optional password part. */
    pj_str_t        host;               /**&lt; Host part, always exists. */
    int             port;               /**&lt; Optional port number, or zero. */
    pj_str_t        user_param;         /**&lt; Optional user parameter */
    pj_str_t        method_param;       /**&lt; Optional method parameter. */
    pj_str_t        transport_param;    /**&lt; Optional transport parameter. */
    int             ttl_param;          /**&lt; Optional TTL param, or -1. */
    int             lr_param;           /**&lt; Optional loose routing param, or zero */
    pj_str_t        maddr_param;        /**&lt; Optional maddr param */
    pjsip_param     other_param;        /**&lt; Other parameters grouped together. */
    pjsip_param     header_param;       /**&lt; Optional header parameter. */
} pjsip_sip_uri;
</code></pre>
<p>SIP and SIPS URI类型URL 特有函数</p>
<p><code>pjsip_sip_uri* pjsip_sip_uri_create( pj_pool_t *pool, pj_bool_t secure );</code></p>
<p>Create a new SIP URL using the specified <em>pool</em>. If the <em>secure</em> flag is set to non-zero, then SIPS URL will be created. This function will set <strong>vptr</strong> member of the URL to SIP or SIPS vptr and set all other members to blank value.</p>
<p><code>void pjsip_sip_uri_init( pjsip_sip_uri \*url, pj_bool_t secure );</code></p>
<p>Initialize a SIP URL structure.</p>
<pre><code class="language-c">void pjsip_sip_uri_assign( pj_pool_t \*pool, 
													pjsip_sip_uri \*url, 
													const pjsip_sip_uri \*rhs );
</code></pre>
<p>Perform deep copy of <em>rhs</em> to <em>url</em>.</p>
<h3 id="315-tel-uri"><a class="header" href="#315-tel-uri"><strong>3.1.5 Tel URI</strong></a></h3>
<p><code>pjsip_tel_uri\* pjsip_tel_uri_create( pj_pool_t \*pool );</code></p>
<p>Create a new tel: URI.</p>
<p><code>int pjsip_tel_nb_cmp( const pj_str_t \*nb1, const pj_str_t \*nb2 );</code></p>
<p>This utility function compares two telephone numbers for equality, according to rules specified in RFC 3966 (about tel: URI). It recognizes global and local numbers, and it ignores visual separators during the comparison.</p>
<h3 id="316-name-address"><a class="header" href="#316-name-address"><strong>3.1.6 Name Address</strong></a></h3>
<pre><code class="language-c">/**
 * SIP name-addr, which typically appear in From, To, and Contact header.
 * The SIP name-addr contains a generic URI and a display name.
 */
typedef struct pjsip_name_addr
{
    /** Pointer to virtual function table. */
    pjsip_uri_vptr  *vptr;

    /** Optional display name. */
    pj_str_t         display;

    /** URI part. */
    pjsip_uri       *uri;

} pjsip_name_addr;
</code></pre>
<p><code>pjsip_name_addr\* pjsip_name_addr_create( pj_pool_t \*pool );</code></p>
<p>Create a new name address. This will set initialize the virtual function table pointer, set blank display name and set the <strong>uri</strong> member to NULL.</p>
<pre><code class="language-c">void pjsip_name_addr_assign( pj_pool_t \*pool, 

															pjsip_name_addr \*name_addr, 

															const pjsip_name_addr \*rhs );
</code></pre>
<p>Copy rhs to name_addr.</p>
<h3 id="32-sip-methods"><a class="header" href="#32-sip-methods"><strong>3.2 SIP Methods</strong></a></h3>
<h3 id="321-sip-method-representation-pjsip_method"><a class="header" href="#321-sip-method-representation-pjsip_method"><strong>3.2.1 SIP Method Representation (pjsip_method)</strong></a></h3>
<pre><code class="language-c">/**
 * This structure represents a SIP method.
 * Application must always use either #pjsip_method_init or #pjsip_method_set
 * to make sure that method name is initialized correctly. This way, the name
 * member will always contain a valid method string regardless whether the ID
 * is recognized or not.
 */
struct pjsip_method
{
    pjsip_method_e id;      /**&lt; Method ID, from \a pjsip_method_e. */
    pj_str_t       name;    /**&lt; Method name, which will always contain the 
                                 method string. */
};

</code></pre>
<ul>
<li>
<p>可扩展</p>
</li>
<li>
<p>对于sip协议定义的头在id字段，填入以下枚举类型</p>
<pre><code class="language-c">/**
 * This enumeration declares SIP methods as described by RFC3261. Additional
 * methods do exist, and they are described by corresponding RFCs for the SIP
 * extentensions. Since they won't alter the characteristic of the processing
 * of the message, they don't need to be explicitly mentioned here.
 */
typedef enum pjsip_method_e
{
    PJSIP_INVITE_METHOD,    /**&lt; INVITE method, for establishing dialogs.   */
    PJSIP_CANCEL_METHOD,    /**&lt; CANCEL method, for cancelling request.     */
    PJSIP_ACK_METHOD,       /**&lt; ACK method.                                */
    PJSIP_BYE_METHOD,       /**&lt; BYE method, for terminating dialog.        */
    PJSIP_REGISTER_METHOD,  /**&lt; REGISTER method.                           */
    PJSIP_OPTIONS_METHOD,   /**&lt; OPTIONS method.                            */

    PJSIP_OTHER_METHOD      /**&lt; Other method.                              */

} pjsip_method_e;
</code></pre>
</li>
</ul>
<h3 id="322-sip-method-api"><a class="header" href="#322-sip-method-api"><strong>3.2.2 SIP Method API</strong></a></h3>
<pre><code class="language-c">void pjsip_method_init( 

​							pjsip_method \*method, pj_pool_t \*pool,

​							const pj_str_t \*method_name );
</code></pre>
<p>Initialize method from string. This will initialize the <strong>id</strong> of the method field to the correct value.</p>
<pre><code class="language-c">void pjsip_method_init_np( pjsip_method \*method,

​							pj_str_t \*method_name );
</code></pre>
<p>Initialize method from <em>method_name</em> string without duplicating the string (np stands for no pool). The <strong>id</strong> field will be initialize accordingly.</p>
<pre><code class="language-c">void pjsip_method_set( pjsip_method \*method, 

​							pjsip_method_id_e method_id );
</code></pre>
<p>Initialize method from the method ID enumeration. The <strong>name</strong> field will be initialized accordingly.</p>
<pre><code class="language-c">void pjsip_method_copy( 

​							pj_pool_t \*pool, 

​							pjsip_method \*method, 

​							const pjsip_method \*rhs );
</code></pre>
<p>Copy <em>rhs</em> to <em>method</em>.</p>
<pre><code class="language-c">int pjsip_method_cmp( 

​							const pjsip_method \*method1,

​							const pjsip_method \*method2 );
</code></pre>
<p>Compare <em>method1</em> to <em>method2</em> for equality. This function returns zero if both methods are equal, and (-1) or (+1) if <em>method1</em> is less or greater than <em>method2</em> respectively.</p>
<h3 id="33-header-fields"><a class="header" href="#33-header-fields"><strong>3.3 Header Fields</strong></a></h3>
<h3 id="331-header-class-diagram"><a class="header" href="#331-header-class-diagram"><strong>3.3.1 Header “Class Diagram”</strong></a></h3>
<img src="img/header.png" alt="img" style="zoom:50%;" />
<h3 id="332-header-structure"><a class="header" href="#332-header-structure"><strong>3.3.2 Header Structure</strong></a></h3>
<p>所有类型header共有的属性  **PJSIP_DECL_HDR_MEMBER(hdr)**宏保证共有属性</p>
<pre><code class="language-c">/**
 * Generic fields for all SIP headers are declared using this macro, to make
 * sure that all headers will have exactly the same layout in their start of
 * the storage. This behaves like C++ inheritance actually.
 */
#define PJSIP_DECL_HDR_MEMBER(hdr)   \
    /** List members. */        \
    PJ_DECL_LIST_MEMBER(hdr);   \
    /** Header type */          \
    pjsip_hdr_e     type;       \
    /** Header name. */         \
    pj_str_t        name;       \
    /** Header short name version. */   \
    pj_str_t        sname;              \
    /** Virtual function table. */      \
    pjsip_hdr_vptr *vptr
</code></pre>
<p>base header</p>
<pre><code class="language-c">/**
 * Generic SIP header structure, for generic manipulation for headers in the
 * message. All header fields can be typecasted to this type.
 */
struct pjsip_hdr
{
    PJSIP_DECL_HDR_MEMBER(struct pjsip_hdr);
};

</code></pre>
<p>pjsip_hdr_vptr通用虚函数表</p>
<pre><code class="language-c">/**
 * This structure provides the pointer to basic functions that are needed
 * for generic header operations. All header fields will have pointer to
 * this structure, so that they can be manipulated uniformly.
 */
typedef struct pjsip_hdr_vptr
{
    /** 
     * Function to clone the header. 
     *
     * @param pool  Memory pool to allocate the new header.
     * @param hdr   Header to clone.
     *
     * @return A new instance of the header.
     */
    void *(*clone)(pj_pool_t *pool, const void *hdr);

    /** 
     * Pointer to function to shallow clone the header. 
     * Shallow cloning will just make a memory copy of the original header,
     * thus all pointers in original header will be kept intact. Because the
     * function does not need to perform deep copy, the operation should be
     * faster, but the application must make sure that the original header
     * is still valid throughout the lifetime of new header.
     *
     * @param pool  Memory pool to allocate the new header.
     * @param hdr   The header to clone.
     */
    void *(*shallow_clone)(pj_pool_t *pool, const void *hdr);

    /** Pointer to function to print the header to the specified buffer.
     *  Returns the length of string written, or -1 if the remaining buffer
     *  is not enough to hold the header.
     *
     *  @param hdr  The header to print.
     *  @param buf  The buffer.
     *  @param len  The size of the buffer.
     *
     *  @return     The size copied to buffer, or -1 if there's not enough space.
     */
    int (*print_on)(void *hdr, char *buf, pj_size_t len);

} pjsip_hdr_vptr;
</code></pre>
<p>以下的一些函数可以应用在所有类型的header上作为pjsip_hdr_vptr虚函数表的初始化</p>
<p><strong>pjsip_hdr *pjsip_hdr_clone(</strong> <strong>pj_pool_t *pool,</strong> <strong>const pjsip_hdr *hdr );</strong></p>
<p>Perform deep clone of <em>hdr</em> header.</p>
<p><strong>pjsip_hdr *pjsip_hdr_shallow_clone( pj_pool_t *pool,</strong> <strong>const pjsip_hdr *hdr );</strong></p>
<p>Perform shallow clone of <em>hdr</em> header. A shallow cloning creates a new exact copy of the specified header field, however most of its value will still point to the values in the original header. Normally shallow clone is just a simple <strong>memcpy()</strong> from the original header to a new header, therefore it’s expected that this operation is faster than deep cloning. However, care must be taken when shallow cloning headers. It must be understood that the new header still shares common pointers to the values in the old header. Therefore, when the pool containing the original header is destroyed, the new header will be rendered invalid too although the new header was shallow-cloned using different memory pool. Or if some values in the original header was modified, then the corresponding values in the shallow-cloned header will be modified too.Despite of this, shallow cloning is used widely in the library. For example, a dialog has some headers which values are more or less persistent during the session (e.g. From, To, Call-Id, Route, and Contact). When creating a request, the dialog can just shallow-clone these headers (instead of performing full cloning) and put them in the request message.</p>
<p><strong>int pjsip_hdr_print_on( pjsip_hdr *hdr,</strong> <strong>char *buf, pj_size_t max_size);</strong></p>
<p>Print the specified header to a buffer (e.g. before transmission). This function returns the number of bytes printed to the buffer, or –1 when the buffer is overflow.</p>
<h3 id="334-supported-header-fields"><a class="header" href="#334-supported-header-fields"><strong>3.3.4 Supported Header Fields</strong></a></h3>
<ul>
<li>
<p>标准头部在The “standard” PJSIP header fields are declared in &lt;pjsip/sip_msg.h&gt;.</p>
</li>
<li>
<p>Other header fields may be declared in header files that implement specific functionalities or SIP extensions (e.g. headers used by SIMPLE extension, etc.).</p>
</li>
<li>
<p>创建头部The APIs to create individual header fields are by convention named after the header field name and followed by <strong>_create()</strong> suffix. For example, call function <strong>pjsip_via_hdr_create()</strong> to create an instance of <strong>pjsip_via_hdr</strong> header.</p>
</li>
</ul>
<h3 id="335-header-array-elements"><a class="header" href="#335-header-array-elements"><strong>3.3.5 Header Array Elements</strong></a></h3>
<p>群组sip消息，拆分处理</p>
<p>When the parser encounters such arrays in headers, it will split the array into individual headers while maintaining their order of appearance.</p>
<h3 id="34-message-body-pjsip_msg_body消息体本身"><a class="header" href="#34-message-body-pjsip_msg_body消息体本身">**3.4 Message Body (pjsip_msg_body)**消息体本身</a></h3>
<p>数据、类型、长度</p>
<pre><code class="language-c">/**
 * @addtogroup PJSIP_MSG_BODY Message Body
 * @brief SIP message body structures and manipulation.
 * @ingroup PJSIP_MSG
 * @{
 */

/**
 * Generic abstraction to message body.
 * When an incoming message is parsed (pjsip_parse_msg()), the parser fills in
 * all members with the appropriate value. The 'data' and 'len' member will
 * describe portion of incoming packet which denotes the message body.
 * When application needs to attach message body to outgoing SIP message, it
 * must fill in all members of this structure. 
 */
struct pjsip_msg_body
{
    /** MIME content type. 
     *  For incoming messages, the parser will fill in this member with the
     *  content type found in Content-Type header.
     *
     *  For outgoing messages, application may fill in this member with
     *  appropriate value, because the stack will generate Content-Type header
     *  based on the value specified here.
     *
     *  If the content_type is empty, no Content-Type AND Content-Length header
     *  will be added to the message. The stack assumes that application adds
     *  these headers themselves.
     */
    pjsip_media_type content_type;

    /** Pointer to buffer which holds the message body data. 
     *  For incoming messages, the parser will fill in this member with the
     *  pointer to the body string.
     *
     *  When sending outgoing message, this member doesn't need to point to the
     *  actual message body string. It can be assigned with arbitrary pointer,
     *  because the value will only need to be understood by the print_body()
     *  function. The stack itself will not try to interpret this value, but
     *  instead will always call the print_body() whenever it needs to get the
     *  actual body string.
     */
    void *data;

    /** The length of the data. 
     *  For incoming messages, the parser will fill in this member with the
     *  actual length of message body.
     *
     *  When sending outgoing message, again just like the "data" member, the
     *  "len" member doesn't need to point to the actual length of the body 
     *  string.
     */
    unsigned len;

    /** Pointer to function to print this message body. 
     *  Application must set a proper function here when sending outgoing 
     *  message.
     *
     *  @param msg_body     This structure itself.
     *  @param buf          The buffer.
     *  @param size         The buffer size.
     *
     *  @return             The length of the string printed, or -1 if there is
     *                      not enough space in the buffer to print the whole
     *                      message body.
     */
    int (*print_body)(struct pjsip_msg_body *msg_body, 
                      char *buf, pj_size_t size);

    /** Clone the data part only of this message body. Note that this only
     *  duplicates the data part of the body instead of the whole message
     *  body. If application wants to duplicate the entire message body
     *  structure, it must call #pjsip_msg_body_clone().
     *
     *  @param pool         Pool used to clone the data.
     *  @param data         The data inside message body, to be cloned.
     *  @param len          The length of the data.
     *
     *  @return             New data duplicated from the original data.
     */
    void* (*clone_data)(pj_pool_t *pool, const void *data, unsigned len);

};
</code></pre>
<pre><code class="language-c">pj_status_t pjsip_msg_body_clone( pj_pool_t \*pool,

																	pjsip_msg_body \*dst_body,

																	const pjsip_msg_body \*src_body);
</code></pre>
<p>Clone the message body in <em>src_body</em> to the <em>dst_body</em>. This will duplicate the contents of the message body using the <em>clone_data</em> member of the source message body.</p>
<h3 id="35-message-pjsip_msg"><a class="header" href="#35-message-pjsip_msg"><strong>3.5 Message (pjsip_msg)</strong></a></h3>
<pre><code class="language-c">
/* **************************************************************************/
/**
 * @defgroup PJSIP_MSG_MSG Message Structure
 * @brief SIP message (request and response) structure and operations.
 * @ingroup PJSIP_MSG
 * @{
 */

/**
 * Message type (request or response).
 */
typedef enum pjsip_msg_type_e
{
    PJSIP_REQUEST_MSG,      /**&lt; Indicates request message. */
    PJSIP_RESPONSE_MSG      /**&lt; Indicates response message. */
} pjsip_msg_type_e;


/**
 * This structure describes a SIP message.
 */
struct pjsip_msg
{
    /** Message type (ie request or response). */
    pjsip_msg_type_e  type;

    /** The first line of the message can be either request line for request
     *  messages, or status line for response messages. It is represented here
     *  as a union.
     */
    union
    {
        /** Request Line. */
        struct pjsip_request_line   req;

        /** Status Line. */
        struct pjsip_status_line    status;
    } line;

    /** List of message headers. */
    pjsip_hdr hdr;

    /** Pointer to message body, or NULL if no message body is attached to
     *  this mesage. 
     */
    pjsip_msg_body *body;
};
</code></pre>
<ul>
<li>request and response message in PJSIP are represented with <strong>pjsip_msg</strong></li>
</ul>
<pre><code class="language-c">/** 
 * Create new request or response message.
 *
 * @param pool      The pool.
 * @param type      Message type.
 * @return          New message, or THROW exception if failed.
 */
PJ_DECL(pjsip_msg*)  pjsip_msg_create( pj_pool_t *pool, pjsip_msg_type_e type);


/**
 * Perform a deep clone of a SIP message.
 *
 * @param pool      The pool for creating the new message.
 * @param msg       The message to be duplicated.
 *
 * @return          New message, which is duplicated from the original 
 *                  message.
 */
PJ_DECL(pjsip_msg*) pjsip_msg_clone( pj_pool_t *pool, const pjsip_msg *msg);


/** 
 * Find a header in the message by the header type.
 *
 * @param msg       The message.
 * @param type      The header type to find.
 * @param start     The first header field where the search should begin.
 *                  If NULL is specified, then the search will begin from the
 *                  first header, otherwise the search will begin at the
 *                  specified header.
 *
 * @return          The header field, or NULL if no header with the specified 
 *                  type is found.
 */
PJ_DECL(void*)  pjsip_msg_find_hdr( const pjsip_msg *msg, 
                                    pjsip_hdr_e type, const void *start);

/** 
 * Find a header in the message by its name.
 *
 * @param msg       The message.
 * @param name      The header name to find.
 * @param start     The first header field where the search should begin.
 *                  If NULL is specified, then the search will begin from the
 *                  first header, otherwise the search will begin at the
 *                  specified header.
 *
 * @return          The header field, or NULL if no header with the specified 
 *                  type is found.
 */
PJ_DECL(void*)  pjsip_msg_find_hdr_by_name( const pjsip_msg *msg, 
                                            const pj_str_t *name, 
                                            const void *start);

/** 
 * Find a header in the message by its name and short name version.
 *
 * @param msg       The message.
 * @param name      The header name to find.
 * @param sname     The short name version of the header name.
 * @param start     The first header field where the search should begin.
 *                  If NULL is specified, then the search will begin from the
 *                  first header, otherwise the search will begin at the
 *                  specified header.
 *
 * @return          The header field, or NULL if no header with the specified 
 *                  type is found.
 */
PJ_DECL(void*)  pjsip_msg_find_hdr_by_names(const pjsip_msg *msg, 
                                            const pj_str_t *name, 
                                            const pj_str_t *sname,
                                            const void *start);

/** 
 * Find and remove a header in the message. 
 *
 * @param msg       The message.
 * @param hdr       The header type to find.
 * @param start     The first header field where the search should begin,
 *                  or NULL to search from the first header in the message.
 *
 * @return          The header field, or NULL if not found.
 */
PJ_DECL(void*)  pjsip_msg_find_remove_hdr( pjsip_msg *msg, 
                                           pjsip_hdr_e hdr, void *start);

/** 
 * Add a header to the message, putting it last in the header list.
 *
 * @param msg       The message.
 * @param hdr       The header to add.
 *
 * @bug Once the header is put in a list (or message), it can not be put in 
 *      other list (or message). Otherwise Real Bad Thing will happen.
 */
PJ_INLINE(void) pjsip_msg_add_hdr( pjsip_msg *msg, pjsip_hdr *hdr )
{
    pj_list_insert_before(&amp;msg-&gt;hdr, hdr);
}

/** 
 * Add header field to the message, putting it in the front of the header list.
 *
 * @param msg   The message.
 * @param hdr   The header to add.
 *
 * @bug Once the header is put in a list (or message), it can not be put in 
 *      other list (or message). Otherwise Real Bad Thing will happen.
 */
PJ_INLINE(void) pjsip_msg_insert_first_hdr( pjsip_msg *msg, pjsip_hdr *hdr )
{
    pj_list_insert_after(&amp;msg-&gt;hdr, hdr);
}

/** 
 * Print the message to the specified buffer. 
 *
 * @param msg   The message to print.
 * @param buf   The buffer
 * @param size  The size of the buffer.
 *
 * @return      The length of the printed characters (in bytes), or NEGATIVE
 *              value if the message is too large for the specified buffer.
 */
PJ_DECL(pj_ssize_t) pjsip_msg_print(const pjsip_msg *msg, 
                                    char *buf, pj_size_t size);


</code></pre>
<h3 id="36-sip-status-codes"><a class="header" href="#36-sip-status-codes"><strong>3.6 SIP Status Codes</strong></a></h3>
<p>sip状态码</p>
<pre><code class="language-c">/**
 * This enumeration lists standard SIP status codes according to RFC 3261.
 * In addition, it also declares new status class 7xx for errors generated
 * by the stack. This status class however should not get transmitted on the 
 * wire.
 */
typedef enum pjsip_status_code
{
    PJSIP_SC_NULL = 0,

    PJSIP_SC_TRYING = 100,
    PJSIP_SC_RINGING = 180,
    PJSIP_SC_CALL_BEING_FORWARDED = 181,
    PJSIP_SC_QUEUED = 182,
    PJSIP_SC_PROGRESS = 183,
    PJSIP_SC_EARLY_DIALOG_TERMINATED = 199,

    PJSIP_SC_OK = 200,
    PJSIP_SC_ACCEPTED = 202,
    PJSIP_SC_NO_NOTIFICATION = 204,

    PJSIP_SC_MULTIPLE_CHOICES = 300,
    PJSIP_SC_MOVED_PERMANENTLY = 301,
    PJSIP_SC_MOVED_TEMPORARILY = 302,
    PJSIP_SC_USE_PROXY = 305,
    PJSIP_SC_ALTERNATIVE_SERVICE = 380,

    PJSIP_SC_BAD_REQUEST = 400,
    PJSIP_SC_UNAUTHORIZED = 401,
    PJSIP_SC_PAYMENT_REQUIRED = 402,
    PJSIP_SC_FORBIDDEN = 403,
    PJSIP_SC_NOT_FOUND = 404,
    PJSIP_SC_METHOD_NOT_ALLOWED = 405,
    PJSIP_SC_NOT_ACCEPTABLE = 406,
    PJSIP_SC_PROXY_AUTHENTICATION_REQUIRED = 407,
    PJSIP_SC_REQUEST_TIMEOUT = 408,
    PJSIP_SC_CONFLICT = 409,
    PJSIP_SC_GONE = 410,
    PJSIP_SC_LENGTH_REQUIRED = 411,
    PJSIP_SC_CONDITIONAL_REQUEST_FAILED = 412,
    PJSIP_SC_REQUEST_ENTITY_TOO_LARGE = 413,
    PJSIP_SC_REQUEST_URI_TOO_LONG = 414,
    PJSIP_SC_UNSUPPORTED_MEDIA_TYPE = 415,
    PJSIP_SC_UNSUPPORTED_URI_SCHEME = 416,
    PJSIP_SC_UNKNOWN_RESOURCE_PRIORITY = 417,
    PJSIP_SC_BAD_EXTENSION = 420,
    PJSIP_SC_EXTENSION_REQUIRED = 421,
    PJSIP_SC_SESSION_TIMER_TOO_SMALL = 422,
    PJSIP_SC_INTERVAL_TOO_BRIEF = 423,
    PJSIP_SC_BAD_LOCATION_INFORMATION = 424,
    PJSIP_SC_USE_IDENTITY_HEADER = 428,
    PJSIP_SC_PROVIDE_REFERRER_HEADER = 429,
    PJSIP_SC_FLOW_FAILED = 430,
    PJSIP_SC_ANONIMITY_DISALLOWED = 433,
    PJSIP_SC_BAD_IDENTITY_INFO = 436,
    PJSIP_SC_UNSUPPORTED_CERTIFICATE = 437,
    PJSIP_SC_INVALID_IDENTITY_HEADER = 438,
    PJSIP_SC_FIRST_HOP_LACKS_OUTBOUND_SUPPORT = 439,
    PJSIP_SC_MAX_BREADTH_EXCEEDED = 440,
    PJSIP_SC_BAD_INFO_PACKAGE = 469,
    PJSIP_SC_CONSENT_NEEDED = 470,
    PJSIP_SC_TEMPORARILY_UNAVAILABLE = 480,
    PJSIP_SC_CALL_TSX_DOES_NOT_EXIST = 481,
    PJSIP_SC_LOOP_DETECTED = 482,
    PJSIP_SC_TOO_MANY_HOPS = 483,
    PJSIP_SC_ADDRESS_INCOMPLETE = 484,
    PJSIP_AC_AMBIGUOUS = 485,
    PJSIP_SC_BUSY_HERE = 486,
    PJSIP_SC_REQUEST_TERMINATED = 487,
    PJSIP_SC_NOT_ACCEPTABLE_HERE = 488,
    PJSIP_SC_BAD_EVENT = 489,
    PJSIP_SC_REQUEST_UPDATED = 490,
    PJSIP_SC_REQUEST_PENDING = 491,
    PJSIP_SC_UNDECIPHERABLE = 493,
    PJSIP_SC_SECURITY_AGREEMENT_NEEDED = 494,

    PJSIP_SC_INTERNAL_SERVER_ERROR = 500,
    PJSIP_SC_NOT_IMPLEMENTED = 501,
    PJSIP_SC_BAD_GATEWAY = 502,
    PJSIP_SC_SERVICE_UNAVAILABLE = 503,
    PJSIP_SC_SERVER_TIMEOUT = 504,
    PJSIP_SC_VERSION_NOT_SUPPORTED = 505,
    PJSIP_SC_MESSAGE_TOO_LARGE = 513,
    PJSIP_SC_PUSH_NOTIFICATION_SERVICE_NOT_SUPPORTED = 555,
    PJSIP_SC_PRECONDITION_FAILURE = 580,

    PJSIP_SC_BUSY_EVERYWHERE = 600,
    PJSIP_SC_DECLINE = 603,
    PJSIP_SC_DOES_NOT_EXIST_ANYWHERE = 604,
    PJSIP_SC_NOT_ACCEPTABLE_ANYWHERE = 606,
    PJSIP_SC_UNWANTED = 607,
    PJSIP_SC_REJECTED = 608,

    PJSIP_SC_TSX_TIMEOUT = PJSIP_SC_REQUEST_TIMEOUT,
    /*PJSIP_SC_TSX_RESOLVE_ERROR = 702,*/
    PJSIP_SC_TSX_TRANSPORT_ERROR = PJSIP_SC_SERVICE_UNAVAILABLE,

    /* This is not an actual status code, but rather a constant
     * to force GCC to use 32bit to represent this enum, since
     * we have a code in PJSUA-LIB that assigns an integer
     * to this enum (see pjsua_acc_get_info() function).
     */
    PJSIP_SC__force_32bit = 0x7FFFFFFF

} pjsip_status_code;
</code></pre>
<h3 id="37-non-standard-parameter-elements"><a class="header" href="#37-non-standard-parameter-elements"><strong>3.7 Non-Standard Parameter Elements</strong></a></h3>
<ul>
<li>标准参数有特定字段“standard” parameters (e.g. URI parameters, header field parameters) will normally be represented as individual attributes/fields of the corresponding structure.</li>
<li>非标准参数在other_param中Parameters that are not “standard” will be put in a list of parameters, with each parameter is represented as <strong>pjsip_param</strong> structure. Non standard parameter normally is declared as <strong>other_param</strong> field in the owning structure.</li>
</ul>
<pre><code class="language-c">/**
 * Generic parameter, normally used in other_param or header_param.
 */
typedef struct pjsip_param
{
    PJ_DECL_LIST_MEMBER(struct pjsip_param);    /**&lt; Generic list member.   */
    pj_str_t        name;                       /**&lt; Param/header name.     */
    pj_str_t        value;                      /**&lt; Param/header value.    */
} pjsip_param;
</code></pre>
<p>相关函数</p>
<pre><code class="language-c">/**
 * Find the specified parameter name in the list. The name will be compared
 * in case-insensitive comparison.
 *
 * @param param_list    List of parameters to find.
 * @param name          Parameter/header name to find.
 *
 * @return              The parameter if found, or NULL.
 */
PJ_DECL(pjsip_param*) pjsip_param_find( const pjsip_param *param_list,
                                        const pj_str_t *name );


/**
 * Alias for pjsip_param_find()
 */
PJ_INLINE(pjsip_param*) pjsip_param_cfind(const pjsip_param *param_list,
                                          const pj_str_t *name)
{
    return pjsip_param_find(param_list, name);
}

/**
 * Compare two parameter lists.
 *
 * @param param_list1   First parameter list.
 * @param param_list2   Second parameter list.
 * @param ig_nf         If set to 1, do not compare parameters that only
 *                      appear in one of the list.
 *
 * @return              Zero if the parameter list are equal, non-zero
 *                      otherwise.
 */
PJ_DECL(int) pjsip_param_cmp(const pjsip_param *param_list1,
                             const pjsip_param *param_list2,
                             pj_bool_t ig_nf);

/**
 * Duplicate the parameters.
 *
 * @param pool          Pool to allocate memory from.
 * @param dst_list      Destination list.
 * @param src_list      Source list.
 */
PJ_DECL(void) pjsip_param_clone(pj_pool_t *pool, pjsip_param *dst_list,
                                const pjsip_param *src_list);

/**
 * Duplicate the parameters.
 *
 * @param pool          Pool to allocate memory from.
 * @param dst_list      Destination list.
 * @param src_list      Source list.
 */
PJ_DECL(void) pjsip_param_shallow_clone(pj_pool_t *pool, 
                                        pjsip_param *dst_list,
                                        const pjsip_param *src_list);

/**
 * Print parameters.
 *
 * @param param_list    The parameter list.
 * @param buf           Buffer.
 * @param size          Size of buffer.
 * @param pname_unres   Specification of allowed characters in pname.
 * @param pvalue_unres  Specification of allowed characters in pvalue.
 * @param sep           Separator character (either ';', ',', or '?').
 *                      When separator is set to '?', this function will
 *                      automatically adjust the separator character to
 *                      '&amp;' after the first parameter is printed.
 *
 * @return              The number of bytes printed, or -1 on errr.
 */
PJ_DECL(pj_ssize_t) pjsip_param_print_on(const pjsip_param *param_list,
                                         char *buf, pj_size_t size,
                                         const pj_cis_t *pname_unres,
                                         const pj_cis_t *pvalue_unres,
                                         int sep);

</code></pre>
<h2 id="chapter-4parser"><a class="header" href="#chapter-4parser"><strong>Chapter 4:Parser</strong></a></h2>
<h3 id="41-features"><a class="header" href="#41-features"><strong>4.1 Features</strong></a></h3>
<ul>
<li>zero-copy for all message elements，only pointer and length</li>
<li>uses PJLIB’s memory pool</li>
<li>zero synchronization</li>
<li>uses PJLIB’s try/catch exception framework</li>
<li>top-down, handwritten parser</li>
<li>It’s reentrant</li>
<li>It’s extensible</li>
</ul>
<h3 id="42-functions"><a class="header" href="#42-functions"><strong>4.2 Functions</strong></a></h3>
<h3 id="421-message-parsing"><a class="header" href="#421-message-parsing"><strong>4.2.1 Message Parsing</strong></a></h3>
<pre><code class="language-c">/**
 * Parse a packet buffer and build a full SIP message from the packet. This
 * function parses all parts of the message, including request/status line,
 * all headers, and the message body. The message body however is only 
 * treated as a text block, ie. the function will not try to parse the content
 * of the body.
 *
 * Note that the input string buffer MUST be NULL terminated and have
 * length at least size+1 (size MUST NOT include the NULL terminator).
 *
 * @param pool          The pool to allocate memory.
 * @param buf           The input buffer, which MUST be NULL terminated.
 * @param size          The length of the string (not counting NULL terminator).
 * @param err_list      If this parameter is not NULL, then the parser will
 *                      put error messages during parsing in this list.
 *
 * @return              The message or NULL when failed. No exception is thrown
 *                      by this function (or any public parser functions).
 */
PJ_DECL(pjsip_msg *) pjsip_parse_msg( pj_pool_t *pool, 
                                      char *buf, pj_size_t size,
                                      pjsip_parser_err_report *err_list);


/**
 * Parse a packet buffer and build a rdata. The resulting message will be
 * stored in \c msg field in the \c rdata. This behaves pretty much like
 * #pjsip_parse_msg(), except that it will also initialize the header fields
 * in the \c rdata.
 *
 * This function is normally called by the transport layer.
 *
 * Note that the input string buffer MUST be NULL terminated and have
 * length at least size+1 (size MUST NOT include the NULL terminator).
 *
 * @param buf           The input buffer, which MUST be NULL terminated.
 * @param size          The length of the string (not counting NULL terminator).
 * @param rdata         The receive data buffer to store the message and
 *                      its elements.
 *
 * @return              The message inside the rdata if successfull, or NULL.
 */
PJ_DECL(pjsip_msg *) pjsip_parse_rdata( char *buf, pj_size_t size,
                                        pjsip_rx_data *rdata );

/**
 * Check incoming packet to see if a (probably) valid SIP message has been 
 * received.
 * Note that the input string buffer MUST be NULL terminated and have
 * length at least size+1 (size MUST NOT include the NULL terminator).
 *
 * @param buf           The input buffer, which must be NULL terminated.
 * @param size          The length of the string (not counting NULL terminator).
 * @param is_datagram   Put non-zero if transport is datagram oriented.
 * @param msg_size      [out] If message is valid, this parameter will contain
 *                      the size of the SIP message (including body, if any).
 *
 * @return              PJ_SUCCESS if a message is found, or an error code.
 */
PJ_DECL(pj_status_t) pjsip_find_msg(const char *buf, 
                                    pj_size_t size, 
                                    pj_bool_t is_datagram, 
                                    pj_size_t *msg_size);

</code></pre>
<h3 id="422-uri-parsing"><a class="header" href="#422-uri-parsing"><strong>4.2.2 URI Parsing</strong></a></h3>
<pre><code class="language-c">/**
 * Parse an URI in the input and return the correct instance of URI.
 * Note that the input string buffer MUST be NULL terminated and have
 * length at least size+1 (size MUST NOT include the NULL terminator).
 *
 * @param pool          The pool to get memory allocations.
 * @param buf           The input buffer, which MUST be NULL terminated.
 * @param size          The length of the string (not counting NULL terminator).
 * @param options       If no options are given (value is zero), the object 
 *                      returned is dependent on the syntax of the URI, 
 *                      eg. basic SIP URL, TEL URL, or name address. 
 *                      If option PJSIP_PARSE_URI_AS_NAMEADDR is given,
 *                      then the returned object is always name address object,
 *                      with the relevant URI object contained in the name 
 *                      address object.
 * @return              The URI or NULL when failed. No exception is thrown by 
 *                      this function (or any public parser functions).
 */
PJ_DECL(pjsip_uri*) pjsip_parse_uri( pj_pool_t *pool, 
                                     char *buf, pj_size_t size,
                                     unsigned options);
</code></pre>
<h3 id="423-header-parsing"><a class="header" href="#423-header-parsing"><strong>4.2.3 Header Parsing</strong></a></h3>
<pre><code class="language-c">/**
 * Parse the content of a header and return the header instance.
 * This function parses the content of a header (ie. part after colon) according
 * to the expected name, and will return the correct instance of header.
 *
 * Note that the input string buffer MUST be NULL terminated and have
 * length at least size+1 (size MUST NOT include the NULL terminator). 
 *
 * @param pool          Pool to allocate memory for the header.
 * @param hname         Header name which is used to find the correct function
 *                      to parse the header.
 * @param line          Header content, which must be NULL terminated.
 * @param size          The length of the string (not counting NULL terminator,
 *                      if any).
 * @param parsed_len    If the value is not NULL, then upon return the function
 *                      will fill the pointer with the length of the string
 *                      that has been parsed. This is usefull for two purposes,
 *                      one is when the string may contain more than one header
 *                      lines, and two when an error happen the value can
 *                      pinpoint the location of the error in the buffer.
 *
 * @return              The instance of the header if parsing was successful,
 *                      or otherwise a NULL pointer will be returned.
 */
PJ_DECL(void*) pjsip_parse_hdr( pj_pool_t *pool, const pj_str_t *hname,
                                char *line, pj_size_t size,
                                int *parsed_len);
                                
/**
 * Parse header line(s). Multiple headers can be parsed by this function.
 * When there are multiple headers, the headers MUST be separated by either
 * a newline (as in SIP message) or ampersand mark (as in URI). This separator
 * is optional for the last header.
 *
 * Note that the input string buffer MUST be NULL terminated and have
 * length at least size+1 (size MUST NOT include the NULL terminator).
 *
 * @param pool          The pool.
 * @param input         The input text to parse, which must be NULL terminated.
 * @param size          The text length (not counting NULL terminator).
 * @param hlist         The header list to store the parsed headers.
 *                      This list must have been initialized before calling 
 *                      this function.
 * @param options       Specify 1 here to make parsing stop when error is
 *                      encountered when parsing the header. Otherwise the
 *                      error is silently ignored and parsing resumes to the
 *                      next line.
 * @return              zero if successfull, or -1 if error is encountered. 
 *                      Upon error, the \a hlist argument MAY contain 
 *                      successfully parsed headers.
 */
PJ_DECL(pj_status_t) pjsip_parse_headers( pj_pool_t *pool, char *input,
                                          pj_size_t size, pjsip_hdr *hlist,
                                          unsigned options);


</code></pre>
<p>pjsip_parse_headers是multiple</p>
<h3 id="43-extending-parser"><a class="header" href="#43-extending-parser"><strong>4.3 Extending Parser</strong></a></h3>
<h2 id="chapter-5message-buffers"><a class="header" href="#chapter-5message-buffers"><strong>Chapter 5:Message Buffers</strong></a></h2>
<h3 id="51-receive-data-buffer"><a class="header" href="#51-receive-data-buffer"><strong>5.1 Receive Data Buffer</strong></a></h3>
<h3 id="511-receive-data-buffer-structure"><a class="header" href="#511-receive-data-buffer-structure"><strong>5.1.1 Receive Data Buffer Structure</strong></a></h3>
<p>A SIP message received by PJSIP will be passed around to different PJSIP software components as <strong>pjsip_rx_data</strong> instead of a plain message. This structure contains all information describing the received message.各个部件彼此传递pjsip_rx_data，包含关于received message的信息</p>
<pre><code class="language-c">/**
 * Incoming message buffer.
 * This structure keep all the information regarding the received message. This
 * buffer lifetime is only very short, normally after the transaction has been
 * called, this buffer will be deleted/recycled. So care must be taken when
 * allocating storage from the pool of this buffer.
 */
struct pjsip_rx_data
{

    /**
     * tp_info is part of rdata that remains static for the duration of the
     * buffer. It is initialized when the buffer was created by transport.
     */
    struct 
    {
        /** Memory pool for this buffer. */
        pj_pool_t               *pool;

        /** The transport object which received this packet. */
        pjsip_transport         *transport;

        /** Other transport specific data to be attached to this buffer. */
        void                    *tp_data;

        /** Ioqueue key. */
        pjsip_rx_data_op_key     op_key;

    } tp_info;


    /**
     * pkt_info is initialized by transport when it receives an incoming
     * packet.
     */
    struct
    {
        /** Time when the message was received. */
        pj_time_val              timestamp;

        /** Pointer to the original packet. */
        char                     packet[PJSIP_MAX_PKT_LEN];

        /** Zero termination for the packet. */
        pj_uint32_t              zero;

        /** The length of the packet received. */
        pj_ssize_t               len;

        /** The source address from which the packet was received. */
        pj_sockaddr              src_addr;

        /** The length of the source address. */
        int                      src_addr_len;

        /** The IP source address string (NULL terminated). */
        char                     src_name[PJ_INET6_ADDRSTRLEN];

        /** The IP source port number. */
        int                      src_port;

    } pkt_info;


    /**
     * msg_info is initialized by transport mgr (tpmgr) before this buffer
     * is passed to endpoint.
     */
    struct
    {
        /** Start of msg buffer. */
        char                    *msg_buf;

        /** Length fo message. */
        int                      len;

        /** The parsed message, if any. */
        pjsip_msg               *msg;

        /** Short description about the message. 
         *  Application should use #pjsip_rx_data_get_info() instead.
         */
        char                    *info;

        /** The Call-ID header as found in the message. */
        pjsip_cid_hdr           *cid;

        /** The From header as found in the message. */
        pjsip_from_hdr          *from;

        /** The To header as found in the message. */
        pjsip_to_hdr            *to;

        /** The topmost Via header as found in the message. */
        pjsip_via_hdr           *via;

        /** The CSeq header as found in the message. */
        pjsip_cseq_hdr          *cseq;

        /** Max forwards header. */
        pjsip_max_fwd_hdr       *max_fwd;

        /** The first route header. */
        pjsip_route_hdr         *route;

        /** The first record-route header. */
        pjsip_rr_hdr            *record_route;

        /** Content-type header. */
        pjsip_ctype_hdr         *ctype;

        /** Content-length header. */
        pjsip_clen_hdr          *clen;

        /** "Require" header containing aggregates of all Require
         *  headers found in the message, or NULL. 
         */
        pjsip_require_hdr       *require;

        /** "Supported" header containing aggregates of all Supported
         *  headers found in the message, or NULL. 
         */
        pjsip_supported_hdr     *supported;

        /** The list of error generated by the parser when parsing 
            this message. 
         */
        pjsip_parser_err_report parse_err;

    } msg_info;


    /**
     * endpt_info is initialized by endpoint after this buffer reaches
     * endpoint.
     */
    struct
    {
        /** 
         * Data attached by modules to this message. 
         */
        void    *mod_data[PJSIP_MAX_MODULE];

    } endpt_info;

};
</code></pre>
<h3 id="52-transmit-data-buffer-pjsip_tx_data"><a class="header" href="#52-transmit-data-buffer-pjsip_tx_data"><strong>5.2 Transmit Data Buffer (pjsip_tx_data)</strong></a></h3>
<p>当要向往发送消息使用结构：<strong>pjsip_tx_data</strong> transmit data buffer 传输数据缓冲区提供了一个内存池，所有属于该消息的消息字段都必须从该内存池中分配，它还提供了一个引用计数器、锁保护和传输层处理该消息所需的其他信息。</p>
<pre><code class="language-c">c/**
 * Data structure for sending outgoing message. Application normally creates
 * this buffer by calling #pjsip_endpt_create_tdata.
 *
 * The lifetime of this buffer is controlled by the reference counter in this
 * structure, which is manipulated by calling #pjsip_tx_data_add_ref and
 * #pjsip_tx_data_dec_ref. When the reference counter has reached zero, then
 * this buffer will be destroyed.
 *
 * A transaction object normally will add reference counter to this buffe
 * when application calls #pjsip_tsx_send_msg, because it needs to keep the
 * message for retransmission. The transaction will release the reference
 * counter once its state has reached final state.
 */
struct pjsip_tx_data
{
    /** This is for transmission queue; it's managed by transports. */
    PJ_DECL_LIST_MEMBER(struct pjsip_tx_data);

    /** Memory pool for this buffer. */
    pj_pool_t           *pool;

    /** A name to identify this buffer. */
    char                 obj_name[PJ_MAX_OBJ_NAME];

    /** Short information describing this buffer and the message in it. 
     *  Application should use #pjsip_tx_data_get_info() instead of
     *  directly accessing this member.
     */
    char                *info;

    /** For response message, this contains the reference to timestamp when 
     *  the original request message was received. The value of this field
     *  is set when application creates response message to a request by
     *  calling #pjsip_endpt_create_response.
     */
    pj_time_val          rx_timestamp;

    /** The transport manager for this buffer. */
    pjsip_tpmgr         *mgr;

    /** Ioqueue asynchronous operation key. */
    pjsip_tx_data_op_key op_key;

    /** Lock object. */
    pj_lock_t           *lock;

    /** The message in this buffer. */
    pjsip_msg           *msg;

    /** Strict route header saved by #pjsip_process_route_set(), to be
     *  restored by #pjsip_restore_strict_route_set().
     */
    pjsip_route_hdr     *saved_strict_route;

    /** Buffer to the printed text representation of the message. When the
     *  content of this buffer is set, then the transport will send the content
     *  of this buffer instead of re-printing the message structure. If the
     *  message structure has changed, then application must invalidate this
     *  buffer by calling #pjsip_tx_data_invalidate_msg.
     */
    pjsip_buffer         buf;

    /** Reference counter. */
    pj_atomic_t         *ref_cnt;

    /** Being processed by transport? */
    int                  is_pending;

    /** Transport manager internal. */
    void                *token;

    /** Callback to be called when this tx_data has been transmitted.   */
    void               (*cb)(void*, pjsip_tx_data*, pj_ssize_t);

    /** Destination information, to be used to determine the network address
     *  of the message. For a request, this information is  initialized when
     *  the request is sent with #pjsip_endpt_send_request_stateless() and
     *  network address is resolved. For CANCEL request, this information
     *  will be copied from the original INVITE to make sure that the CANCEL
     *  request goes to the same physical network address as the INVITE
     *  request.
     */
    struct
    {
        /** Server name. 
         */
        pj_str_t                 name;

        /** Server addresses resolved. 
         */
        pjsip_server_addresses   addr;

        /** Current server address being tried. 
         */
        unsigned cur_addr;

    } dest_info;

    /** Transport information, only valid during on_tx_request() and 
     *  on_tx_response() callback.
     */
    struct
    {
        pjsip_transport     *transport;     /**&lt; Transport being used.  */
        pj_sockaddr          dst_addr;      /**&lt; Destination address.   */
        int                  dst_addr_len;  /**&lt; Length of address.     */
        char                 dst_name[PJ_INET6_ADDRSTRLEN]; /**&lt; Destination address.   */
        int                  dst_port;      /**&lt; Destination port.      */
    } tp_info;

    /** 
     * Transport selector, to specify which transport to be used. 
     * The value here must be set with pjsip_tx_data_set_transport(),
     * to allow reference counter to be set properly.
     */
    pjsip_tpselector        tp_sel;

    /**
     * Special flag to indicate that this transmit data is a request that has
     * been updated with proper authentication response and is ready to be
     * sent for retry.
     */
    pj_bool_t               auth_retry;

    /**
     * Arbitrary data attached by PJSIP modules.
     */
    void                    *mod_data[PJSIP_MAX_MODULE];

    /**
     * If via_addr is set, it will be used as the "sent-by" field of the
     * Via header for outgoing requests as long as the request uses via_tp
     * transport. Normally application should not use or access these fields.
     */
    pjsip_host_port          via_addr;      /**&lt; Via address.           */
    const void              *via_tp;        /**&lt; Via transport.         */
};
</code></pre>
<h2 id="chapter-6transport-layer"><a class="header" href="#chapter-6transport-layer"><strong>Chapter 6:Transport Layer</strong></a></h2>
<h3 id="61-transport-layer-design"><a class="header" href="#61-transport-layer-design"><strong>6.1 Transport Layer Design</strong></a></h3>
<p>send/receive messages across the network</p>
<h3 id="611-class-diagram"><a class="header" href="#611-class-diagram"><strong>6.1.1 “Class Diagram”</strong></a></h3>
<p><img src="img/Transport_Layer.png" alt="" /></p>
<p>endpoint 中有一个transport manager的实例<code>pjsip_tpmgr *transport_mgr;</code>transport manager管理transport和transport factory</p>
<h3 id="612-transport-manager"><a class="header" href="#612-transport-manager"><strong>6.1.2 Transport Manager</strong></a></h3>
<ul>
<li>
<p>管理transports的生命周期通过transport’s 引用计数器 and 空闲时间</p>
</li>
<li>
<p>Manages transport factories.</p>
</li>
<li>
<p>接受来自transport的包，解析包，把sip消息分发给endpoint</p>
</li>
<li>
<p>找到匹配的transport发送SIP message给特定的目的地，通过transport type and remote address.</p>
<p>Transport manager is normally not visible to applications; applications should use the functions provided by</p>
<p>endpoint.</p>
</li>
</ul>
<h3 id="613-transport-factory"><a class="header" href="#613-transport-factory"><strong>6.1.3 Transport Factory</strong></a></h3>
<p>传输工厂(pjsip_tpfactory)用于创建到remote endpoint的动态连接。示例：TCP传输，其中需要为每个目的地创建一个TCP传输。当transport manager检测到它需要创建到新目的地的新transport时，它会找到具有匹配规范(即传输类型)的transport factory，并要求factory创建连接。</p>
<h3 id="614-transport"><a class="header" href="#614-transport"><strong>6.1.4 Transport</strong></a></h3>
<ul>
<li>
<p>对应数据结构 <strong>pjsip_transport</strong></p>
<pre><code class="language-c">/**
 * This structure represent the "public" interface of a SIP transport.
 * Applications normally extend this structure to include transport
 * specific members.
 */
struct pjsip_transport
{
    char                    obj_name[PJ_MAX_OBJ_NAME];  /**&lt; Name. */

    pj_pool_t              *pool;           /**&lt; Pool used by transport.    */
    pj_atomic_t            *ref_cnt;        /**&lt; Reference counter.         */
    pj_lock_t              *lock;           /**&lt; Lock object.               */
    pj_grp_lock_t          *grp_lock;       /**&lt; Group lock for sync with
                                                 ioqueue and timer.         */
    pj_bool_t               tracing;        /**&lt; Tracing enabled?           */
    pj_bool_t               is_shutdown;    /**&lt; Being shutdown?            */
    pj_bool_t               is_destroying;  /**&lt; Destroy in progress?       */

    /** Key for indexing this transport in hash table. */
    pjsip_transport_key     key;

    char                   *type_name;      /**&lt; Type name.                 */
    unsigned                flag;           /**&lt; #pjsip_transport_flags_e   */
    char                   *info;           /**&lt; Transport info/description.*/

    int                     addr_len;       /**&lt; Length of addresses.       */
    pj_sockaddr             local_addr;     /**&lt; Bound address.             */
    pjsip_host_port         local_name;     /**&lt; Published name (eg. STUN). */
    pjsip_host_port         remote_name;    /**&lt; Remote address name.       */
    pjsip_transport_dir     dir;            /**&lt; Connection direction.      */
    
    pjsip_endpoint         *endpt;          /**&lt; Endpoint instance.         */
    pjsip_tpmgr            *tpmgr;          /**&lt; Transport manager.         */
    pjsip_tpfactory        *factory;        /**&lt; Factory instance. Note: it
                                                 may be invalid/shutdown.   */
    pj_timer_entry          idle_timer;     /**&lt; Timer when ref cnt is zero.*/

    pj_timestamp            last_recv_ts;   /**&lt; Last time receiving data.  */
    pj_size_t               last_recv_len;  /**&lt; Last received data length. */

    void                   *data;           /**&lt; Internal transport data.   */
    unsigned                initial_timeout;/**&lt; Initial timeout interval
                                                 to be applied to incoming
                                                 TCP/TLS transports when no
                                                 valid data received after
                                                 a successful connection.   */

    /**
     * Function to be called by transport manager to send SIP message.
     *
     * @param transport     The transport to send the message.
     * @param packet        The buffer to send.
     * @param length        The length of the buffer to send.
     * @param op_key        Completion token, which will be supplied to
     *                      caller when pending send operation completes.
     * @param rem_addr      The remote destination address.
     * @param addr_len      Size of remote address.
     * @param callback      If supplied, the callback will be called
     *                      once a pending transmission has completed. If
     *                      the function completes immediately (i.e. return
     *                      code is not PJ_EPENDING), the callback will not
     *                      be called.
     *
     * @return              Should return PJ_SUCCESS only if data has been
     *                      succesfully queued to operating system for 
     *                      transmission. Otherwise it may return PJ_EPENDING
     *                      if the underlying transport can not send the
     *                      data immediately and will send it later, which in
     *                      this case caller doesn't have to do anything 
     *                      except wait the calback to be called, if it 
     *                      supplies one.
     *                      Other return values indicate the error code.
     */
    pj_status_t (*send_msg)(pjsip_transport *transport, 
                            pjsip_tx_data *tdata,
                            const pj_sockaddr_t *rem_addr,
                            int addr_len,
                            void *token,
                            pjsip_transport_callback callback);

    /**
     * Instruct the transport to initiate graceful shutdown procedure.
     * After all objects release their reference to this transport,
     * the transport will be deleted.
     *
     * Note that application MUST use #pjsip_transport_shutdown() instead.
     *
     * @param transport     The transport.
     *
     * @return              PJ_SUCCESS on success.
     */
    pj_status_t (*do_shutdown)(pjsip_transport *transport);

    /**
     * Forcefully destroy this transport regardless whether there are
     * objects that currently use this transport. This function should only
     * be called by transport manager or other internal objects (such as the
     * transport itself) who know what they're doing. Application should use
     * #pjsip_transport_shutdown() instead.
     *
     * @param transport     The transport.
     *
     * @return              PJ_SUCCESS on success.
     */
    pj_status_t (*destroy)(pjsip_transport *transport);

    /*
     * Application may extend this structure..
     */
};

</code></pre>
</li>
<li>
<p>每一个实例代表一个socket handle</p>
</li>
<li>
<p>对于接收，每个transport对象必须必须自己从网络上接受packet，并且发送其给<em>transport manager</em> ，他自己本身不能提供poll操作。比较好的办法是将 transport’s socket handle注册到 endpoint’s I/O queue (<strong>pj_ioqueue_t</strong>)。当endpoint poll I/O queue 时从网上来的包就会被，transport接收。接受后，必须调用<strong>pjsip_tpmgr_receive_packet()</strong>，解析并传递该信息 。 The transport object must initialize both <strong>tp_info</strong> and <strong>pkt_info</strong> member of receive data buffer (<strong>pjsip_rx_data</strong>).</p>
</li>
<li>
<p>对于发送，每个传输对象都有一个指向将消息发送到网络的函数的指针(即传输对象的send_msg()属性)。应用程序(或堆栈)通过调用pjsip_transport_send()函数将消息发送到网络，该函数最终将到达传输对象，并且将调用send_msg()。数据包的发送可以异步完成;如果是这样，传输必须在send_msg()中返回PJ_EPENDING状态，并在消息发送到目的地时调用参数中指定的回调。</p>
</li>
<li>
<p>对于transport的管理，通过pjsip_transport_register()将transport注册到transport manager，在此之前transport 实例必须完成初始化。传输的生命周期由transport manager自动管理。每次transport的参考计数器达到零时，将启动一个空闲计时器。当空闲计时器到期且引用计数器仍然为零时，transport manager将通过调用pjsip_transport_unregister()来销毁传输。此函数将传输从transport manager的哈希表中注销，并最终销毁传输。</p>
</li>
<li>
<p>对于错误处理：由transport user处理</p>
</li>
</ul>
<h3 id="62-using-transports"><a class="header" href="#62-using-transports"><strong>6.2 Using Transports</strong></a></h3>
<h3 id="621-function-reference"><a class="header" href="#621-function-reference"><strong>6.2.1 Function Reference</strong></a></h3>
<pre><code class="language-c">PJ_DEF(pj_status_t) pjsip_endpt_acquire_transport(pjsip_endpoint *endpt,
                                                  pjsip_transport_type_e type,
                                                  const pj_sockaddr_t *remote,
                                                  int addr_len,
                                                  const pjsip_tpselector *sel,
                                                  pjsip_transport **transport)
</code></pre>
<p>获取类型为t_type的transport，用于发送消息到目的地remote_addr。请注意，如果成功获取transport，则transport的引用计数器将增加。通过endpoint 中的transport manager找transport</p>
<pre><code class="language-c">/**
 * Add reference counter to the specified transport. Any objects that wishes
 * to keep the reference of the transport MUST increment the transport's
 * reference counter to prevent it from being destroyed.
 *
 * @param tp            The transport instance.
 *
 * @return              PJ_SUCCESS on success or the appropriate error code.
 */
PJ_DECL(pj_status_t) pjsip_transport_add_ref( pjsip_transport *tp );

/**
 * Decrement reference counter of the specified transport. When an object no
 * longer want to keep the reference to the transport, it must decrement the
 * reference counter. When the reference counter of the transport reaches 
 * zero, the transport manager will start the idle timer to destroy the
 * transport if no objects acquire the reference counter during the idle
 * interval.
 *
 * @param tp            The transport instance.
 *
 * @return              PJ_SUCCESS on success.
 */
PJ_DECL(pj_status_t) pjsip_transport_dec_ref( pjsip_transport *tp );
</code></pre>
<pre><code class="language-c">/**
 * This is a low-level function to send a SIP message using the specified
 * transport to the specified destination.
 * 
 * @param tr        The SIP transport to be used.
 * @param tdata     Transmit data buffer containing SIP message.
 * @param addr      Destination address.
 * @param addr_len  Length of destination address.
 * @param token     Arbitrary token to be returned back to callback.
 * @param cb        Optional callback to be called to notify caller about
 *                  the completion status of the pending send operation.
 *
 * @return          If the message has been sent successfully, this function
 *                  will return PJ_SUCCESS and the callback will not be 
 *                  called. If message cannot be sent immediately, this
 *                  function will return PJ_EPENDING, and application will
 *                  be notified later about the completion via the callback.
 *                  Any statuses other than PJ_SUCCESS or PJ_EPENDING
 *                  indicates immediate failure, and in this case the 
 *                  callback will not be called.
 */
PJ_DECL(pj_status_t) pjsip_transport_send( pjsip_transport *tr, 
                                           pjsip_tx_data *tdata,
                                           const pj_sockaddr_t *addr,
                                           int addr_len,
                                           void *token,
                                           pjsip_tp_send_callback cb);
</code></pre>
<p>使用transport将tdata中的消息发送到remote_addr。如果函数立即完成并且数据已经发送，则函数返回PJ_SUCCESS。如果函数立即以错误结束，则返回一个非零错误码。在这两种情况下，回调都不会被调用。如果函数不能立即完成(例如，当底层套接字缓冲区已满时)，该函数将返回PJ_EPENDING，并通过回调cb通知调用方完成。如果挂起的发送操作以错误完成，则在回调的bytes_sent参数中，错误代码将以错误代码的负值表示(要获取错误代码，使用“pj_status_t status = -bytes_sent”)。这个函数按原样发送消息;它不会对消息执行任何验证。Via头也不会被这个函数修改。</p>
<h3 id="63-extending-transports"><a class="header" href="#63-extending-transports"><strong>6.3 Extending Transports</strong></a></h3>
<h3 id="64-initializing-transports"><a class="header" href="#64-initializing-transports"><strong>6.4 Initializing Transports</strong></a></h3>
<p>PJSIP doesn’t start any transports by default.  it is the responsibility of the application to initialize and start any transports that it wishes to use.</p>
<h3 id="641-udp-transport-initialization"><a class="header" href="#641-udp-transport-initialization"><strong>6.4.1 UDP Transport Initialization</strong></a></h3>
<pre><code class="language-c">/**
 * Start UDP transport.
 *
 * @param endpt         The SIP endpoint.
 * @param local         Optional local address to bind. If this argument
 *                      is NULL, the UDP transport will be bound to arbitrary
 *                      UDP port.
 * @param a_name        Published address (only the host and port portion is 
 *                      used). If this argument is NULL, then the bound address
 *                      will be used as the published address.
 * @param async_cnt     Number of simultaneous async operations.
 * @param p_transport   Pointer to receive the transport.
 *
 * @return              PJ_SUCCESS when the transport has been successfully
 *                      started and registered to transport manager, or
 *                      the appropriate error code.
 */
PJ_DECL(pj_status_t) pjsip_udp_transport_start(pjsip_endpoint *endpt,
                                               const pj_sockaddr_in *local,
                                               const pjsip_host_port *a_name,
                                               unsigned async_cnt,
                                               pjsip_transport **p_transport);
</code></pre>
<p>创建、初始化、注册和启动一个新的UDP传输。UDP套接字将绑定到local_addr。如果端点位于防火墙/NAT或其他端口转发设备之后，则可以使用pub_addr作为此传输的广告地址;否则，pub_addr应该与local_addr相同。参数async_cnt指定此传输允许多少个同时操作，以及最大值性能，该值应该等于节点中的处理器数量。</p>
<p>如果传输成功启动，该函数返回PJ_SUCCESS，如果应用程序想要立即使用传输，则在p_transport参数中返回传输。申请不需要向运输经理登记运输;当函数成功返回时，此函数已经完成了该操作。当出现错误时，该函数返回一个非零错误代码。</p>
<pre><code class="language-c">/**
 * Attach IPv4 UDP socket as a new transport and start the transport.
 *
 * @param endpt         The SIP endpoint.
 * @param sock          UDP socket to use.
 * @param a_name        Published address (only the host and port portion is 
 *                      used).
 * @param async_cnt     Number of simultaneous async operations.
 * @param p_transport   Pointer to receive the transport.
 *
 * @return              PJ_SUCCESS when the transport has been successfully
 *                      started and registered to transport manager, or
 *                      the appropriate error code.
 */
PJ_DECL(pj_status_t) pjsip_udp_transport_attach(pjsip_endpoint *endpt,
                                                pj_sock_t sock,
                                                const pjsip_host_port *a_name,
                                                unsigned async_cnt,
                                                pjsip_transport **p_transport);
</code></pre>
<p>UDP socket is already available</p>
<h2 id="chapter-7sending-messages"><a class="header" href="#chapter-7sending-messages"><strong>Chapter 7:Sending Messages</strong></a></h2>
<p>有状态发送和无状态发送：无状态是指协议对于事务处理没有记忆能力.缺少状态意味着如果后续处理需要前面的信息,则它必须重传,这样可能导致每次连接传送的数据量增大.另一方面,在服务器不需要先前信息时它的应答就较快.</p>
<h3 id="71-sending-messages-overview"><a class="header" href="#71-sending-messages-overview"><strong>7.1 Sending Messages Overview</strong></a></h3>
<p>Receiving incoming message is handled in <strong>on_rx_request()</strong> and <strong>on_rx_response()</strong> callback of each module</p>
<p>This chapter will describe about the basic way to send outgoing messages本章介绍发送outgoing messages</p>
<h3 id="711-creating-messages"><a class="header" href="#711-creating-messages"><strong>7.1.1 Creating Messages</strong></a></h3>
<p>response messages：<code>pjsip_endpt_create_response()</code></p>
<p>request messages: <code>pjsip_endpt_create_request(),pjsip_endpt_create_request_from_hdr(), pjsip_endpt_create_ack(), orpjsip_endpt_create_cancel()</code></p>
<p>proxies 利用incoming messages创建 request or response messages：<code>pjsip_endpt_create_request_fwd()，pjsip_endpt_create_response_fwd()</code></p>
<p>手动创建 request or response messages：使用pjsip_endpt_create_tdata()创建传输缓冲区，使用pjsip_msg_create()创建消息，使用pjsip_msg_add_hdr()或pjsip_msg_insert_first_hdr()向消息添加报头字段，设置消息主体等。</p>
<h3 id="712-sending-messages"><a class="header" href="#712-sending-messages"><strong>7.1.2 Sending Messages</strong></a></h3>
<p>basic way：**pjsip_endpt_acquire_transport()**and **pjsip_transport_send()**需要知道目的地址，太底层</p>
<p><strong>pjsip_endpt_send_request_stateless()</strong>：</p>
<ul>
<li>根据Request-URI和Route headers中的参数确定要联系的目的地;</li>
<li>使用RFC 3263(定位SIP服务器)中的程序解析目标服务器;</li>
<li>选择并建立用于连接服务器的transport;</li>
<li>修改发送通过在Via头反映当前正在使用的transport;</li>
<li>使用当前transport发送消息;</li>
<li>故障转移到下一个服务器/transport，如果服务器不能使用当前transport</li>
</ul>
<p><strong>pjsip_endpt_send_response()</strong></p>
<ul>
<li>Follow the procedures in Section 18.2.2 of RFC 3261 to select which transport to use and which address to send response to,</li>
<li>Additionally conform to RFC 3581 about rport parameter,</li>
<li>Send the response using the selected transport,</li>
<li>Fail-over to next address when response failed to be sent using the selected transport, resolving the server according to RFC 3263 when necessary.</li>
</ul>
<h3 id="72-function-reference"><a class="header" href="#72-function-reference"><strong>7.2 Function Reference</strong></a></h3>
<h3 id="721-sending-response"><a class="header" href="#721-sending-response"><strong>7.2.1 Sending Response</strong></a></h3>
<p><strong>pjsip_endpt_create_response</strong>：根据状态码和状态信息和接受到的rdata，创建response message</p>
<p><strong>pjsip_get_response_addr</strong>：根据rdata确定send 地址</p>
<p><strong>pjsip_endpt_send_response</strong>： send response 无状态，需要目的地址</p>
<p>pjsip_endpt_respond_stateless 创建发送response一体</p>
<h3 id="722-sending-request"><a class="header" href="#722-sending-request">7.2.2 Sending Request</a></h3>
<p>pjsip_endpt_create_tdata ：Create a new, blank transmit data.</p>
<p>pjsip_endpt_create_request ：创建request，Create a new request message of the specified <em>method</em> for the specified target URI, <em>from</em>, <em>to</em>, and <em>contact</em>. The <em>call_id</em> and <em>cseq</em> are optional. If <em>text</em> is specified, then a “text/plain” body is added. The request message has initial reference counter set to 1, and is then returned to sender in <em>p_tdata</em>.</p>
<p>pjsip_endpt_create_request_from_hdr：创建新的 request header by shallow-cloning the headers from the specified arguments.</p>
<p>pjsip_endpt_create_ack：创建ACK request 通过在tdata里的原有 request in <em>tdata</em></p>
<p>pjsip_endpt_create_cancel</p>
<p>pjsip_endpt_send_request_stateless：Send request in <em>tdata</em> statelessly.</p>
<h3 id="723-stateless-proxy-forwarding"><a class="header" href="#723-stateless-proxy-forwarding"><strong>7.2.3 Stateless Proxy Forwarding</strong></a></h3>
<p><strong>pjsip_endpt_create_request_fwd</strong></p>
<p><strong>pjsip_endpt_create_response_fwd</strong></p>
<p><strong>pjsip_calculate_branch_id</strong></p>
<h2 id="chapter-8transactions"><a class="header" href="#chapter-8transactions"><strong>Chapter 8:Transactions</strong></a></h2>
<h3 id="81-design"><a class="header" href="#81-design"><strong>8.1 Design</strong></a></h3>
<h3 id="811-introduction"><a class="header" href="#811-introduction"><strong>8.1.1 Introduction</strong></a></h3>
<ul>
<li>通过pjsip_tsx_endpt_create_uac()** / <strong>pjsip_tsx_create_uas()</strong>.创建Transaction</li>
<li>初始化 UAS transaction后, application 调用 **pjsip_tsx_recv_msg()**接收初始request message，transaction state从NULL 变成 TRYING，transaction接收重发送信息</li>
<li>Subsequent request retransmissions will be absorbed by the transaction.</li>
<li>当 application 想通过transaction发送request or response 可以调用 <strong>pjsip_tsx_send_msg()</strong>.</li>
<li>Transaction state 自动转化当messages传递进来, transaction user 通过 <strong>on_tsx_state()</strong> 回调函数，获得通知</li>
<li>Transaction 自动销毁当状态达到 PJSIP_TSX_STATE_TERMINATED. Application可以调用<strong>pjsip_tsx_terminate()</strong>.主动销毁</li>
</ul>
<h3 id="812-timers-and-retransmissions"><a class="header" href="#812-timers-and-retransmissions"><strong>8.1.2 Timers and Retransmissions</strong></a></h3>
<p>有两种类型的timer，retransmission timer and timeout timer 这两种定时器的值由事务根据事务类型(UAS或UAC)、transport方式(可靠或不可靠)和方法(INVITE或非INVITE)自动设置。应用程序只能在全局基础上更改计时器的间隔值(甚至可能只在编译期间)。transaction处理 incoming and outgoing retransmissions。 Incoming retransmissions 被静默地吸收并被事务忽略;没有关于事务发出的传入重传的通知。如有需要，外发讯息会由交易自动重传;同样，事务在传出重传时也不会发出通知。</p>
<h3 id="813-invite-final-response-and-ack-request"><a class="header" href="#813-invite-final-response-and-ack-request"><strong>8.1.3 INVITE Final Response and ACK Request</strong></a></h3>
<h4 id="failed-invite-request"><a class="header" href="#failed-invite-request">Failed INVITE Request</a></h4>
<p>Client transaction：当客户端INVITE transaction收到300-699对INVITE的最终响应时，它将自动发出对该响应的ACK请求。然后，事务在终止之前等待定时器D间隔，在此期间，任何传入的300-699响应重传将自动以ACK请求应答</p>
<p>Server transaction：当服务器INVITE事务被要求发送300-699最终响应时，它将发送该响应并保持重发该响应，直到接收到ACK请求或定时器H间隔已经过去。在此间隔期间，当收到ACK请求时，transaction将进入Confirmed状态，并在计时器I间隔结束后销毁。当定时器H超时而没有收到有效的ACK请求时，事务将被销毁。</p>
<h4 id="successfull-invite-request"><a class="header" href="#successfull-invite-request">Successfull INVITE Request</a></h4>
<p>Client transaction：当客户端INVITE事务收到2xx对INVITE的最终响应时，它将在将响应传递给其事务用户（can be a dialog or application）后自动销毁自己。随后传入的2xx响应重传将直接传递到dialog or application。在任何情况下，应用程序必须在收到2xx对INVITE的最终响应后手动发送ACK请求。（传递销毁，手动ack）</p>
<p>Server transaction：当服务器INVITE事务被要求发送2xx最终响应时，它将发送该响应并保持重传该响应，直到收到ACK或事务被应用程序用pjsip_tsx_terminate（）终止。（保持直到）为了简化实现，典型的UASdialog通常会让事务处理2xx INVITE响应的重传。但是代理应用程序必须在收到并发送2xx响应后立即销毁UAS事务，以便端到端用户代理处理2xx重传。</p>
<h3 id="814-incoming-ack-request"><a class="header" href="#814-incoming-ack-request"><strong>8.1.4 Incoming ACK Request</strong></a></h3>
<p>不成功transaction吸收ack用户收不到，成功transaction通知用户第一个ack</p>
<p>当服务器INVITE transaction以不成功的最终响应完成时，ACK请求将被transaction吸收;transaction用户将不会被通知传入的ACK请求。当服务器INVITE事务以2xx最终响应完成时，第一个ACK请求将被通知给事务用户。随后收到的ACK重发将不会通知交易用户。</p>
<h3 id="815-server-resolution-and-transports"><a class="header" href="#815-server-resolution-and-transports"><strong>8.1.5 Server Resolution and Transports</strong></a></h3>
<p>Transaction使用核心API pjsip_endpt_send_request_stateless（）和pjsip_endpt_send_response（）发送传出消息。这些函数提供服务器解析和传输建立以发送消息，并在检测到故障时故障转移到备用传输。事务使用这些函数提供的回调来监视传输的进度并跟踪正在使用的传输。</p>
<h3 id="816-via-header"><a class="header" href="#816-via-header"><strong>8.1.6 Via Header</strong></a></h3>
<p>Branch Parameter：UAC事务在Via标头中不存在唯一的分支参数时自动生成该参数。如果分支参数已经存在，则事务将使用它作为其键，遵守RFC 3261和RFC 2543设置的规则。</p>
<p>Via Sent-By：Via Sent-By始终由pjsip_endpt_send_request_stateless（）和pjsip_endpt_send_response（）放置。</p>
<h3 id="82-reference"><a class="header" href="#82-reference"><strong>8.2 Reference</strong></a></h3>
<p>pjsip_tsx_layer_init_module初始化事务层模块并将其注册到指定endpoint</p>
<p><strong>pjsip_tsx_layer_instance</strong> Get the instance of transaction layer module.</p>
<p><strong>pjsip_tsx_layer_destroy</strong> 销毁并且unregister endpoint</p>
<p><strong>pjsip_tsx_create_uas</strong> 为传入的incoming request rdata 创建一个新的UAS transaction，事务用户设置为tsx_user事务被自动初始化并注册到endpoint的事务表。</p>
<p><strong>pjsip_tsx_create_uac</strong> 为传出的outgoing request tdata 创建一个新的UAC transaction，事务用户设置为tsx_user。事务将自动初始化并注册到事务表。请注意，在调用此函数之后，应用程序通常会调用pjsip_tsx_send_msg（）来实际发送请求。</p>
<p><strong>pjsip_tsx_recv_msg</strong> 应用程序必须在UAS事务创建后调用此函数，传递初始请求消息，以便事务状态可以从NULL移动到TRYING。调用事务用户的on_tsx_state（）。</p>
<p><strong>pjsip_tsx_send_msg</strong>  通过transaction发送消息。如果tdata为NULL，则将重传最后一条消息或在创建过程中指定的消息。当函数返回PJ_SUCCESS时，tdata引用计数器将递减。</p>
<p>pjsip_tsx_create_key</p>
<p>pjsip_tsx_layer_find_tsx</p>
<p><strong>pjsip_tsx_terminate</strong> 强制终止具有指定状态代码st_code的事务tsx。通常应用程序不需要调用此函数，因为事务将根据其状态机终止并销毁自己。例如，当发送/接收到对INVITE的200/OK响应并且UA层想要手动处理200/OK响应的重传时，使用该功能。事务将发出事务状态更改事件（状态更改为PJSIP_TSX_STATE_STATED），然后它将被注销并立即被此函数销毁。</p>
<p><strong>pjsip_rdata_get_tsx</strong> 获取传入消息中的transaction对象。</p>
<p><strong>pjsip_endpt_respond</strong> 有状态 Send 集合体respond by creating a new UAS transaction for the incoming request.</p>
<p><strong>pjsip_endpt_send_request</strong> Send the request by using an UAC transaction, and optionally request callback to be called when the transaction completes.</p>
<h3 id="83-sending-statefull-responses"><a class="header" href="#83-sending-statefull-responses"><strong>8.3 Sending Statefull Responses</strong></a></h3>
<p>区别7.3的stateless</p>
<p>在 <strong>on_rx_request</strong>中，表示先接受再发送。先创建uas （pjsip_tsx_create_uas），接受初始信息（pjsip_tsx_recv_msg），send（pjsip_tsx_send_msg）或者 直接pjsip_endpt_respond</p>
<h3 id="84-sending-statefull-request"><a class="header" href="#84-sending-statefull-request"><strong>8.4 Sending Statefull Request</strong></a></h3>
<p>创建request（ pjsip_endpt_create_request） 创建uac（pjsip_tsx_create_uac），send（pjsip_tsx_send_msg）或者直接pjsip_endpt_send_request()</p>
<h2 id="chapter-10basic-user-agent-layer-ua"><a class="header" href="#chapter-10basic-user-agent-layer-ua">Chapter 10:Basic User Agent Layer (UA)</a></h2>
<h3 id="101-basic-dialog-concept"><a class="header" href="#101-basic-dialog-concept">10.1 Basic Dialog Concept</a></h3>
<p>Basic UA Dialog 提供用于管理SIP Dialog和dialog usages的基本设施，诸如基本dialog状态、会话计数器、呼叫ID、From、To和Contact报头、事务中的CSeq的排序以及路由集。</p>
<p>dialog PJSIPdialog不知道其session的状态。它不知道INVITE session是已建立还是已断开。事实上，dialog甚至不知道dialog中有什么类型的session。它只关心dialog中有多少活动session。dialog从一个活动session开始，当session计数器达到零并且最后一个transaction终止时，dialog将被销毁。可以在单个dialog中同时建立多个和不同类型的session。</p>
<h3 id="1011-dialog-sessions"><a class="header" href="#1011-dialog-sessions">10.1.1 Dialog Sessions</a></h3>
<p>PJSIP Dialog框架中的Dialog session仅用引用计数器表示。每当dialog使用模块在该特定dialog中创建/销毁session时，该引用计数器都会递增和递减。</p>
<p>Dialog’s sessions 被dialog usages 创建</p>
<h3 id="1012-dialog-usages"><a class="header" href="#1012-dialog-usages">10.1.2 Dialog Usages</a></h3>
<p>Dialog Usages是PJSIP modules注册在dialog，以接受dialog 事件。多个modules可以注册到一个dialog，因此dialog可以有多种用途。每个dialog Usage module负责处理特定的session。例如，subscribe usage module将在每次接收到新的SUBSCRIBE请求时创建新的subscribe session（增量dialog session计数器）</p>
<p>Dialog处理Dialog Usages和endpoint类似，在每个on_req_request（）和on_req_response（）事件上，dialog将事件传递给从较高优先级模块开始的每个Dialog Usage（即优先级较低的模块），直到其中一个模块返回true（即，非零），在这种情况下，dialog将停止事件的分发。on_tsx_state（）通知将分发给所有dialog使用。每个dialog的使用都应该过滤掉不属于它的事务事件。</p>
<p>在其最基本的（即低级）使用中，应用程序直接管理dialog，并且它是dialog唯一“使用”（或用户）。在这种情况下，应用程序负责管理dialog中的session，这意味着处理所有请求和响应，并手动建立/拆除session。</p>
<h3 id="1013-dialog-set"><a class="header" href="#1013-dialog-set">10.1.3 Dialog Set</a></h3>
<p>每个Dialog都是一个Dialog集的成员。Dialog集common local tag（即From标签）标识。通常，一个Dialog集只有一个Dialog作为成员。只有当发出INVITE分叉时，dialog集才会包含多个dialog，在这种情况下，接收到的每个带有不同To标记的响应消息将在同一dialog集中创建一个新dialog。在PJSIP中，dialog集被定义为不透明类型（即void*）。dialog结构（pjsip_dialog）有一个名为dlg_set的成员，用于标识它所属的dialog集。应用程序可以使用链接列表API来检索dialog的同级dialog（在同一dialog集中）。</p>
<h3 id="1014-client-authentication"><a class="header" href="#1014-client-authentication">10.1.4 Client Authentication</a></h3>
<p>dialog维护一个客户端身份验证会话（pjsip_auth_clt_sess），用于验证dialog中所有下游服务器的请求。基本dialog使用适当的身份验证头（如果可用）验证每个传出请求。然而，认证挑战必须由dialog使用来处理;例如，基本dialog不会在401/407响应失败时自动重试请求。</p>
<h3 id="1015-class-diagram"><a class="header" href="#1015-class-diagram">10.1.5 Class Diagram</a></h3>
<p><img src="img/UA.png" alt="img" /></p>
<p>该图显示了dialog和它的使用之间的关系。在最基本/低级的场景中，应用程序模块是dialog的唯一用途。在更高级的场景中，一些高级模块（例如pjsip_invite_usage和pjsip_subscribe_usage）可以注册到dialog作为dialog usages，并且应用程序将从这些usages而不是直接从dialog接收事件。</p>
<p>该图还显示了PJSIP user_agent模块（pjsip_user_agent）。user_agent模块是所有dialog的“所有者”;user_agent模块维护当前活动的所有session集的哈希表。</p>
<h3 id="1016-forking"><a class="header" href="#1016-forking">10.1.6 Forking</a></h3>
<p>先不看了</p>
<h3 id="1017-cseq-sequencing"><a class="header" href="#1017-cseq-sequencing">10.1.7 CSeq Sequencing</a></h3>
<p>Dialog的本地cseq在发送请求时更新（与创建请求时相反）。当CSeq报头存在于请求中时，该值可以随着在dialog内发送请求而被更新。</p>
<p>当收到请求时，dialog的远程cseq将被更新。当dialog的远程cseq为空时，收到的第一个请求将设置dialog的远程cseq。对于后续的请求，当dialog接收到cseq低于dialog记录的cseq的请求时，此请求将由dialog自动无状态地回答，并返回500响应（内部服务器错误）。当请求的cseq大于dialog记录的cseq时，dialog将自动更新远程的cseq（包括当请求的cseq大于1时）。</p>
<h3 id="1018-transactions"><a class="header" href="#1018-transactions">10.1.8 Transactions</a></h3>
<p>Dialog 总是有状态地运行。当传入请求到达时，它自动创建UAS transaction，当请求发送传出请求时，它创建UAC transaction。dialog无状态操作的唯一时间是当它接收到CSeq低于当前CSeq的传入请求时，在这种情况下，它将使用500（内部服务器错误）响应来回答请求。</p>
<p>当transaction代表dialog时（通过dialogAPI，对于UAS和UAC事务），transaction的transaction user（TU）被设置为user agent实例，并且dialog实例将被放置transaction的mod_data中以适当的index形式。index是user agent的模块ID。当事件或消息到达时，transaction将事件报告给user agent模块，user agent模块将查找dialog并将事件传递给dialog。</p>
<h3 id="102-basic-ua-api-reference"><a class="header" href="#102-basic-ua-api-reference">10.2 Basic UA API Reference</a></h3>
<h3 id="1021-user-agent-module-api"><a class="header" href="#1021-user-agent-module-api">10.2.1 User Agent Module API</a></h3>
<p><code>typedef pjsip_module pjsip_user_agent;</code>User agent type.</p>
<p>pjsip_ua_init_module、pjsip_ua_instance ： Get the instance of the user agent</p>
<p>pjsip_ua_destroy： Destroy the user agent module.</p>
<h3 id="1022-dialog-structure"><a class="header" href="#1022-dialog-structure">10.2.2 Dialog Structure</a></h3>
<pre><code class="language-c">/**
 * This structure is used to describe dialog's participants, which in this
 * case is local party (i.e. us) and remote party.
 */
typedef struct pjsip_dlg_party
{
    pjsip_fromto_hdr    *info;      /**&lt; From/To header, inc tag.       */
    pj_str_t             info_str;  /**&lt; String rep of info header.     */
    pj_uint32_t          tag_hval;  /**&lt; Hashed value of the tag.       */
    pjsip_contact_hdr   *contact;   /**&lt; Contact header.                */
    pj_int32_t           first_cseq;/**&lt; First CSeq seen.               */
    pj_int32_t           cseq;      /**&lt; Next sequence number.          */
} pjsip_dlg_party;
/**
 * This structure describes the dialog structure. Application MUST NOT
 * try to SET the values here directly, but instead it MUST use the
 * appropriate dialog API. The dialog declaration only needs to be made 
 * visible because other PJSIP modules need to see it (e.g. INVITE session,
 * the event framework, etc.).
 *
 * Application MAY READ the dialog contents directly after it acquires
 * dialog lock.
 *
 * To acquire dialog lock, use #pjsip_dlg_inc_lock(), and to release it,
 * use #pjsip_dlg_dec_lock(). DO NOT USE pj_mutex_lock()/pj_mutex_unlock()
 * on the dialog's mutex directly, because this will not protect against
 * dialog being destroyed.
 */
struct pjsip_dialog
{
    /** The dialog set list. */
    PJ_DECL_LIST_MEMBER(pjsip_dialog);

    /* Dialog's system properties. */
    char                obj_name[PJ_MAX_OBJ_NAME];  /**&lt; Standard id.       */
    pj_pool_t          *pool;       /**&lt; Dialog's pool.                     */
    pjsip_user_agent   *ua;         /**&lt; User agent instance.               */
    pjsip_endpoint     *endpt;      /**&lt; Endpoint instance.                 */
    pj_grp_lock_t      *grp_lock_;  /**&lt; Dialog's grp lock. Do not call!!
                                         Use pjsip_dlg_inc_lock() instead!  */

    /** The dialog set which this dialog belongs (opaque type). */
    void               *dlg_set;

    /* Dialog's session properties. */
    pjsip_dialog_state  state;      /**&lt; Dialog state.                      */
    pjsip_uri          *target;     /**&lt; Current target.                    */
    pjsip_target_set    target_set; /**&lt; Target set, for UAC only.          */
    pjsip_hdr           inv_hdr;    /**&lt; Headers from hparam in dest URL    */
    pjsip_dlg_party     local;      /**&lt; Local party info.                  */
    pjsip_dlg_party     remote;     /**&lt; Remote party info.                 */
    pjsip_hdr           rem_cap_hdr;/**&lt; List of remote capability header.  */
    pjsip_role_e        role;       /**&lt; Initial role.                      */
    pj_bool_t           uac_has_2xx;/**&lt; UAC has received 2xx response?     */
    pj_bool_t           secure;     /**&lt; Use secure transport?              */
    pj_bool_t           add_allow;  /**&lt; Add Allow header in requests?      */
    pj_bool_t           ack_sent;   /**&lt; ACK has been sent?                 */
    pjsip_cid_hdr      *call_id;    /**&lt; Call-ID header.                    */
    pjsip_route_hdr     route_set;  /**&lt; Route set.                         */
    pj_bool_t           route_set_frozen; /**&lt; Route set has been set.      */
    pjsip_auth_clt_sess auth_sess;  /**&lt; Client authentication session.     */
    pj_str_t            initial_dest;/**&lt; Initial destination host (used for
                                          verifying remote TLS cert).       */

    /** Session counter. */
    int                 sess_count; /**&lt; Number of sessions.                */

    /** Transaction counter. */
    int                 tsx_count;  /**&lt; Number of pending transactions.    */

    /** Transport selector. */
    pjsip_tpselector    tp_sel;

    /* Dialog usages. */
    unsigned            usage_cnt;  /**&lt; Number of registered usages.       */
    pjsip_module       *usage[PJSIP_MAX_MODULE]; /**&lt; Array of usages, 
                                         priority sorted                    */

    /** Module specific data. */
    void               *mod_data[PJSIP_MAX_MODULE]; /**&lt; Module data.       */

    /**
     * If via_addr is set, it will be used as the "sent-by" field of the
     * Via header for outgoing requests as long as the request uses via_tp
     * transport. Normally application should not use or access these fields.
     */
    pjsip_host_port     via_addr;   /**&lt; Via address.                       */
    const void         *via_tp;     /**&lt; Via transport.                     */
};
</code></pre>
<h3 id="1023-dialog-creation-api"><a class="header" href="#1023-dialog-creation-api">10.2.3 Dialog Creation API</a></h3>
<p>pjsip_dlg_create_uac： 创建一个新的dialog并返回p_dlg参数中的实例。创建dialog后，应用程序可以通过调用pjsip_dlg_add_usage（）将模块添加为dialog usages。</p>
<p>pjsip_dlg_create_uas：从传入请求（如INVITE、REFER或SUBSCRIBE）中找到的信息初始化UAS dialog，并将本地Contact设置为contact。如果未指定contact，则从请求的To标头中的URI初始化本地联系人。如果请求有To tag参数，dialog的本地tag将从该值初始化。否则，将调用全局唯一ID生成器来创建dialog的本地tag。</p>
<h3 id="1024-dialog-termination"><a class="header" href="#1024-dialog-termination">10.2.4 Dialog Termination</a></h3>
<p>一旦会话计数器达到零并且所有挂起的事务都已终止，dialog通常会自动销毁。</p>
<p>pjsip_dlg_terminate（）函数用于提前销毁dialog。此函数通常由dialog调用。应用程序应使用适当的更高级别会话API，如pjsip_inv_terminate（），它将销毁session和dialog。</p>
<p>销毁dialog并从UA模块的哈希表中取消注册。</p>
<h3 id="1025-dialog-session-management-api"><a class="header" href="#1025-dialog-session-management-api">10.2.5 Dialog Session Management API</a></h3>
<p>以下函数用于管理dialog的会话计数器。 pjsip_dlg_inc_session、pjsip_dlg_dec_session一旦会话计数器达到零并且没有挂起的事务，dialog将被销毁。请注意，如果调用此函数时没有挂起的事务，则此函数可能会立即销毁dialog。</p>
<h3 id="1026-dialog-usages-api"><a class="header" href="#1026-dialog-usages-api">10.2.6 Dialog Usages API</a></h3>
<p>manage dialog usages in a dialog</p>
<p>pjsip_dlg_add_usage：添加一个模块作为dialog usages，并可以选择设置模块特定的数据。</p>
<p>pjsip_dlg_set_mod_data：将模块特定数据附加到dialog</p>
<p>pjsip_dlg_get_mod_data：获取先前附加到dialog的模块特定数据。</p>
<h3 id="1027-dialog-request-and-response-api"><a class="header" href="#1027-dialog-request-and-response-api">10.2.7 Dialog Request and Response API</a></h3>
<p>pjsip_dlg_create_request：使用指定的方法创建一个基本/通用request，并可选地指定cseq。为cseq使用值-1，使dialog自动为请求放置下一个cseq编号。对于某些请求，例如CANCEL和ACK，应用程序必须将CSeq作为参数放入原始INVITE请求中。此函数还将在适当的位置放置Contact标题。</p>
<p>pjsip_dlg_send_request：发送请求消息到远程对等体。如果请求不是ACK请求，则dialog将创建UAC transaction并通过transaction将request 有状态地发送出去。此外，当请求不是ACK或CANCEL时，dialog将增加其本地cseq号，并根据dialog的cseq更新请求中的cseq。</p>
<p>pjsip_dlg_create_response：通过传入的rdata创建一条response消息，状态代码为st_code，可选状态文本为st_text。此函数与endpoint 的API pjsip_endpt_create_response（）的不同之处在于，dialog函数在响应中适当地添加Contact标头和Record-Route标头。</p>
<p>pjsip_dlg_modify_response(：用其他状态代码修改以前发送的响应。将在适当时添加Contact header。</p>
<p>pjsip_dlg_send_response：有状态地发送响应消息。transaction实例必须是在on_req_request（）回调中报告的transaction。</p>
<h3 id="1028-dialog-auxiliary-api"><a class="header" href="#1028-dialog-auxiliary-api">10.2.8 Dialog Auxiliary API</a></h3>
<p>pjsip_dlg_set_route_set：</p>
<p>pjsip_dlg_start_app_timer</p>
<p>pjsip_dlg_stop_app_timer</p>
<p>pjsip_rdata_get_dlg：获取传入rdata中的dialog实例</p>
<p>pjsip_tsx_get_dlg：获取指定事务中的dialog实例</p>
<h3 id="103-examples"><a class="header" href="#103-examples">10.3 Examples</a></h3>
<h3 id="1031-invite-uas-dialog"><a class="header" href="#1031-invite-uas-dialog">10.3.1 Invite UAS Dialog</a></h3>
<p>o create and initialize incoming dialog,
o create UAS transaction to process the incoming INVITE request and transmit 1xx responses,
o transmit 2xx response to INVITE reliably,
o process the incoming ACK.</p>
<h4 id="creating-initial-invite-dialog"><a class="header" href="#creating-initial-invite-dialog">Creating Initial Invite Dialog</a></h4>
<p>pjsip_dlg_create_uas初始化uas、pjsip_dlg_add_usage将应用程序注册为唯一的dialog usage、pjsip_dlg_inc_session、pjsip_dlg_create_response创建180/振铃响应、pjsip_dlg_send_response有状态发送180响应、200/OK在answer_dlg（）函数中，为此，我们必须“保存”INVITE事务。我们通过将事务实例放在dialog的模块数据中索引应用程序模块的ID来实现。</p>
<h4 id="answering-dialog"><a class="header" href="#answering-dialog">Answering Dialog</a></h4>
<p>pjsip_dlg_modify_response修改之前的响应、pjsip_dlg_send_response使用以前的transaction发送200响应</p>
<h4 id="processing-cancel-request"><a class="header" href="#processing-cancel-request">Processing CANCEL Request</a></h4>
<p>获取transaction、pjsip_dlg_respond、pjsip_dlg_modify_response 487 、pjsip_dlg_send_response、pjsip_dlg_dec_session</p>
<h4 id="processing-ack-request"><a class="header" href="#processing-ack-request">Processing ACK Request</a></h4>
<p>pjsip_rdata_get_dlg、pjsip_rdata_get_dlg</p>
<h3 id="1032-outgoing-invite-dialog"><a class="header" href="#1032-outgoing-invite-dialog">10.3.2 Outgoing Invite Dialog</a></h3>
<h4 id="creating-initial-dialog"><a class="header" href="#creating-initial-dialog">Creating Initial Dialog</a></h4>
<p>pjsip_dlg_create_uac、pjsip_dlg_add_usage、pjsip_dlg_inc_session、pjsip_dlg_create_request（创建invite request）、pjsip_dlg_send_request(发送)</p>
<h4 id="receiving-response"><a class="header" href="#receiving-response">Receiving Response</a></h4>
<p>pjsip_rdata_get_dlg、pjsip_rdata_get_tsx 获取rdata对应的transaction、根据transaction状态做不同的处理，send_ack/交给transaction处理</p>
<h4 id="sending-ack"><a class="header" href="#sending-ack">Sending ACK</a></h4>
<p>pjsip_dlg_create_request、pjsip_dlg_send_request</p>
<h3 id="1033-terminating-dialog"><a class="header" href="#1033-terminating-dialog">10.3.3 Terminating Dialog</a></h3>
<p>pjsip_dlg_create_request（Create BYE request）、pjsip_dlg_send_request （Send the request）、pjsip_dlg_dec_session</p>
<h2 id="chapter-11sdp-offeranswer-framework"><a class="header" href="#chapter-11sdp-offeranswer-framework">Chapter 11:SDP Offer/Answer Framework</a></h2>
<p>PJSIP中的SDP提供/应答框架是基于RFC 3264“具有会话描述符协议（SDP）的提供/应答模型”。该框架的主要功能是本地和远程方之间的媒体能力的协商，并就在一个invite session中使用哪组媒体达成一致。</p>
<p>请注意，尽管它主要由invite session使用，但框架本身基于通用SDP协商框架（pjmedia_sdp_neg），因此它应该能够由其他类型的应用程序使用。dialog邀请会话提供SDP提供/应答框架与SIP协议的集成;它正确地解释相关消息（例如，INVITE、ACK、PRACK、UPDATE）中的消息体，并将它们转换为SDP提供/应答协商。</p>
<h3 id="111-sdp-negotiator-structure"><a class="header" href="#111-sdp-negotiator-structure">11.1 SDP Negotiator Structure</a></h3>
<p><img src="img/sdp.png" alt="img" /></p>
<p>pjmedia_sdp_neg结构保留三个SDP结构</p>
<p>initial_sdp：这是本地endpoint的初始能力。此SDP在创建期间传递给negotiator，并且内容通常在整个会话期间不会更改（即使在协商之后）。当negotiator从远程接收到新的提议时（与从远程接收更新的SDP相反），negotiator在协商中使用该SDP。</p>
<p>active_local_sdp：包含与远程协商后的本地SDP。dialog必须使用这个启动它的本地媒体，而不是初始SDP。</p>
<p>active_remote_sdp：包含对等/远程当前使用的SDP。</p>
<h3 id="112-sdp-negotiator-session"><a class="header" href="#112-sdp-negotiator-session">11.2 SDP Negotiator Session</a></h3>
<p><img src="img/sdpState.png" alt="img" /></p>
<p>协商会话以PJMEDIA_SDP_NEG_STATE_NULL开始。如果dialog已准备好本地媒体描述并希望将媒体提供给远程（通常是dialog充当UAC时的情况），则它会通过将本地SDP传递给函数pjmedia_sdp_neg_create_w_local_offer（）来创建SDP negotiator。此函数将设置本地endpoint的初始能力，并将协商会话状态设置为PJMEDIA_SDP_NEG_STATE_PROGRAM_OFFER。然后，可以在传出INVITE请求中将初始SDP发送到远程方。一旦dialog 收到远程的SDP，UAS端，它必须调用pjmedia_sdp_neg_remote_answer（）并提供远程的SDP。然后可以调用协商函数。</p>
<p>如果dialog已经有了远程媒体描述（通常是当dialog充当UAS时的情况），它可以通过将本地和远程SDP传递给pjmedia_sdp_neg_create_w_remote_offer（）来创建SDP协商器会话。在此之后，可以调用协商函数。</p>
<p>在会话建立之后，本地方和远程方都可以修改会话。negotiator可以处理以下两种情况之一：</p>
<ul>
<li>Dialog已从远程接收SDP。在这种情况下，Dialog将调用pjmedia_sdp_neg_remote_offer（）并将远程的SDP传递给此函数。在此之后，可以调用协商函数。协商函数的返回值确定本地媒体中是否需要修改。</li>
<li>本地方希望将SDP发送到远程。dialog框可以进一步选择以下操作之一：
<ul>
<li>如果它只想发送当前活动的本地SDP而不修改，它应该调用pjmedia_sdp_neg_tx_local_offer（）来获取活动的本地SDP，发送SDP，然后等待远程的应答。</li>
<li>如果它想要修改当前活动的本地媒体（例如，改变流方向，改变活动编解码器等），它应该使用pjmedia_sdp_neg_get_local（）获取活动的本地媒体，修改它，调用pjmedia_sdp_neg_modify_local_offer（）以更新报价，发送本地SDP，然后等待远程的应答。</li>
<li>dialog框可能希望完全更改本地媒体（例如更改IP地址、更改编解码器集、添加新媒体线）。这与上述更新当前媒体不同，因为它将更改initial_sdp，以便将来的协商将基于此新SDP。如果dialog框想要这样做，它会使用新的本地SDP调用pjmedia_sdp_neg_reinit_local_offer（），发送SDP，然后等待远程的应答。</li>
</ul>
</li>
</ul>
<p>Dialog向远程方发送要约后，它应该收到来自远程方的应答。Dialog必须向negotiator提供远程的SDP，以便可以调用协商功能。该Dialog通过调用pjsip_sdp_neg_remote_answer（）提供远程应答。</p>
<p>如果远程拒绝了本地的提议（例如返回488/“此处不可接受”响应），dialog必须仍然调用pjsip_sdp_neg_remote_answer（），并在远程的SDP参数中提供NULL，并调用协商函数，以便negotiator会话可以恢复到先前活动的会话描述（如果有的话）。</p>
<h3 id="113-sdp-negotiation-function"><a class="header" href="#113-sdp-negotiation-function">11.3 SDP Negotiation Function</a></h3>
<p>在提供了用于协商的本地和远程SDP之后，对话调用pjmedia_sdp_neg_negotiate（）来协商提议和应答（即协商者状态为PJMEDIA_SDP_NEG_STATE_WAIT_NEGO）。此函数可能返回以下结果之一：</p>
<p>PJ_SUCCESS（即零），如果它已成功地在本地和远程SDP之间建立了协议。在这种情况下，本地和远程的活动SDP都将存储在会话中以供将来参考，应用程序可以查询这些活动SDP以启动本地媒体。</p>
<p>PJMEDIA_ESDPNOCHANGE，如果它发现当前使用的SDP（本地和远程）中不需要修改。在这种情况下，先前商定的SDP会话也不会被修改。</p>
<p>PJMEDIA_ESDPFAIL，如果它无法找到本地和远程功能的协议。在这种情况下，如果会话保留先前商定的SDP，则这些SDP（本地和远程）将不会被修改。如果dialog充当此会话的UAS，则它应该使用488/Not Accepted Here响应请求。</p>
<p>PJMEDIA_ESDPNOOFFER，如果negotiator尚未发送/接收任何offer</p>
<p>PJMEDIA_ESDPNOANSWER，如果negotiator尚未收到远程的应答。</p>
<p>在所有情况下，协商函数将negotiator’s状态设置为PJMEDIA_SDP_NEG_STATE_DONE。</p>
<h2 id="chapter-12dialog-invite-session-and-usage"><a class="header" href="#chapter-12dialog-invite-session-and-usage">Chapter 12:Dialog Invite Session and Usage</a></h2>
<p>high level 的API application可以使用去管理invite session，application完全对抽象的dialog进行管理</p>
<p>dialog invite session由dialog invite usage管理，具体流程是，dialog invite usage将dialog收到的事件分发给invite session</p>
<h3 id="1211-terms"><a class="header" href="#1211-terms">12.1.1 Terms</a></h3>
<p>Dialog invite session在dialog中</p>
<p>Dialog invite usage注册在dialog中</p>
<h3 id="1212-features"><a class="header" href="#1212-features">12.1.2 Features</a></h3>
<ul>
<li>Session progress reporting (e.g. session progressing, connected, confirmed, disconnected),</li>
<li>Automatic authentication handling (e.g. retry the request on receipt of 401/407 response),</li>
<li>SDP offer and answer handling,</li>
<li>High-level forking handler,</li>
<li>Session timeout (i.e. Expires header),</li>
<li>Session extensions, such as session timer, and reliable provisional response.</li>
</ul>
<h3 id="1213-invite-session-state"><a class="header" href="#1213-invite-session-state">12.1.3 Invite Session State</a></h3>
<p>dialog invite usage提供回调来通知应用程序有关会话进度。这对于电话应用程序特别有用，其中会话的状态通常与电话呼叫状态相关联。</p>
<img src="img/Invite_Session_State.png" alt="img" style="zoom:50%;" />
<img src="img/StateDescription.png" alt="img" style="zoom:50%;" />
<h3 id="1214-invite-session-creation"><a class="header" href="#1214-invite-session-creation">12.1.4 Invite Session Creation</a></h3>
<p>对于outgoing dialog (i.e. caller)，应用程序需要使用pjsip_dlg_create_uac（）创建UAC对话。然后，应用程序通过调用pjsip_inv_create_uac（）为对话创建invite session，并将UAC dialog实例作为参数之一传递。在invite session创建之前，应用程序不得发送INVITE请求，否则invite session将丢失某些事件。</p>
<p>对于 incoming dialog，应用程序可以首先通过调用pjsip_inv_verify_request（）来验证请求是否可以接受。此函数验证Supported、Require和request body，以确保它可以接受请求。如果请求不能被接受，它将创建相应的拒绝响应。如果可以接受请求，则应用程序通过调用pjsip_dlg_create_uas（）函数来创建UASdialog。然后，应用程序通过调用pjsip_inv_create_uas（）为该对话创建invite session，并将UAS dialog实例作为参数之一传递。在invite session创建之前，应用程序不得发送任何响应，否则邀请会话将丢失某些事件。</p>
<p>Invite Session创建函数（即pjsip_inv_create_uac（）和pjsip_inv_create_uas（）函数）自动将invite session usage注册到dialog。应用程序不需要调用pjsip_dlg_add_usage（）来将invite session usage注册到dialog。</p>
<h3 id="1215-messages-handling"><a class="header" href="#1215-messages-handling">12.1.5 Messages Handling</a></h3>
<p>invite session处理可能更改 invite session状态的所有SIP方法。对于这个版本的PJSIP， invite session处理INVITE、BYE、ACK、CANCEL、UPDATE和PRACK方法。应用程序必须使用 invite session API创建和发送请求和响应消息与上述方法。这对于确保请求和响应消息得到正确处理以及包含session使用的适当功能（例如可靠的临时响应）是必要的。</p>
<h3 id="1216-extending-the-dialog"><a class="header" href="#1216-extending-the-dialog">12.1.6 Extending the Dialog</a></h3>
<p>如前所述， invite session处理dialog中出现的INVITE、BYE、ACK、CANCEL、UPDATE和PRACK消息。当应用程序想要支持或处理其他类型的消息时，它必须将自己注册到dialog中作为 dialog usage。这将使应用程序能够处理传入的请求，这些请求是现有dialog的语言“未处理”的。应用程序正确设置其应用程序模块的优先级是很重要的。应用程序优先级应设置为PJSIP_MOD_PRIORITY_APPLICATION。邀请使用的模块优先级设置为（PJSIP_MOD_PRIORITY_APPLICATION-1）。这将确保invite用法能够在应用之前首先检查传入的请求。</p>
<h3 id="1217-extending-the-invite-session"><a class="header" href="#1217-extending-the-invite-session">12.1.7 Extending the Invite Session</a></h3>
<p>在未来，邀请会话可能会扩展到支持更多的SIP扩展，如呼叫转移，对话目标等，目前，应用程序应该能够通过手动构建消息来执行这些功能。</p>
<h3 id="122-reference"><a class="header" href="#122-reference">12.2 Reference</a></h3>
<h3 id="1221-data-structure"><a class="header" href="#1221-data-structure">12.2.1 Data Structure</a></h3>
<pre><code class="language-c">/**

 * This enumeration describes invite session state.
   */
   typedef enum pjsip_inv_state
   {
   PJSIP_INV_STATE_NULL,           /**&lt; Before INVITE is sent or received  */
   PJSIP_INV_STATE_CALLING,        /**&lt; After INVITE is sent               */
   PJSIP_INV_STATE_INCOMING,       /**&lt; After INVITE is received.          */
   PJSIP_INV_STATE_EARLY,          /**&lt; After response with To tag.        */
   PJSIP_INV_STATE_CONNECTING,     /**&lt; After 2xx is sent/received.        */
   PJSIP_INV_STATE_CONFIRMED,      /**&lt; After ACK is sent/received.        */
   PJSIP_INV_STATE_DISCONNECTED,   /**&lt; Session is terminated.             */
   } pjsip_inv_state;


/**

 * This structure describes the invite session.
   *
 * Note regarding the invite session's pools. The inv_sess used to have
 * only one pool, which is just a pointer to the dialog's pool. Ticket
 * https://github.com/pjsip/pjproject/issues/877 has found that the memory
 * usage will grow considerably everytime re-INVITE or UPDATE is
 * performed.
   *
 * Ticket #877 then created two more memory pools for the inv_sess, so
 * now we have three memory pools:
 * - pool: to be used to allocate long term data for the session
 * - pool_prov and pool_active: this is a flip-flop pools to be used
 * interchangably during re-INVITE and UPDATE. pool_prov is
 * "provisional" pool, used to allocate SDP offer or answer for
 * the re-INVITE and UPDATE. Once SDP negotiation is done, the
 * provisional pool will be made as the active pool, then the
 * existing active pool will be reset, to release the memory
 * back to the OS. So these pool's lifetime is synchronized to
 * the SDP offer-answer negotiation.
    *
 * Higher level application such as PJSUA-LIB has been modified to
 * make use of these flip-flop pools, i.e. by creating media objects
 * from the provisional pool rather than from the long term pool.
   *
 * Other applications that want to use these pools must understand
 * that the flip-flop pool's lifetimes are synchronized to the
 * SDP offer-answer negotiation.
   *
 * The lifetime of this session is controlled by the reference counter in this
 * structure, which is manipulated by calling #pjsip_inv_add_ref and
 * #pjsip_inv_dec_ref. When the reference counter has reached zero, then
 * this session will be destroyed.
   */
   struct pjsip_inv_session
   {
   char                 obj_name[PJ_MAX_OBJ_NAME]; /**&lt; Log identification */
   pj_pool_t           *pool;                      /**&lt; Long term pool.    */
   pj_pool_t           *pool_prov;                 /**&lt; Provisional pool   */
   pj_pool_t           *pool_active;               /**&lt; Active/current pool*/
   pjsip_inv_state      state;                     /**&lt; Invite sess state. */
   pj_bool_t            cancelling;                /**&lt; CANCEL requested   */
   pj_bool_t            pending_cancel;            /**&lt; Wait to send CANCEL*/
   pjsip_tx_data       *pending_bye;               /**&lt; BYE to send later  */
   pjsip_status_code    cause;                     /**&lt; Disconnect cause.  */
   pj_str_t             cause_text;                /**&lt; Cause text.        */
   pj_bool_t            notify;                    /**&lt; Internal.          */
   pj_bool_t            sdp_done_early_rel;        /**&lt; Nego done in early
                                                        med was reliable?  */
   unsigned             cb_called;                 /**&lt; Cb has been called */
   pjsip_dialog        *dlg;                       /**&lt; Underlying dialog. */
   pjsip_role_e         role;                      /**&lt; Invite role.       */
   unsigned             options;                   /**&lt; Options in use.    */
   pjmedia_sdp_neg     *neg;                       /**&lt; Negotiator.        */
   unsigned             sdp_neg_flags;             /**&lt; SDP neg flags.     */
   pjsip_transaction   *invite_tsx;                /**&lt; 1st invite tsx.    */
   pjsip_tx_data       *invite_req;                /**&lt; Saved invite req   */
   pjsip_tx_data       *last_answer;               /**&lt; Last INVITE resp.  */
   pjsip_tx_data       *last_ack;                  /**&lt; Last ACK request   */
   pj_int32_t           last_ack_cseq;             /**&lt; CSeq of last ACK   */
   void                *mod_data[PJSIP_MAX_MODULE];/**&lt; Modules data.      */
   struct pjsip_timer  *timer;                     /**&lt; Session Timers.    */
   pj_bool_t            following_fork;            /**&lt; Internal, following
                                                        forked media?      */
   pj_atomic_t         *ref_cnt;                   /**&lt; Reference counter. */
   pj_bool_t            updated_sdp_answer;        /**&lt; SDP answer just been
                                                        updated?           */
   };


</code></pre>
<p>下面的代码显示了可以应用于会话的各种选项。创建会话时需要指定这些选项的位掩码组合。在建立对话之后（包括早期），pjsip_inv_session的选项成员将显示哪些功能在两个端点中通用。</p>
<pre><code class="language-c">/**
 * This enumeration shows various options that can be applied to a session. 
 * The bitmask combination of these options need to be specified when 
 * creating a session. After the dialog is established (including early), 
 * the options member of #pjsip_inv_session shows which capabilities are 
 * common in both endpoints.
 */
enum pjsip_inv_option
{       
    /** 
     * Indicate support for reliable provisional response extension 
     */
    PJSIP_INV_SUPPORT_100REL    = 1,

    /** 
     * Indicate support for session timer extension. 
     */
    PJSIP_INV_SUPPORT_TIMER     = 2,

    /** 
     * Indicate support for UPDATE method. This is automatically implied
     * when creating outgoing dialog. After the dialog is established,
     * the options member of #pjsip_inv_session shows whether peer supports
     * this method as well.
     */
    PJSIP_INV_SUPPORT_UPDATE    = 4,

    /**
     * Indicate support for ICE
     */
    PJSIP_INV_SUPPORT_ICE       = 8,

    /**
     * Require ICE support.
     */
    PJSIP_INV_REQUIRE_ICE       = 16,

    /** 
     * Require reliable provisional response extension. 
     */
    PJSIP_INV_REQUIRE_100REL    = 32,

    /**  
     * Require session timer extension. 
     */
    PJSIP_INV_REQUIRE_TIMER     = 64,

    /**  
     * Session timer extension will always be used even when peer doesn't
     * support/want session timer.
     */
    PJSIP_INV_ALWAYS_USE_TIMER  = 128,

    /**
     * Indicate support for trickle ICE
     */
    PJSIP_INV_SUPPORT_TRICKLE_ICE = 256,

    /**
     * Require trickle ICE support.
     */
    PJSIP_INV_REQUIRE_TRICKLE_ICE = 512,

};

</code></pre>
<h3 id="1222-invite-usage-module"><a class="header" href="#1222-invite-usage-module">12.2.2 Invite Usage Module</a></h3>
<p>在创建任何invite session之前，必须初始化invite dialog usage模块。</p>
<p>pjsip_inv_usage_init：初始化invite dialog usage模块并将其注册到endpoint。回调参数包含一个指针，指向在invite session中发生事件时要调用的函数（Session Callback）。</p>
<p>pjsip_inv_usage_instance：获取invite usage模块的实例。</p>
<h3 id="1223-session-callback"><a class="header" href="#1223-session-callback">12.2.3 Session Callback</a></h3>
<p>usage 处理 session事件的函数</p>
<p>结构pjsip_inv_callback包含指向函数的指针，该函数将可以由应用程序注册到invite dialog usage模块以接收关于invite session事件的通知。</p>
<p>on_state_changed：当invite session状态更改时，将调用此回调。应用程序应该检查session状态（inv_sess-&gt;state）以获取当前状态。此回调是强制性的。</p>
<p>on_new_session：当invite使用模块创建了一个新的dialog并由于forked传出请求而发出invite时，将调用此回调。此回调是强制性的。</p>
<p>on_tsx_state_changed：每当dialog中的任何transaction更改了其状态时，都会调用此回调。应用程序可以实现此回调，例如，监控传出请求的进度。此回调是可选的。</p>
<p>on_rx_offer：当invite session收到来自对等方的新提议时，将调用此回调。应用程序通过调用pjsip_inv_set_sdp_answer（）设置本地应答。此功能不会发送外发消息。它只是保留SDP协商过程的答案，并将包含在后续发送的响应或请求中。此回调是可选的。如果未指定，默认行为是与会话的初始功能协商远程提供。</p>
<p>on_media_update：此回调在SDP协商完后调用。status参数指定pjmedia_sdp_neg_negotiate（）返回的offer/answer的状态。这个回调是可选的（从框架的角度来看），但是所有有用的应用程序通常都需要实现这个回调。</p>
<h3 id="1224-session-creation-and-termination"><a class="header" href="#1224-session-creation-and-termination">12.2.4 Session Creation and Termination</a></h3>
<p>**pjsip_inv_create_uac：**在dlg中为指定的dialog创建UAC invite session。如果应用程序已确定其媒体能力，则可以在local_sdp中指定SDP。否则，它可以将其保留为NULL，以让远程UAS指定一个要约。选项参数是pjsip_inv_options枚举中SIP功能的位掩码组合。成功返回时，invite session将被放入inv_sess参数中，函数将返回PJ_SUCCESS。否则，失败时将返回相应的错误状态。</p>
<p>**pjsip_inv_verify_request：**应用程序应该在创建invite session（甚至对话）之前，在rdata中接收到初始INVITE请求时调用此函数，以验证nvite session可以处理INVITE请求。此功能验证本地endpoint是否能够处理请求中所需的SIP扩展（即Require报头字段）以及媒体（如果请求中存在媒体描述）。调用此函数时，选项参数SHOULD包含要应用于会话的所需SIP扩展。返回时，此参数将包含在考虑请求中的Supported、Require和Allow标头后将应用于会话的SIP扩展。如果本地媒体能力已经确定，并且如果应用程序希望验证它可以处理传入INVITE请求中的媒体提供，则应在local_sdp参数中指定其本地媒体能力。如果未指定，此功能将不执行介质验证。如果一切都协商成功，函数将返回PJ_SUCCESS。否则，它将返回失败的原因。此功能能够在验证失败时创建适当的响应消息。如果指定了tdata，那么当验证失败时，将创建一个非2xx的最终响应，并在返回时放入此参数中。如果在调用此函数之前已经创建了dialog，则必须在dlg参数中指定它。否则，应用程序必须指定endpt参数（例如，当应用程序想要无状态地发送响应时，这很有用）。</p>
<p>**pjsip_inv_create_uas：**在dlg中为指定的dialog创建UAS invite session。应用程序必须在rdata中指定收到的INVITE请求。邀请会话需要检查接收到的请求，以查看请求是否包含它支持的功能。应用程序应该在调用此函数之前调用验证函数，以确保它可以成功创建会话。如果应用程序已确定其媒体功能，则可以在local_sdp中指定此功能。如果在初始INVITE中接收到SDP，则local_sdp中指定的UAS功能不必与接收到的要约匹配; SDP协商器能够重新安排应答中的媒体线路，以便其与要约匹配。选项参数是pjsip_inv_options枚举中SIP功能的位掩码组合。成功返回时，邀请会话将被放入inv_sess参数中，函数将返回PJ_SUCCESS。否则，失败时将返回相应的错误状态。</p>
<p>**pjsip_inv_terminate：**提前终止INVITE会话并销毁基础dialog（如果该dialog没有其他用途）。只有在INVITE会话初始化失败时才应调用此函数。对于正常情况，应用程序必须通过调用pjsip_inv_end_session（）来终止INVITE会话。st_code参数指定作为断开原因的SIP状态代码。如果notify为true，则将调用应用程序回调。</p>
<h3 id="1225-session-operations"><a class="header" href="#1225-session-operations">12.2.5 Session Operations</a></h3>
<p><strong>pjsip_inv_invite:</strong> 创建此会话的初始INVITE请求。</p>
<p>此函数只能在UAC会话中调用。如果初始INVITE请求可以成功创建，则它将被放入tdata参数中。如果在创建邀请会话时指定了本地媒体功能，则此函数将在传出的INVITE请求中放置SDP提议。否则，传出请求将不包含SDP主体。</p>
<p><strong>pjsip_inv_answer:</strong> 创建对初始INVITE请求的响应消息。</p>
<p>st_code包含要发送的状态代码，它可以是临时的或最终的响应。如果需要自定义状态文本，应用程序可以在st_text中指定文本;否则，如果此参数为NULL，则将使用默认状态文本。 如果应用程序在创建UAS invite session期间指定了其媒体功能，则local_sdp参数必须为NULL。这是因为应用程序不能在单个INVITE transaction中执行多个SDP提供/应答会话。如果应用程序在创建UAS邀请会话期间没有指定其媒体能力，则它可以或必须在local_sdp参数中指定其能力，这取决于st_code是否指示2xx最终响应。</p>
<p>**pjsip_inv_end_session：**创建SIP消息以启动邀请会话终止。</p>
<p>根据会话的状态，此函数可能返回CANCEL请求、非2xx最终响应或BYE请求。如果会话没有应答传入的INVITE，此函数将创建非2xx最终响应，并在st_code中指定状态代码，在st_text中指定可选状态文本。</p>
<p>**pjsip_inv_reinvite：**创建re-INVITE请求。</p>
<p>如果应用程序想要更新其本地联系人并通知对等体使用新联系人执行目标刷新，则可以在new_contact参数中指定新联系人;否则此参数必须为NULL。当没有待发送或接收的应答时，应用程序可以在请求中发起新的SDP提供/应答会话。它可以通过观察邀请会话的SDP协商者的状态来检测这种情况。如果new offer应该发送到remote，则必须在new_offer中指定offer，否则此参数必须为NULL。</p>
<p>**pjsip_inv_update：**创建UPDATE请求。</p>
<p>如果应用程序想要更新其本地联系人并通知对等体使用新联系人执行目标刷新，则可以在new_contact参数中指定新联系人;否则此参数必须为NULL。当没有待发送或接收的应答时，应用程序可以在请求中发起新的SDP提供/应答会话。它可以通过观察邀请会话的SDP协商者的状态来检测这种情况。如果new offer应该发送到remote，则必须在new_offer中指定offer，否则此参数必须为NULL。</p>
<p>**pjsip_inv_send_msg：**在tdata中发送请求或响应消息。</p>
<p>令牌是一个任意的应用程序数据，它将被放置在事务的mod_data数组中，位于应用程序模块的索引处。</p>
<h3 id="1226-auxiliary-api"><a class="header" href="#1226-auxiliary-api">12.2.6 Auxiliary API</a></h3>
<p>pjsip_dlg_get_inv_session：获取与对话dlg关联的invite session实例，或NULL。</p>
<p>pjsip_tsx_get_inv_session：获取与transaction tsx关联的invite session实例，或NULL。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state"><a class="header" href="#state">State</a></h1>
<p>转载：<a href="https://blog.csdn.net/croop520/article/details/78666799">sip信令超时时间调整_pjsip的最长呼叫等待时间-CSDN博客</a></p>
<p><strong>UAC （呼叫方）状态机转换如下：</strong></p>
<p><img src="img/UAC_invite.png" alt="img" /></p>
<p>刚开始呼叫时，sip_transaction的状态机处于tsx_on_state_null状态，拨打电话发出INVITE信令后，状态机转为Calling状态，处理函数：tsx_on_state_calling，应用可以收到Calling的状态通知。</p>
<p>之后会收到被叫方发来的100 try信令，状态机转为Processing状态，处理函数：tsx_on_state_proceeding_uac</p>
<p>在收到180 ringing的信令后，还是在tsx_on_state_proceeding_uac中处理，应用会收到Early的状态通知。</p>
<p>如果被叫方接听了该呼叫，会收到被叫方的200 OK信令，状态机会转为Terminated状态，处理函数：tsx_on_state_terminated，应用会收到Connecting的状态通知，之后会通过timeout方式，把状态转为Destroyed。Call的状态也转为Confirmed。</p>
<p><strong>Bye信令状态转换：</strong></p>
<p><img src="img/bye_uac.png" alt="img" /></p>
<p>发出Bye信令时，状态机转为Calling状态（tsx_on_state_calling），在收到200OK信令时，转为Completed状态（tsx_on_state_completed_uac），应用会收到Disconnected的状态通知</p>
<p>，之后通过timeout的方式，状态转为Terminated和Destroyed</p>
<p><strong>UAS（被叫方）状态机转换如下：</strong></p>
<p><em><strong>*<img src="img/uas_invite.png" alt="img" />*</strong></em></p>
<p>Bye状态转换：</p>
<p><img src="img/bye_uas.png" alt="img" /></p>
<p>被叫方的转换和呼叫方类似。</p>
<div style="break-before: page; page-break-before: always;"></div><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=5,IE=9" ><![endif]-->
<!DOCTYPE html>
<html>
<head>
<title>make_call</title>
<meta charset="utf-8"/>
</head>
<body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;Electron\&quot; modified=\&quot;2024-02-05T09:25:00.446Z\&quot; agent=\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) draw.io/23.0.2 Chrome/120.0.6099.109 Electron/28.1.0 Safari/537.36\&quot; etag=\&quot;SRPfLFEZ7rk0RFPKnhQI\&quot; version=\&quot;23.0.2\&quot; type=\&quot;device\&quot;&gt;\n  &lt;diagram name=\&quot;第 1 页\&quot; id=\&quot;1MJY-K0O8pv3mbvC8SUG\&quot;&gt;\n    &lt;mxGraphModel dx=\&quot;2998\&quot; dy=\&quot;1113\&quot; grid=\&quot;1\&quot; gridSize=\&quot;10\&quot; guides=\&quot;1\&quot; tooltips=\&quot;1\&quot; connect=\&quot;1\&quot; arrows=\&quot;1\&quot; fold=\&quot;1\&quot; page=\&quot;1\&quot; pageScale=\&quot;1\&quot; pageWidth=\&quot;827\&quot; pageHeight=\&quot;1169\&quot; math=\&quot;0\&quot; shadow=\&quot;0\&quot;&gt;\n      &lt;root&gt;\n        &lt;mxCell id=\&quot;0\&quot; /&gt;\n        &lt;mxCell id=\&quot;1\&quot; parent=\&quot;0\&quot; /&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-1\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;N3EoBCBhOJMtYulJdJZf-2\&quot; target=\&quot;N3EoBCBhOJMtYulJdJZf-4\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-2\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Check that account is valid&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;330\&quot; y=\&quot;90\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-3\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;N3EoBCBhOJMtYulJdJZf-4\&quot; target=\&quot;N3EoBCBhOJMtYulJdJZf-8\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-4\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Check arguments&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;330\&quot; y=\&quot;180\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-5\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;acc_id&amp;lt;/div&amp;gt;\&quot; style=\&quot;text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;450\&quot; y=\&quot;105\&quot; width=\&quot;70\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-6\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;dest_uri&amp;lt;/div&amp;gt;\&quot; style=\&quot;text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;450\&quot; y=\&quot;195\&quot; width=\&quot;80\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-7\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;N3EoBCBhOJMtYulJdJZf-8\&quot; target=\&quot;N3EoBCBhOJMtYulJdJZf-10\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-8\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;PJSUA_LOCK&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;rounded=0;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;330\&quot; y=\&quot;270\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-9\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;N3EoBCBhOJMtYulJdJZf-10\&quot; target=\&quot;N3EoBCBhOJMtYulJdJZf-13\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-10\&quot; value=\&quot;获取并检查acc\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;330\&quot; y=\&quot;360\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-11\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;acc = &amp;amp;amp;pjsua_var.acc[&amp;lt;span style=&amp;quot;color: #808080;&amp;quot;&amp;gt;acc_id&amp;lt;/span&amp;gt;];&amp;lt;/div&amp;gt;\&quot; style=\&quot;text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;450\&quot; y=\&quot;375\&quot; width=\&quot;230\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-12\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;N3EoBCBhOJMtYulJdJZf-13\&quot; target=\&quot;N3EoBCBhOJMtYulJdJZf-16\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-13\&quot; value=\&quot;分配并检查call-id\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;330\&quot; y=\&quot;448\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-14\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;alloc_call_id&amp;lt;/div&amp;gt;\&quot; style=\&quot;text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;450\&quot; y=\&quot;463\&quot; width=\&quot;120\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-15\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;N3EoBCBhOJMtYulJdJZf-16\&quot; target=\&quot;N3EoBCBhOJMtYulJdJZf-19\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-16\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Clear call descriptor&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;330\&quot; y=\&quot;525\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-17\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsua_var.calls[call_id]&amp;lt;br&amp;gt;&amp;lt;/div&amp;gt;\&quot; style=\&quot;text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;450\&quot; y=\&quot;540\&quot; width=\&quot;200\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-18\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;N3EoBCBhOJMtYulJdJZf-19\&quot; target=\&quot;N3EoBCBhOJMtYulJdJZf-22\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-19\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Associate session with account&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;330\&quot; y=\&quot;610\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-20\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;&amp;lt;div&amp;gt;call-&amp;amp;gt;acc_id = &amp;lt;span style=&amp;quot;color: #808080;&amp;quot;&amp;gt;acc_id&amp;lt;/span&amp;gt;;&amp;lt;/div&amp;gt;&amp;lt;div&amp;gt;    &amp;lt;span style=&amp;quot;color: #1f377f;&amp;quot;&amp;gt;call&amp;lt;/span&amp;gt;-&amp;amp;gt;call_hold_type = &amp;lt;span style=&amp;quot;color: #1f377f;&amp;quot;&amp;gt;acc&amp;lt;/span&amp;gt;-&amp;amp;gt;cfg.call_hold_type;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;\&quot; style=\&quot;text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;450\&quot; y=\&quot;615\&quot; width=\&quot;360\&quot; height=\&quot;50\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-21\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;N3EoBCBhOJMtYulJdJZf-22\&quot; target=\&quot;N3EoBCBhOJMtYulJdJZf-25\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-22\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Generate per-session RTCP CNAME, according to RFC 7022&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;330\&quot; y=\&quot;690\&quot; width=\&quot;120\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-23\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;&amp;lt;div&amp;gt;    pj_create_random_string(&amp;lt;span style=&amp;quot;color: #1f377f;&amp;quot;&amp;gt;call&amp;lt;/span&amp;gt;-&amp;amp;gt;cname_buf, &amp;lt;span style=&amp;quot;color: #1f377f;&amp;quot;&amp;gt;call&amp;lt;/span&amp;gt;-&amp;amp;gt;cname.slen);&amp;lt;/div&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/div&amp;gt;\&quot; style=\&quot;text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;450\&quot; y=\&quot;710\&quot; width=\&quot;450\&quot; height=\&quot;50\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-24\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;N3EoBCBhOJMtYulJdJZf-25\&quot; target=\&quot;N3EoBCBhOJMtYulJdJZf-28\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-25\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Apply call setting&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;330\&quot; y=\&quot;790\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-26\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;status = &amp;lt;span style=&amp;quot;color: #74531f;&amp;quot;&amp;gt;apply_call_setting&amp;lt;/span&amp;gt;(&amp;lt;span style=&amp;quot;color: #1f377f;&amp;quot;&amp;gt;call&amp;lt;/span&amp;gt;, &amp;lt;span style=&amp;quot;color: #808080;&amp;quot;&amp;gt;opt&amp;lt;/span&amp;gt;, &amp;lt;span style=&amp;quot;color: #8a1bff;&amp;quot;&amp;gt;NULL&amp;lt;/span&amp;gt;);&amp;lt;/div&amp;gt;\&quot; style=\&quot;text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;450\&quot; y=\&quot;805\&quot; width=\&quot;350\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-27\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;N3EoBCBhOJMtYulJdJZf-28\&quot; target=\&quot;N3EoBCBhOJMtYulJdJZf-31\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-28\&quot; value=\&quot;创建声音设备&amp;amp;nbsp;&amp;amp;nbsp;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;330\&quot; y=\&quot;870\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-29\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsua_set_snd_dev&amp;lt;/div&amp;gt;\&quot; style=\&quot;text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;450\&quot; y=\&quot;885\&quot; width=\&quot;150\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-30\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;N3EoBCBhOJMtYulJdJZf-31\&quot; target=\&quot;N3EoBCBhOJMtYulJdJZf-34\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-31\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Verify and Parse that destination URI &amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;330\&quot; y=\&quot;950\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-32\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;uri = &amp;lt;span style=&amp;quot;color: #74531f;&amp;quot;&amp;gt;pjsip_parse_uri&amp;lt;/span&amp;gt;(&amp;lt;span style=&amp;quot;color: #1f377f;&amp;quot;&amp;gt;tmp_pool&amp;lt;/span&amp;gt;, &amp;lt;span style=&amp;quot;color: #1f377f;&amp;quot;&amp;gt;dup&amp;lt;/span&amp;gt;.ptr, &amp;lt;span style=&amp;quot;color: #1f377f;&amp;quot;&amp;gt;dup&amp;lt;/span&amp;gt;.slen, &amp;lt;span style=&amp;quot;color: #098658;&amp;quot;&amp;gt;0&amp;lt;/span&amp;gt;);&amp;lt;/div&amp;gt;\&quot; style=\&quot;text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;450\&quot; y=\&quot;965\&quot; width=\&quot;410\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-33\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;N3EoBCBhOJMtYulJdJZf-34\&quot; target=\&quot;N3EoBCBhOJMtYulJdJZf-36\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-34\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Mark call start time.&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;150\&quot; y=\&quot;950\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-35\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;N3EoBCBhOJMtYulJdJZf-36\&quot; target=\&quot;N3EoBCBhOJMtYulJdJZf-39\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-36\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Reset first response time&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;150\&quot; y=\&quot;870\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-37\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pj_gettimeofday&amp;lt;/div&amp;gt;\&quot; style=\&quot;text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;20\&quot; y=\&quot;885\&quot; width=\&quot;130\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-38\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;N3EoBCBhOJMtYulJdJZf-39\&quot; target=\&quot;N3EoBCBhOJMtYulJdJZf-41\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-39\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Create suitable Contact header&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;150\&quot; y=\&quot;790\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-40\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;N3EoBCBhOJMtYulJdJZf-41\&quot; target=\&quot;N3EoBCBhOJMtYulJdJZf-43\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-41\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Create an UAC dialog&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;150\&quot; y=\&quot;710\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-42\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsip_dlg_create_uac&amp;lt;/div&amp;gt;\&quot; style=\&quot;text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-20\&quot; y=\&quot;730\&quot; width=\&quot;170\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-43\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Calculate call&amp;#39;s secure level&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;150\&quot; y=\&quot;630\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-44\&quot; value=\&quot;初始化媒体流信道\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;150\&quot; y=\&quot;550\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-45\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsua_media_channel_init&amp;lt;/div&amp;gt;\&quot; style=\&quot;text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-50\&quot; y=\&quot;565\&quot; width=\&quot;200\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;N3EoBCBhOJMtYulJdJZf-46\&quot; value=\&quot;&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; font-weight: normal; font-size: 12px; line-height: 18px;&amp;quot;&amp;gt;&amp;lt;div&amp;gt;&amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt;Outgoing call callback when media transport creation is completed&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;150\&quot; y=\&quot;420\&quot; width=\&quot;120\&quot; height=\&quot;110\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n      &lt;/root&gt;\n    &lt;/mxGraphModel&gt;\n  &lt;/diagram&gt;\n&lt;/mxfile&gt;\n&quot;}"></div>
<script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
</body>
</html><div style="break-before: page; page-break-before: always;"></div><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=5,IE=9" ><![endif]-->
<!DOCTYPE html>
<html>
<head>
<title>pjsip_dlg_create_uac</title>
<meta charset="utf-8"/>
</head>
<body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;Electron\&quot; modified=\&quot;2024-02-05T09:34:13.633Z\&quot; agent=\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) draw.io/23.0.2 Chrome/120.0.6099.109 Electron/28.1.0 Safari/537.36\&quot; etag=\&quot;dbHGqIm8xYyq5nR8Iul5\&quot; version=\&quot;23.0.2\&quot; type=\&quot;device\&quot;&gt;\n  &lt;diagram name=\&quot;第 1 页\&quot; id=\&quot;Xj2k2AnkuFdQmTh-Ux4U\&quot;&gt;\n    &lt;mxGraphModel dx=\&quot;367\&quot; dy=\&quot;612\&quot; grid=\&quot;1\&quot; gridSize=\&quot;10\&quot; guides=\&quot;1\&quot; tooltips=\&quot;1\&quot; connect=\&quot;1\&quot; arrows=\&quot;1\&quot; fold=\&quot;1\&quot; page=\&quot;1\&quot; pageScale=\&quot;1\&quot; pageWidth=\&quot;827\&quot; pageHeight=\&quot;1169\&quot; math=\&quot;0\&quot; shadow=\&quot;0\&quot;&gt;\n      &lt;root&gt;\n        &lt;mxCell id=\&quot;0\&quot; /&gt;\n        &lt;mxCell id=\&quot;1\&quot; parent=\&quot;0\&quot; /&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-1\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;Bc1azsTiaTzSrHkS6a_k-2\&quot; target=\&quot;Bc1azsTiaTzSrHkS6a_k-4\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-2\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsip_dlg_create_uac&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1030\&quot; y=\&quot;50\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-3\&quot; style=\&quot;edgeStyle=entityRelationEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;shape=flexArrow;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;Bc1azsTiaTzSrHkS6a_k-4\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;1289\&quot; y=\&quot;170\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-4\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsip_dlg_create_uac2&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1030\&quot; y=\&quot;140\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-5\&quot; value=\&quot;初始化pjsip_dlg_create_uac_param&amp;lt;span style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace;&amp;quot;&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; color: rgb(31, 55, 127);&amp;quot;&amp;gt;create_param&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace;&amp;quot;&amp;gt;;&amp;lt;/span&amp;gt;\&quot; style=\&quot;text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1179\&quot; y=\&quot;65\&quot; width=\&quot;310\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-6\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;Bc1azsTiaTzSrHkS6a_k-7\&quot; target=\&quot;Bc1azsTiaTzSrHkS6a_k-10\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-7\&quot; value=\&quot;Check arguments\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1289\&quot; y=\&quot;145\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-8\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;shape=flexArrow;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;Bc1azsTiaTzSrHkS6a_k-10\&quot; target=\&quot;Bc1azsTiaTzSrHkS6a_k-11\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-9\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;Bc1azsTiaTzSrHkS6a_k-10\&quot; target=\&quot;Bc1azsTiaTzSrHkS6a_k-14\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-10\&quot; value=\&quot;Create dialog instance\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1289\&quot; y=\&quot;234\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-11\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;create_dialog&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1489\&quot; y=\&quot;234\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-12\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;shape=flexArrow;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;Bc1azsTiaTzSrHkS6a_k-14\&quot; target=\&quot;Bc1azsTiaTzSrHkS6a_k-15\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-13\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;Bc1azsTiaTzSrHkS6a_k-14\&quot; target=\&quot;Bc1azsTiaTzSrHkS6a_k-17\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-14\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Parse remote target.&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1289\&quot; y=\&quot;320\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-15\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsip_parse_uri&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1489\&quot; y=\&quot;320\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-16\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;Bc1azsTiaTzSrHkS6a_k-17\&quot; target=\&quot;Bc1azsTiaTzSrHkS6a_k-19\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-17\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Put any header param in the target URI into INVITE header list ？？？？&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1289\&quot; y=\&quot;410\&quot; width=\&quot;120\&quot; height=\&quot;110\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-18\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Add target to the target set&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1289\&quot; y=\&quot;535\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-19\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Init local.&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;初始化dlg&amp;lt;span style=&amp;quot;&amp;quot;&amp;gt;-&amp;amp;gt;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;&amp;quot;&amp;gt;local，包括info、&amp;lt;/span&amp;gt;tag、hash value、CSeq、contact&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1289\&quot; y=\&quot;610\&quot; width=\&quot;120\&quot; height=\&quot;140\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-20\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Init remote.&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;初始化dlg&amp;lt;span style=&amp;quot;&amp;quot;&amp;gt;-&amp;amp;gt;&amp;lt;/span&amp;gt;&amp;amp;nbsp;remote&amp;lt;span style=&amp;quot;&amp;quot;&amp;gt;，包括info、&amp;lt;/span&amp;gt;tag、hash value、CSeq、contact&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1289\&quot; y=\&quot;770\&quot; width=\&quot;120\&quot; height=\&quot;140\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-21\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Initial role is UAC.&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1289\&quot; y=\&quot;930\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-22\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Generate Call-ID header.&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1289\&quot; y=\&quot;1010\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-23\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;shape=flexArrow;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;Bc1azsTiaTzSrHkS6a_k-24\&quot; target=\&quot;Bc1azsTiaTzSrHkS6a_k-25\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-24\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Register this dialog to user agent.&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1289\&quot; y=\&quot;1090\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;Bc1azsTiaTzSrHkS6a_k-25\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsip_ua_register_dlg&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1499\&quot; y=\&quot;1090\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n      &lt;/root&gt;\n    &lt;/mxGraphModel&gt;\n  &lt;/diagram&gt;\n&lt;/mxfile&gt;\n&quot;}"></div>
<script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
</body>
</html><div style="break-before: page; page-break-before: always;"></div><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=5,IE=9" ><![endif]-->
<!DOCTYPE html>
<html>
<head>
<title>on_make_call_med_tp_complete</title>
<meta charset="utf-8"/>
</head>
<body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;Electron\&quot; modified=\&quot;2024-02-05T09:35:56.586Z\&quot; agent=\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) draw.io/23.0.2 Chrome/120.0.6099.109 Electron/28.1.0 Safari/537.36\&quot; etag=\&quot;ZIUeSZrFmLgCFIlamgJv\&quot; version=\&quot;23.0.2\&quot; type=\&quot;device\&quot;&gt;\n  &lt;diagram name=\&quot;第 1 页\&quot; id=\&quot;dm5Nj5f2KzERc9XE3jcm\&quot;&gt;\n    &lt;mxGraphModel dx=\&quot;3644\&quot; dy=\&quot;2189\&quot; grid=\&quot;1\&quot; gridSize=\&quot;10\&quot; guides=\&quot;1\&quot; tooltips=\&quot;1\&quot; connect=\&quot;1\&quot; arrows=\&quot;1\&quot; fold=\&quot;1\&quot; page=\&quot;1\&quot; pageScale=\&quot;1\&quot; pageWidth=\&quot;827\&quot; pageHeight=\&quot;1169\&quot; math=\&quot;0\&quot; shadow=\&quot;0\&quot;&gt;\n      &lt;root&gt;\n        &lt;mxCell id=\&quot;0\&quot; /&gt;\n        &lt;mxCell id=\&quot;1\&quot; parent=\&quot;0\&quot; /&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-1\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;shape=flexArrow;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-2\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-7\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-2\&quot; value=\&quot;on_make_call_med_tp_complete\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1550\&quot; y=\&quot;347.5\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-3\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-4\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-11\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-4\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsua_media_channel_create_sdp&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1120\&quot; y=\&quot;347.5\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-5\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;shape=flexArrow;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-7\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-4\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-6\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-7\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-21\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-7\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Create SDP based on the current media channel&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1340\&quot; y=\&quot;347.5\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-8\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-11\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-16\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-9\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-11\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-12\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-10\&quot; value=\&quot;需要对所有provisional media做\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;-eo6Yc6-5UVX0u5PC9od-9\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-0.2468\&quot; y=\&quot;-2\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint as=\&quot;offset\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-11\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;&amp;lt;div&amp;gt;Get media transport info from the specified transport and all underlying &amp;lt;/div&amp;gt;&amp;lt;div&amp;gt;&amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt; * transports if any. The transport also contains information about socket info&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div&amp;gt;&amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt; * which describes the local address of the transport, and would be needed&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div&amp;gt;&amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt; * for example to fill in the &amp;quot;c=&amp;quot; and &amp;quot;m=&amp;quot; line of local SDP.&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-840\&quot; y=\&quot;-127.5\&quot; width=\&quot;143\&quot; height=\&quot;365\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-12\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjmedia_transport_get_info&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-493\&quot; y=\&quot;25\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-13\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-16\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-17\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-14\&quot; value=\&quot;no media line\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot; parent=\&quot;-eo6Yc6-5UVX0u5PC9od-13\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-0.3648\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint as=\&quot;offset\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-15\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-16\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-18\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-16\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Create the base (blank) SDP&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-838.5\&quot; y=\&quot;287.5\&quot; width=\&quot;140\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-17\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjmedia_endpt_create_base_sdp&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-500\&quot; y=\&quot;297.5\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-18\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Process each media line&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-838\&quot; y=\&quot;407.5\&quot; width=\&quot;138\&quot; height=\&quot;70\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-19\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-21\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-23\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-20\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-21\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-29\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-21\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Create UAC invite session.&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1340\&quot; y=\&quot;500\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-22\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-23\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-25\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-23\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsip_inv_create_uac&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1160\&quot; y=\&quot;500\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-24\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-25\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-27\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-25\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Create the session&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1020\&quot; y=\&quot;500\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-26\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-27\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-37\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-27\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Register invite as dialog usage.&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1020\&quot; y=\&quot;595\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-28\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-29\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-31\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-29\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Init Session Timers&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1340\&quot; y=\&quot;615\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-30\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-31\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-33\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-31\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Create and associate our data in the session.&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1340\&quot; y=\&quot;715\&quot; width=\&quot;120\&quot; height=\&quot;85\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-32\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-33\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-36\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-33\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Set dialog&amp;#39;s transport based on acc&amp;#39;s config&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1340\&quot; y=\&quot;835\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-34\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-36\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-39\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-35\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-36\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-57\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-36\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;line-height: 18px;&amp;quot;&amp;gt;Create initial INVITE request.&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1340\&quot; y=\&quot;930\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-37\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsip_dlg_add_usage&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-838\&quot; y=\&quot;595\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-38\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-39\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-42\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-39\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsip_inv_invite&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1160\&quot; y=\&quot;930\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-40\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-42\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-47\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-41\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-42\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-44\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-42\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Create the INVITE request.&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1000\&quot; y=\&quot;700\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-43\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-44\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-51\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-44\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsip_dlg_create_request&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-840\&quot; y=\&quot;700\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-45\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-47\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-49\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-46\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-47\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-55\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-47\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;See if we have SDP to send.&amp;amp;nbsp;Add SDP, if any.&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1000\&quot; y=\&quot;800\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-48\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Add Require header&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1000\&quot; y=\&quot;980\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-49\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsip_msg_add_hdr&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-840\&quot; y=\&quot;800\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-50\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-51\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-52\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-51\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;line-height: 18px;&amp;quot;&amp;gt;Create a new request within dialog&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-680\&quot; y=\&quot;700\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-52\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;dlg_create_request_throw&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-523\&quot; y=\&quot;700\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-53\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsip_get_invite_method&amp;lt;/div&amp;gt;\&quot; style=\&quot;text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-870\&quot; y=\&quot;670\&quot; width=\&quot;190\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-54\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-55\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-48\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-55\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Add Supported header&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1000\&quot; y=\&quot;890\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-56\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-57\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-58\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-57\&quot; value=\&quot;&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; font-weight: normal; font-size: 12px; line-height: 18px;&amp;quot;&amp;gt;&amp;lt;div&amp;gt;&amp;lt;span style=&amp;quot;color: #008000;&amp;quot;&amp;gt;Send initial INVITE&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1340\&quot; y=\&quot;1060\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-58\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsip_inv_send_msg&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1160\&quot; y=\&quot;1060\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-59\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-60\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-63\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-60\&quot; value=\&quot;Send request message to remote peer. If the request is not an ACK request, the dialog will send the request statefully, by creating an UAC transaction and send the request with the transaction. Also when the request is not ACK or CANCEL, the dialog will increment its local cseq number and update the cseq in the request according to dialog&amp;#39;s cseq. If p_tsx is not null, this argument will be set with the transaction instance that was used to send the request. This function will decrement the transmit data&amp;#39;s reference counter regardless the status of the operation.\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1000\&quot; y=\&quot;1070\&quot; width=\&quot;120\&quot; height=\&quot;420\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-61\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0.014;entryY=0.602;entryDx=0;entryDy=0;entryPerimeter=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-58\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-60\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-62\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-63\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-65\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-63\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsip_dlg_send_request&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-829\&quot; y=\&quot;1070\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-64\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-65\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-68\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-65\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Update dialog&amp;#39;s CSeq and message&amp;#39;s CSeq&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-660\&quot; y=\&quot;1070\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-66\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-68\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-71\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-67\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-68\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-85\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-68\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;line-height: 18px;&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;line-height: 18px;&amp;quot;&amp;gt;Create, initialize, and register a new transaction as UAC from the specified transmit data (tdata).&amp;amp;nbsp;&amp;lt;br&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-660\&quot; y=\&quot;1160\&quot; width=\&quot;120\&quot; height=\&quot;170\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-69\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;tdata&amp;amp;nbsp;&amp;lt;/div&amp;gt;initial INVITE request 的数据结构\&quot; style=\&quot;text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-1200\&quot; y=\&quot;880\&quot; width=\&quot;200\&quot; height=\&quot;50\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-70\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-71\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-74\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-71\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsip_tsx_create_uac2&amp;amp;amp;&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsip_tsx_create_uac2&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-460\&quot; y=\&quot;1215\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-72\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-74\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-75\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-73\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-74\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-77\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-74\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Create transaction instance&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-280\&quot; y=\&quot;1080\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-75\&quot; value=\&quot;&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; font-weight: normal; font-size: 12px; line-height: 18px;&amp;quot;&amp;gt;&amp;lt;div&amp;gt;&amp;lt;span style=&amp;quot;color: #74531f;&amp;quot;&amp;gt;tsx_create&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-90\&quot; y=\&quot;1080\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-76\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-77\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-79\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-77\&quot; value=\&quot;ROLE、method、CSeq、Generate Via\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-280\&quot; y=\&quot;1165\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-78\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-79\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-81\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-79\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Generate transaction key.&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-280\&quot; y=\&quot;1245\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-80\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-81\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-82\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-81\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Calculate hashed key value.&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-280\&quot; y=\&quot;1325\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-82\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Register transaction to hash table.&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-280\&quot; y=\&quot;1405\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-83\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-85\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-86\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-84\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-85\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-88\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-85\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Set transport selector&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-660\&quot; y=\&quot;1380\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-86\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsip_tsx_set_transport&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-460\&quot; y=\&quot;1380\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-87\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-88\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-90\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-88\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Send the message.&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-660\&quot; y=\&quot;1490\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-89\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-90\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-92\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-90\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;pjsip_tsx_send_msg&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-460\&quot; y=\&quot;1490\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-91\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-92\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-94\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-92\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Dispatch to transaction&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-270\&quot; y=\&quot;1490\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-93\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-94\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-96\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-94\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Set transport selector to tdata&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-270\&quot; y=\&quot;1580\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-95\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-eo6Yc6-5UVX0u5PC9od-96\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-97\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-96\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Dispatch to state handler&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-270\&quot; y=\&quot;1670\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-97\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;(*tsx-&amp;amp;gt;state_handler)(&amp;lt;span style=&amp;quot;color: #808080;&amp;quot;&amp;gt;tsx&amp;lt;/span&amp;gt;, &amp;amp;amp;&amp;lt;span style=&amp;quot;color: #1f377f;&amp;quot;&amp;gt;event&amp;lt;/span&amp;gt;)&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;line-height: 18px;&amp;quot;&amp;gt;tsx_on_state_null&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-80\&quot; y=\&quot;1640\&quot; width=\&quot;140\&quot; height=\&quot;120\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-98\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;tsx-&amp;amp;gt;state_handler = &amp;amp;amp;&amp;lt;span style=&amp;quot;color: #74531f;&amp;quot;&amp;gt;tsx_on_state_null&amp;lt;/span&amp;gt;;&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-95\&quot; y=\&quot;1280\&quot; width=\&quot;150\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-eo6Yc6-5UVX0u5PC9od-99\&quot; value=\&quot;\&quot; style=\&quot;endArrow=classic;html=1;rounded=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; target=\&quot;-eo6Yc6-5UVX0u5PC9od-98\&quot;&gt;\n          &lt;mxGeometry width=\&quot;50\&quot; height=\&quot;50\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;-220\&quot; y=\&quot;1310\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;-90\&quot; y=\&quot;1270\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n      &lt;/root&gt;\n    &lt;/mxGraphModel&gt;\n  &lt;/diagram&gt;\n&lt;/mxfile&gt;\n&quot;}"></div>
<script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
</body>
</html><div style="break-before: page; page-break-before: always;"></div><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=5,IE=9" ><![endif]-->
<!DOCTYPE html>
<html>
<head>
<title>tsx_on_state_null</title>
<meta charset="utf-8"/>
</head>
<body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;Electron\&quot; modified=\&quot;2024-02-05T11:59:03.105Z\&quot; agent=\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) draw.io/23.0.2 Chrome/120.0.6099.109 Electron/28.1.0 Safari/537.36\&quot; etag=\&quot;HN8B6Mv5MQhKg60n84yj\&quot; version=\&quot;23.0.2\&quot; type=\&quot;device\&quot;&gt;\n  &lt;diagram name=\&quot;第 1 页\&quot; id=\&quot;Cg21HPRUDu0QK858DQtc\&quot;&gt;\n    &lt;mxGraphModel dx=\&quot;1706\&quot; dy=\&quot;-295\&quot; grid=\&quot;1\&quot; gridSize=\&quot;10\&quot; guides=\&quot;1\&quot; tooltips=\&quot;1\&quot; connect=\&quot;1\&quot; arrows=\&quot;1\&quot; fold=\&quot;1\&quot; page=\&quot;1\&quot; pageScale=\&quot;1\&quot; pageWidth=\&quot;827\&quot; pageHeight=\&quot;1169\&quot; math=\&quot;0\&quot; shadow=\&quot;0\&quot;&gt;\n      &lt;root&gt;\n        &lt;mxCell id=\&quot;0\&quot; /&gt;\n        &lt;mxCell id=\&quot;1\&quot; parent=\&quot;0\&quot; /&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-4\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-5\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-8\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-5\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;tsx_on_state_null&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;354\&quot; y=\&quot;1500\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-6\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-8\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-10\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-7\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-8\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-12\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-8\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/div&amp;gt;\&quot; style=\&quot;rhombus;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;530\&quot; y=\&quot;1490\&quot; width=\&quot;80\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-9\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-10\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-22\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-10\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;PJSIP_ROLE_UAS&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;620\&quot; y=\&quot;1440\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-11\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-12\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-14\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-12\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;PJSIP_ROLE_UAC&amp;lt;br&amp;gt;&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;620\&quot; y=\&quot;1560\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-13\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-14\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-16\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-14\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Get the txdata&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;780\&quot; y=\&quot;1560\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-15\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-16\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-29\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-16\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Save the message for retransmission&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;780\&quot; y=\&quot;1660\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-17\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-18\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-20\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-18\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Start Timer B (or called timer F for non-INVITE) for transaction timeout&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;780\&quot; y=\&quot;1850\&quot; width=\&quot;120\&quot; height=\&quot;110\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-19\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-20\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-25\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-20\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Start Timer A (or timer E) for retransmission only if unreliable&amp;amp;nbsp;&amp;lt;/div&amp;gt;timeout\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;780\&quot; y=\&quot;1990\&quot; width=\&quot;120\&quot; height=\&quot;120\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-21\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-22\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-23\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-22\&quot; value=\&quot;Set state trying\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;780\&quot; y=\&quot;1440\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-23\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;tsx_set_state&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;930\&quot; y=\&quot;1440\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-24\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-25\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-26\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-25\&quot; value=\&quot;Set state calling\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;780\&quot; y=\&quot;2130\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-26\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;tsx_set_state&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;950\&quot; y=\&quot;2130\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-27\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-29\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-18\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-28\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-29\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-31\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-29\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;line-height: 18px;&amp;quot;&amp;gt;Send message to the transport&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;780\&quot; y=\&quot;1740\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-30\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-31\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-33\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-31\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;tsx_send_msg&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;970\&quot; y=\&quot;1740\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-32\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-33\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-35\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-33\&quot; value=\&quot;send a SIP message using the specified transport to the specified destination.\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1130\&quot; y=\&quot;1740\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-34\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-35\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-40\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-35\&quot; value=\&quot;&amp;amp;nbsp;pjsip_transport_send\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1280\&quot; y=\&quot;1740\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-36\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-37\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-42\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-37\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Send to transport&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1440\&quot; y=\&quot;1840\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-38\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-40\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-37\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-39\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;-cGrdV75PCvy61bXwfDb-40\&quot; target=\&quot;-cGrdV75PCvy61bXwfDb-41\&quot;&gt;\n          &lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-40\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;Distribute to modules. &amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1440\&quot; y=\&quot;1740\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-41\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;status = (*&amp;lt;span style=&amp;quot;color: #808080;&amp;quot;&amp;gt;tr&amp;lt;/span&amp;gt;-&amp;amp;gt;tpmgr-&amp;amp;gt;on_tx_msg)(&amp;lt;span style=&amp;quot;color: #808080;&amp;quot;&amp;gt;tr&amp;lt;/span&amp;gt;-&amp;amp;gt;endpt, &amp;lt;span style=&amp;quot;color: #808080;&amp;quot;&amp;gt;tdata&amp;lt;/span&amp;gt;);&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1609\&quot; y=\&quot;1730\&quot; width=\&quot;221\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;-cGrdV75PCvy61bXwfDb-42\&quot; value=\&quot;&amp;lt;div style=&amp;quot;background-color: rgb(255, 255, 255); font-family: Menlo, Monaco, &amp;amp;quot;Courier New&amp;amp;quot;, monospace; line-height: 18px;&amp;quot;&amp;gt;&amp;lt;div&amp;gt;status = (*&amp;lt;span style=&amp;quot;color: #808080;&amp;quot;&amp;gt;tr&amp;lt;/span&amp;gt;-&amp;amp;gt;send_msg)(&amp;lt;span style=&amp;quot;color: #808080;&amp;quot;&amp;gt;tr&amp;lt;/span&amp;gt;, &amp;lt;span style=&amp;quot;color: #808080;&amp;quot;&amp;gt;tdata&amp;lt;/span&amp;gt;,  &amp;lt;span style=&amp;quot;color: #808080;&amp;quot;&amp;gt;addr&amp;lt;/span&amp;gt;, &amp;lt;span style=&amp;quot;color: #808080;&amp;quot;&amp;gt;addr_len&amp;lt;/span&amp;gt;, (&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;void&amp;lt;/span&amp;gt;*)&amp;lt;span style=&amp;quot;color: #808080;&amp;quot;&amp;gt;tdata&amp;lt;/span&amp;gt;, &amp;lt;/div&amp;gt;&amp;lt;div&amp;gt;                             &amp;amp;amp;&amp;lt;span style=&amp;quot;color: #74531f;&amp;quot;&amp;gt;transport_send_callback&amp;lt;/span&amp;gt;);&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;1609\&quot; y=\&quot;1840\&quot; width=\&quot;221\&quot; height=\&quot;160\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n      &lt;/root&gt;\n    &lt;/mxGraphModel&gt;\n  &lt;/diagram&gt;\n&lt;/mxfile&gt;\n&quot;}"></div>
<script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
</body>
</html><div style="break-before: page; page-break-before: always;"></div><h1 id="发送数据全流程"><a class="header" href="#发送数据全流程">发送数据全流程</a></h1>
<h2 id="1发送的线程在声音设备端直接获取声卡数据"><a class="header" href="#1发送的线程在声音设备端直接获取声卡数据">1、发送的线程（在声音设备端直接获取声卡数据）</a></h2>
<p>先看发送的线程 ca_thread_func，这里我们以alsa_dev为例</p>
<pre><code class="language-c">static int ca_thread_func (void *arg)
{
    struct alsa_stream* stream = (struct alsa_stream*) arg;
    snd_pcm_t* pcm             = stream-&gt;ca_pcm;
    int size                   = stream-&gt;ca_buf_size;
    snd_pcm_uframes_t nframes  = stream-&gt;ca_frames;
    void* user_data            = stream-&gt;user_data;
    char* buf                  = stream-&gt;ca_buf;
    pj_timestamp tstamp;
    int result;
    struct sched_param param;
    pthread_t* thid;

    thid = (pthread_t*) pj_thread_get_os_handle (pj_thread_this());
    param.sched_priority = sched_get_priority_max (SCHED_RR);
    PJ_LOG (5,(THIS_FILE, "ca_thread_func(%u): Set thread priority "
                          "for audio capture thread.",
                          (unsigned)syscall(SYS_gettid)));
    result = pthread_setschedparam (*thid, SCHED_RR, &amp;param);
    if (result) {
        if (result == EPERM)
            PJ_LOG (5,(THIS_FILE, "Unable to increase thread priority, "
                                  "root access needed."));
        else
            PJ_LOG (5,(THIS_FILE, "Unable to increase thread priority, "
                                  "error: %d",
                                  result));
    }

    pj_bzero (buf, size);
    tstamp.u64 = 0;

    TRACE_((THIS_FILE, "ca_thread_func(%u): Started",
            (unsigned)syscall(SYS_gettid)));

    snd_pcm_prepare (pcm);

    while (!stream-&gt;quit) {
        pjmedia_frame frame;

        pj_bzero (buf, size);
        result = snd_pcm_readi (pcm, buf, nframes);
        if (result == -EPIPE) {
            PJ_LOG (4,(THIS_FILE, "ca_thread_func: overrun!"));
            snd_pcm_prepare (pcm);
            continue;
        } else if (result &lt; 0) {
            PJ_LOG (4,(THIS_FILE, "ca_thread_func: error reading data!"));
        }
        if (stream-&gt;quit)
            break;

        frame.type = PJMEDIA_FRAME_TYPE_AUDIO;
        frame.buf = (void*) buf;
        frame.size = size;
        frame.timestamp.u64 = tstamp.u64;
        frame.bit_info = 0;

        result = stream-&gt;ca_cb (user_data, &amp;frame);
        if (result != PJ_SUCCESS || stream-&gt;quit)
            break;

        tstamp.u64 += nframes;
    }
    snd_pcm_drop(pcm);
    TRACE_((THIS_FILE, "ca_thread_func: Stopped"));

    return PJ_SUCCESS;
}
</code></pre>
<p>该线程的主体部分在不停的while循环，我们来看一次循环的内容：</p>
<p>调用 <code>snd_pcm_readi (pcm, buf, nframes);</code> 读网卡的数据到buf中。然后将读出的数据和一系列属性包装成一个frame。然后调用<code>stream-&gt;ca_cb (user_data, &amp;frame);</code></p>
<p>在初始化（pjmedia_aud_stream_create-&gt;f-&gt;op-&gt;create_stream）中我们知道stream-&gt;ca_cb 我们设置为 <code>rec_cb</code> 接下来我们来看<code>rec_cb</code>  在sound_port.c中.</p>
<p>另外我们需要知道<code>ca_cb</code> 中的<code>user_data</code> 到底是什么 这可以看我们之前初始化流程的分析：pjmedia_snd_port_create-》pjmedia_snd_port_create2-》start_sound_device-》pjmedia_aud_stream_create-》f-&gt;op-&gt;create_stream-》alsa_factory_create_stream</p>
<p>到pjmedia_aud_stream_create这步我们看出user_data是我们创建的<code>snd_port</code></p>
<h2 id="2rec_cb-音频流端"><a class="header" href="#2rec_cb-音频流端">2、rec_cb （音频流端）</a></h2>
<pre><code class="language-c">/*
 * The callback called by sound recorder when it has finished capturing a
 * frame.
 */
static pj_status_t rec_cb(void *user_data, pjmedia_frame *frame)
{
    pjmedia_snd_port *snd_port = (pjmedia_snd_port*) user_data;
    pjmedia_port *port;

    pjmedia_clock_src_update(&amp;snd_port-&gt;cap_clocksrc, &amp;frame-&gt;timestamp);

    /* Invoke preview callback */
    if (snd_port-&gt;on_rec_frame)
        (*snd_port-&gt;on_rec_frame)(snd_port-&gt;user_data, frame);

    port = snd_port-&gt;port;
    if (port == NULL)
        return PJ_SUCCESS;

    /* Cancel echo */
    if (snd_port-&gt;ec_state &amp;&amp; !snd_port-&gt;ec_suspended) {
        pjmedia_echo_capture(snd_port-&gt;ec_state, (pj_int16_t*) frame-&gt;buf, 0);
    }

    pjmedia_port_put_frame(port, frame);


    return PJ_SUCCESS;
}
</code></pre>
<p>首先看<code>snd_port-&gt;on_rec_frame</code>这个是可选项，这里没有使用</p>
<p>其次就是最重要的调用pjmedia_port_put_frame，看一下这里的port参数，<code>port = snd_port-&gt;port;</code>  是pjmedia_snd_port类型snd_port中的pjmedia_port类型属性，snd_port-&gt;port是在<code>pjmedia_snd_port_connect</code>中初始化的先看一下pjmedia_snd_port_connect</p>
<pre><code class="language-c">/*
 * Connect a port.
 */
PJ_DEF(pj_status_t) pjmedia_snd_port_connect( pjmedia_snd_port *snd_port,
                                              pjmedia_port *port)
{
    pjmedia_audio_format_detail *afd;

    PJ_ASSERT_RETURN(snd_port &amp;&amp; port, PJ_EINVAL);

    afd = pjmedia_format_get_audio_format_detail(&amp;port-&gt;info.fmt, PJ_TRUE);

    /* Check that port has the same configuration as the sound device
     * port.
     */
    if (afd-&gt;clock_rate != snd_port-&gt;clock_rate)
        return PJMEDIA_ENCCLOCKRATE;

    if (PJMEDIA_AFD_SPF(afd) != snd_port-&gt;samples_per_frame)
        return PJMEDIA_ENCSAMPLESPFRAME;

    if (afd-&gt;channel_count != snd_port-&gt;channel_count)
        return PJMEDIA_ENCCHANNEL;

    if (afd-&gt;bits_per_sample != snd_port-&gt;bits_per_sample)
        return PJMEDIA_ENCBITS;

    /* Port is okay. */
    snd_port-&gt;port = port;
    return PJ_SUCCESS;
}
</code></pre>
<p>注意这里的参数<code>pjmedia_port *port</code>来自pjmedia_stream stream的port，这个port还有一点特殊即port-&gt;port_data.pdata; 其实是指向stream，即stream中有port，port也有办法指向stream，这在put_frame中会遇到。</p>
<p>&lt;::&gt;再回来看pjmedia_port_put_frame该函数其实是port-&gt;put_frame callback的封装，会直接调用port-&gt;put_frame，这个回调函数的初始化在<code>pjmedia_stream_create</code> 完成将port-&gt;put_frame 初始化为 stream-&gt;port.put_frame = &amp;put_frame;，所以接下来我们看put_frame</p>
<pre><code class="language-c">
/**
 * Put a frame to the port (and subsequent downstream ports).
 */
PJ_DEF(pj_status_t) pjmedia_port_put_frame( pjmedia_port *port,
                                            pjmedia_frame *frame )
{
    PJ_ASSERT_RETURN(port &amp;&amp; frame, PJ_EINVAL);

    if (port-&gt;put_frame)
        return port-&gt;put_frame(port, frame);
    else
        return PJ_EINVALIDOP;
}
</code></pre>
<h2 id="3put_frame-port端"><a class="header" href="#3put_frame-port端">3、put_frame （port端）</a></h2>
<pre><code class="language-c">/**
 * put_frame()
 *
 * This callback is called by upstream component when it has PCM frame
 * to transmit. This function encodes the PCM frame, pack it into
 * RTP packet, and transmit to peer.
 */
static pj_status_t put_frame( pjmedia_port *port,
                              pjmedia_frame *frame )
{
    pjmedia_stream *stream = (pjmedia_stream*) port-&gt;port_data.pdata;
    pjmedia_frame tmp_zero_frame;
    unsigned samples_per_frame;

    samples_per_frame = stream-&gt;enc_samples_per_pkt;

    /* https://github.com/pjsip/pjproject/issues/56:
     *  when input is PJMEDIA_FRAME_TYPE_NONE, feed zero PCM frame
     *  instead so that encoder can decide whether or not to transmit
     *  silence frame.
     */
    if (frame-&gt;type == PJMEDIA_FRAME_TYPE_NONE) {
        pj_memcpy(&amp;tmp_zero_frame, frame, sizeof(pjmedia_frame));
        frame = &amp;tmp_zero_frame;

        tmp_zero_frame.buf = NULL;
        tmp_zero_frame.size = samples_per_frame * 2;
        tmp_zero_frame.type = PJMEDIA_FRAME_TYPE_AUDIO;
    }

    /* If VAD is temporarily disabled during creation, enable it
     * after transmitting for VAD_SUSPEND_SEC seconds.
     */
    if (stream-&gt;vad_enabled != stream-&gt;codec_param.setting.vad &amp;&amp;
        (stream-&gt;tx_duration - stream-&gt;ts_vad_disabled) &gt;
           PJMEDIA_PIA_SRATE(&amp;stream-&gt;port.info) *
          PJMEDIA_STREAM_VAD_SUSPEND_MSEC / 1000)
    {
        stream-&gt;codec_param.setting.vad = stream-&gt;vad_enabled;
        pjmedia_codec_modify(stream-&gt;codec, &amp;stream-&gt;codec_param);
        PJ_LOG(4,(stream-&gt;port.info.name.ptr,"VAD re-enabled"));
    }


    /* If encoder has different ptime than decoder, then the frame must
     * be passed through the encoding buffer via rebuffer() function.
     */
    if (stream-&gt;enc_buf != NULL) {
        pjmedia_frame tmp_rebuffer_frame;
        pj_status_t status = PJ_SUCCESS;

        /* Copy original frame to temporary frame since we need
         * to modify it.
         */
        pj_memcpy(&amp;tmp_rebuffer_frame, frame, sizeof(pjmedia_frame));

        /* Loop while we have full frame in enc_buffer */
        for (;;) {
            pj_status_t st;

            /* Run rebuffer() */
            rebuffer(stream, &amp;tmp_rebuffer_frame);

            /* Process this frame */
            st = put_frame_imp(port, &amp;tmp_rebuffer_frame);
            if (st != PJ_SUCCESS)
                status = st;

            /* If we still have full frame in the buffer, re-run
             * rebuffer() with NULL frame.
             */
            if (stream-&gt;enc_buf_count &gt;= stream-&gt;enc_samples_per_pkt) {

                tmp_rebuffer_frame.type = PJMEDIA_FRAME_TYPE_NONE;

            } else {

                /* Otherwise break */
                break;
            }
        }

        return status;

    } else {
        return put_frame_imp(port, frame);
    }
}
</code></pre>
<p>重点看一下<code>put_frame_imp</code> 对frame的处理，函数比较长，我们来分段看一下</p>
<ol>
<li>
<p>函数开始时，从 <code>port</code> 参数中获取了指向 <code>pjmedia_stream</code> 结构的指针 <code>stream</code>，并且从 <code>stream</code> 中获取了编码通道 <code>enc</code>。</p>
<pre><code class="language-c">    pjmedia_stream *stream = (pjmedia_stream*) port-&gt;port_data.pdata;
    pjmedia_channel *channel = stream-&gt;enc;
</code></pre>
</li>
<li>
<p>如果流启用了保活机制，函数会检查距离上次发送数据包的时间间隔，如果超过了指定的保活间隔，会发送一个保活数据包。</p>
</li>
<li>
<p>然后，函数会根据帧的类型计算帧中的样本数 <code>ts_len</code>，并根据是否存在特定的编码器问题来确定 RTP 时间戳的长度 <code>rtp_ts_len</code>。</p>
<pre><code class="language-c">    /* Number of samples in the frame */
    if (frame-&gt;type == PJMEDIA_FRAME_TYPE_AUDIO)
        ts_len = ((unsigned)frame-&gt;size &gt;&gt; 1) /
                 stream-&gt;codec_param.info.channel_cnt;
    else if (frame-&gt;type == PJMEDIA_FRAME_TYPE_EXTENDED)
        ts_len = PJMEDIA_PIA_SPF(&amp;stream-&gt;port.info) /
                 PJMEDIA_PIA_CCNT(&amp;stream-&gt;port.info);
    else
        ts_len = 0;

#if defined(PJMEDIA_HANDLE_G722_MPEG_BUG) &amp;&amp; (PJMEDIA_HANDLE_G722_MPEG_BUG!=0)
    /* Handle special case for audio codec with RTP timestamp inconsistence
     * e.g: G722, MPEG audio.
     */
    if (stream-&gt;has_g722_mpeg_bug)
        rtp_ts_len = stream-&gt;rtp_tx_ts_len_per_pkt;
    else
        rtp_ts_len = ts_len;
#else
    rtp_ts_len = ts_len;
#endif
</code></pre>
</li>
<li>
<p>如果编码通道被暂停，函数会更新 RTP 会话的时间戳，并在需要时发送 RTCP SR/RR 报告。</p>
<pre><code class="language-c">    /* Don't do anything if stream is paused, except updating RTP timestamp */
    if (channel-&gt;paused) {
        stream-&gt;enc_buf_pos = stream-&gt;enc_buf_count = 0;

        /* Update RTP session's timestamp. */
        status = pjmedia_rtp_encode_rtp( &amp;channel-&gt;rtp, 0, 0, 0, rtp_ts_len,
                                         NULL, NULL);

        /* Update RTCP stats with last RTP timestamp. */
        stream-&gt;rtcp.stat.rtp_tx_last_ts = pj_ntohl(channel-&gt;rtp.out_hdr.ts);

        /* Check if now is the time to transmit RTCP SR/RR report.
         * We only do this when the decoder is paused,
         * because otherwise check_tx_rtcp() will be handled by on_rx_rtp().
         */
        if (stream-&gt;dec-&gt;paused) {
            check_tx_rtcp(stream, pj_ntohl(channel-&gt;rtp.out_hdr.ts));
        }

        return PJ_SUCCESS;
    }
</code></pre>
</li>
<li>
<p>接着，函数会增加传输时长，初始化输出帧缓冲区，并检查是否有 DTMF 数字在队列中，如果有则发送数字，否则对音频帧进行编码。</p>
<pre><code class="language-c">	  if (stream-&gt;tx_dtmf_count) {
        int first=0, last=0;

        create_dtmf_payload(stream, &amp;frame_out, 0, &amp;first, &amp;last);

        /* Encapsulate into RTP packet. Note that:
         *  - RTP marker should be set on the beginning of a new event
         *  - RTP timestamp is constant for the same packet.
         */
        status = pjmedia_rtp_encode_rtp( &amp;channel-&gt;rtp,
                                         stream-&gt;tx_event_pt, first,
                                         (int)frame_out.size,
                                         (first ? rtp_ts_len : 0),
                                         (const void**)&amp;rtphdr,
                                         &amp;rtphdrlen);

        if (last) {
            /* This is the last packet for the event.
             * Increment the RTP timestamp of the RTP session, for next
             * RTP packets.
             */
            inc_timestamp = stream-&gt;dtmf_duration +
                            ((DTMF_EBIT_RETRANSMIT_CNT-1) *
                             stream-&gt;rtp_tx_ts_len_per_pkt)
                            - rtp_ts_len;
        }

    } 
</code></pre>
</li>
<li>
<p>如果音频帧的缓冲区为空，则发送一段静音，保持 NAT 绑定。</p>
<pre><code class="language-c">	else if (frame-&gt;type == PJMEDIA_FRAME_TYPE_AUDIO &amp;&amp;
               frame-&gt;buf == NULL &amp;&amp;
               stream-&gt;port.info.fmt.id == PJMEDIA_FORMAT_L16 &amp;&amp;
               (stream-&gt;dir &amp; PJMEDIA_DIR_ENCODING))
    {
        pjmedia_frame silence_frame;

        pj_bzero(&amp;silence_frame, sizeof(silence_frame));
        silence_frame.buf = stream-&gt;zero_frame;
        silence_frame.size = stream-&gt;enc_samples_per_pkt * 2;
        silence_frame.type = PJMEDIA_FRAME_TYPE_AUDIO;
        silence_frame.timestamp.u32.lo = pj_ntohl(stream-&gt;enc-&gt;rtp.out_hdr.ts);

        /* Encode! */
        status = pjmedia_codec_encode( stream-&gt;codec, &amp;silence_frame,
                                       channel-&gt;out_pkt_size -
                                       sizeof(pjmedia_rtp_hdr),
                                       &amp;frame_out);
        if (status != PJ_SUCCESS) {
            LOGERR_((stream-&gt;port.info.name.ptr, status,
                    "Codec encode() error"));
            return status;
        }

        /* Encapsulate. */
        status = pjmedia_rtp_encode_rtp( &amp;channel-&gt;rtp,
                                         channel-&gt;pt, 0,
                                         (int)frame_out.size, rtp_ts_len,
                                         (const void**)&amp;rtphdr,
                                         &amp;rtphdrlen);

    
} 
</code></pre>
</li>
<li>
<p>如果音频帧不为空，则对音频帧进行编码，并将 RTP 头封装到输出包中。</p>
<pre><code class="language-c">else if ((frame-&gt;type == PJMEDIA_FRAME_TYPE_AUDIO &amp;&amp;
                frame-&gt;buf != NULL) ||
               (frame-&gt;type == PJMEDIA_FRAME_TYPE_EXTENDED))
    {
        /* Encode! */
        status = pjmedia_codec_encode( stream-&gt;codec, frame,
                                       channel-&gt;out_pkt_size -
                                       sizeof(pjmedia_rtp_hdr),
                                       &amp;frame_out);
        if (status != PJ_SUCCESS) {
            LOGERR_((stream-&gt;port.info.name.ptr, status,
                    "Codec encode() error"));
            return status;
        }

        /* Encapsulate. */
        status = pjmedia_rtp_encode_rtp( &amp;channel-&gt;rtp,
                                         channel-&gt;pt, 0,
                                         (int)frame_out.size, rtp_ts_len,
                                         (const void**)&amp;rtphdr,
                                         &amp;rtphdrlen);

    } 
</code></pre>
</li>
<li>
<p>最后，函数会根据当前是否正在流式传输来设置 RTP 标记位，并将 RTP 包发送到传输层。</p>
<pre><code class="language-c">
    /* Copy RTP header to the beginning of packet */
    pj_memcpy(channel-&gt;out_pkt, rtphdr, sizeof(pjmedia_rtp_hdr));

    /* Special case for DTMF: timestamp remains constant for
     * the same event, and is only updated after a complete event
     * has been transmitted.
     */
    if (inc_timestamp) {
        pjmedia_rtp_encode_rtp( &amp;channel-&gt;rtp, stream-&gt;tx_event_pt, 0,
                                0, inc_timestamp, NULL, NULL);
    }

    /* Set RTP marker bit if currently not streaming */
    if (stream-&gt;is_streaming == PJ_FALSE) {
        pjmedia_rtp_hdr *rtp = (pjmedia_rtp_hdr*) channel-&gt;out_pkt;

        rtp-&gt;m = 1;
        PJ_LOG(5,(stream-&gt;port.info.name.ptr,"Start talksprut.."));
    }

    stream-&gt;is_streaming = PJ_TRUE;

    /* Send the RTP packet to the transport. */
    status = pjmedia_transport_send_rtp(stream-&gt;transport, channel-&gt;out_pkt,
                                        frame_out.size +
                                            sizeof(pjmedia_rtp_hdr));
</code></pre>
</li>
<li>
<p>在发送 RTP 包之后，函数会更新一些统计信息，并且如果启用了保活机制，则记录最后发送数据包的时间。</p>
</li>
</ol>
<p>我们来仔细梳理一下rtp包发送的流程</p>
<p>（1）先设置frame_out.buf 对应的偏置 <code>((char*)channel-&gt;out_pkt) + sizeof(pjmedia_rtp_hdr);</code></p>
<p>（2）调用pjmedia_codec_encode，对frame编码结果输出到frame_out中，此时frame_out.buf获取到rtp payload，相应地(char*)channel-&gt;out_pkt) + sizeof(pjmedia_rtp_hdr处获取到rtp payload</p>
<p>（3）添加rtp头部，调用pjmedia_rtp_encode_rtp，hannel-&gt;rtp-&gt;out_hdr，并将头部拷贝至(char*)channel-&gt;out_pkt)处，至此channel-&gt;out_pkt存放地为编码后的rtp包</p>
<p>（4）Send the RTP packet to the transport. 调用pjmedia_transport_send_rtp</p>
<p>我们就主要看pjmedia_transport_send_rtp了，其实就是op-&gt;send_rtp 的封装，由初始化可知send_rtp为transport_send_rtcp</p>
<pre><code class="language-c">PJ_INLINE(pj_status_t) pjmedia_transport_send_rtp(pjmedia_transport *tp,
                                                  const void *pkt,
                                                  pj_size_t size)
{
    return (*tp-&gt;op-&gt;send_rtp)(tp, pkt, size);
}

</code></pre>
<h2 id="4transport_send_rtp"><a class="header" href="#4transport_send_rtp">4、transport_send_rtp</a></h2>
<p>直接调用transport_send_rtcp2</p>
<pre><code class="language-c">/* Called by application to send RTP packet */
static pj_status_t transport_send_rtp( pjmedia_transport *tp,
                                       const void *pkt,
                                       pj_size_t size)
{
    struct transport_udp *udp = (struct transport_udp*)tp;
    pj_ssize_t sent;
    unsigned id;
    struct pending_write *pw;
    pj_status_t status;

    /* Must be attached */
    //PJ_ASSERT_RETURN(udp-&gt;attached, PJ_EINVALIDOP);

    /* Check that the size is supported */
    PJ_ASSERT_RETURN(size &lt;= PJMEDIA_MAX_MTU, PJ_ETOOBIG);

    if (!udp-&gt;started) {
        return PJ_SUCCESS;
    }

    /* Simulate packet lost on TX direction */
    if (udp-&gt;tx_drop_pct) {
        if ((pj_rand() % 100) &lt;= (int)udp-&gt;tx_drop_pct) {
            PJ_LOG(5,(udp-&gt;base.name, 
                      "TX RTP packet dropped because of pkt lost "
                      "simulation"));
            return PJ_SUCCESS;
        }
    }


    id = udp-&gt;rtp_write_op_id;
    pw = &amp;udp-&gt;rtp_pending_write[id];
    if (pw-&gt;is_pending) {
        /* There is still currently pending operation for this buffer. */
        PJ_LOG(4,(udp-&gt;base.name, "Too many pending write operations"));
        return PJ_EBUSY;
    }
    pw-&gt;is_pending = PJ_TRUE;

    /* We need to copy packet to our buffer because when the
     * operation is pending, caller might write something else
     * to the original buffer.
     */
    pj_memcpy(pw-&gt;buffer, pkt, size);

    sent = size;
    status = pj_ioqueue_sendto( udp-&gt;rtp_key, 
                                &amp;udp-&gt;rtp_pending_write[id].op_key,
                                pw-&gt;buffer, &amp;sent, 0,
                                &amp;udp-&gt;rem_rtp_addr, 
                                udp-&gt;addr_len);

    if (status != PJ_EPENDING) {
        /* Send operation has completed immediately. Clear the flag. */
        pw-&gt;is_pending = PJ_FALSE;
    }

    udp-&gt;rtp_write_op_id = (udp-&gt;rtp_write_op_id + 1) %
                           PJ_ARRAY_SIZE(udp-&gt;rtp_pending_write);

    if (status==PJ_SUCCESS || status==PJ_EPENDING)
        return PJ_SUCCESS;

    return status;
}
</code></pre>
<p>udp-&gt;rtp_write_op_id;是当前write操作可用的id，udp-&gt;rtp_pending_write是Pending write对象用于指示udp-&gt;rtp_pending_write[udp-&gt;rtp_write_op_id]是否有pending的write 操作如果有pending 返回。没有的话将该id处置为pending <code>pw-&gt;is_pending = PJ_TRUE; </code> 调用pj_ioqueue_sendto  最后需要将id+1</p>
<h2 id="5pj_ioqueue_sendto"><a class="header" href="#5pj_ioqueue_sendto">5、pj_ioqueue_sendto</a></h2>
<p>参数key来着 udp-&gt;rtp_key 在 pj_ioqueue_register_sock2中初始化，绑定到rtp socket</p>
<p>参数op_key来自 transport_udp::udp-&gt;rtp_pending_write[id].op_key，在transport_media_start中设置为空</p>
<p>如果key对应的writelist不为空，直接发送调用pj_sock_sendto</p>
<pre><code class="language-c">	 if (pj_list_empty(&amp;key-&gt;write_list)) {
        /*
         * See if data can be sent immediately.
         */
        sent = *length;
        status = pj_sock_sendto(key-&gt;fd, data, &amp;sent, flags, addr, addrlen);
        
    }
</code></pre>
<p>否则初始化write_operation:: write_op 主要需要将要发送的rtp数据保存在write_op中，然后挂在key对应的writelist队列上</p>
<pre><code class="language-c">		write_op-&gt;op = PJ_IOQUEUE_OP_SEND_TO;
    write_op-&gt;buf = (char*)data;
    write_op-&gt;size = *length;
    write_op-&gt;written = 0;
    write_op-&gt;flags = flags;
    pj_memcpy(&amp;write_op-&gt;rmt_addr, addr, addrlen);
    write_op-&gt;rmt_addrlen = addrlen;
    
    pj_ioqueue_lock_key(key);
    /* Check again. Handle may have been closed after the previous check
     * in multithreaded app. If we add bad handle to the set it will
     * corrupt the ioqueue set. See #913
     */
    if (IS_CLOSING(key)) {
        pj_ioqueue_unlock_key(key);
        return PJ_ECANCELLED;
    }
    pj_list_insert_before(&amp;key-&gt;write_list, write_op);
</code></pre>
<p>调用ioqueue_add_to_set进而调用ioqueue_add_to_set2</p>
<pre><code class="language-c">static void ioqueue_add_to_set2(pj_ioqueue_t *ioqueue,
                                pj_ioqueue_key_t *key,
                                unsigned event_types )
{
    pj_uint32_t events = key-&gt;ev.events;

    if (event_types &amp; READABLE_EVENT)
        events |= EPOLLIN;
    if (event_types &amp; WRITEABLE_EVENT)
        events |= EPOLLOUT;
    if (event_types &amp; EXCEPTION_EVENT)
        events |= EPOLLERR;

    if (events != key-&gt;ev.events)
        update_epoll_event_set(ioqueue, key, events);
}
</code></pre>
<p>根据 event_types 设置 events 调用 update_epoll_event_set  这里event_types是WRITEABLE_EVENT</p>
<pre><code class="language-c">static void update_epoll_event_set(pj_ioqueue_t *ioqueue,
                                   pj_ioqueue_key_t *key,
                                   pj_uint32_t events)
{
    int rc;
    /* From epoll_ctl(2):
     * EPOLLEXCLUSIVE may be used only in an EPOLL_CTL_ADD operation;
     * attempts to employ it with EPOLL_CTL_MOD yield an error.
     */
    if (key-&gt;ev.events &amp; EPOLLEXCLUSIVE) {
        rc = os_epoll_ctl(ioqueue-&gt;epfd, EPOLL_CTL_DEL, key-&gt;fd, &amp;key-&gt;ev);
        key-&gt;ev.events = events;
        rc = os_epoll_ctl(ioqueue-&gt;epfd, EPOLL_CTL_ADD, key-&gt;fd, &amp;key-&gt;ev);
    } else {
        key-&gt;ev.events = events;
        rc = os_epoll_ctl(ioqueue-&gt;epfd, EPOLL_CTL_MOD, key-&gt;fd, &amp;key-&gt;ev);
    }

    if (rc != 0) {
        pj_status_t status = pj_get_os_error();
        PJ_PERROR(1,(THIS_FILE, status,
                     "epol_ctl(MOD) error (events=0x%x)", events));
    }
}
</code></pre>
<p>这里修改监测rtp socket事件EPOLL_CTL_MOD修改为EPOLLOUT 触发</p>
<h2 id="6ioqueue_epoll参与"><a class="header" href="#6ioqueue_epoll参与">6、ioqueue_epoll参与</a></h2>
<p>这里不一定是上述追踪的rtp包</p>
<p>当pj_ioqueue_poll工作线程 调用os_epoll_wait 发现监测的EPOLLOUT写触发，调用ioqueue_dispatch_write_event写操作，在ioqueue_dispatch_write_event中先看key write_list上有没有pending_write,有的话，从write_list取出，根据write_list的 write_op确定写大小，要写入的数据，将数据写入调用pj_sock_send函数Transmit data to the socket.，最后调用on_write_complete，回调函数已在pj_ioqueue_register_sock2时设置过，传入write_op为on_rtp_data_sent</p>
<pre><code class="language-c">if (h-&gt;cb.on_write_complete &amp;&amp; !IS_CLOSING(h)) {
                (*h-&gt;cb.on_write_complete)(h, 
                                           (pj_ioqueue_op_key_t*)write_op,
                                           write_op-&gt;written);
            }
</code></pre>
<pre><code class="language-c">static void on_rtp_data_sent(pj_ioqueue_key_t *key, 
                             pj_ioqueue_op_key_t *op_key, 
                             pj_ssize_t bytes_sent)
{
    struct transport_udp *udp;
    unsigned i;

    PJ_UNUSED_ARG(bytes_sent);

    udp = (struct transport_udp*) pj_ioqueue_get_user_data(key);

    for (i = 0; i &lt; PJ_ARRAY_SIZE(udp-&gt;rtp_pending_write); ++i) {
        if (&amp;udp-&gt;rtp_pending_write[i].op_key == op_key) {
            udp-&gt;rtp_pending_write[i].is_pending = PJ_FALSE;
            break;
        }
    }
}
</code></pre>
<p>遍历transport_udp udp中的rtp_pending_write 找到与目标 op_key一致的位置，将is_pending置为false完成</p>
<h2 id="附相互指向关系"><a class="header" href="#附相互指向关系">附：相互指向关系</a></h2>
<p>stream.user_data-》snd_port，</p>
<p>snd_port.port-》port</p>
<p>port-&gt;port_data.pdata;-》stream</p>
<p>stream-&gt;transport-》pjmedia_transport</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="接收数据过程"><a class="header" href="#接收数据过程">接收数据过程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="初始化全流程思考"><a class="header" href="#初始化全流程思考">初始化全流程思考</a></h2>
<p>一个transport 一个 stream一个port两个channel，</p>
<p><img src="img/20190917203551691.png" alt="img" /></p>
<p>一、再开启invite session之前</p>
<ol>
<li>创建media endpoint</li>
<li>创建transport放在g_med_transport数组，注册绑定socket</li>
</ol>
<p>二、loop处理sip事件</p>
<p>三、SDP协商完后回调</p>
<ol>
<li>
<p>创建stream，先获取stream_info（从sdp协商中pjmedia_stream_info_from_sdp）</p>
<ul>
<li>
<p>1、申请媒体流空间</p>
<p>2、初始化流的若干参数</p>
<p>3、codec管理者及codec相关的操作</p>
<p>4、设置第一组回调put_frame和get_frame，这组回调是音频设备port要用的</p>
<p>5、创建jitterbuffer，这个后面会单独讲</p>
<p>6、创建编码通道和解码通道</p>
<p>7、调用上一节中提到的媒体传输attach，传入第2组回调on_rx_rtp和on_rx_rtcp</p>
</li>
</ul>
</li>
<li>
<p>pjmedia_stream_start，channel开，Start the audio stream</p>
<p>编码通道和解码通道pause =0；</p>
</li>
<li>
<p>pjmedia_transport_media_start，UDP media transport开</p>
<p>Start the audio stream，tp-&gt;start = 1</p>
</li>
<li>
<p>port创建，创建设备，开启设备  Open audio stream object</p>
</li>
</ol>
<p>Callback when SDP negotiation has completed.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ioqueue_epoll"><a class="header" href="#ioqueue_epoll">ioqueue_epoll</a></h2>
<h3 id="pj_ioqueue_t"><a class="header" href="#pj_ioqueue_t">pj_ioqueue_t</a></h3>
<p>ioqueue的整体结构pj_ioqueue_t，使用epoll的在ioqueue_epoll.c  下列出ioqueue相关的<code>DECLARE_COMMON_IOQUEUE宏</code>、<code>pj_ioqueue_cfg</code>、<code>pj_ioqueue_t</code></p>
<pre><code class="language-c">#define DECLARE_COMMON_IOQUEUE                      \
    pj_lock_t          *lock;                       \
    pj_bool_t           auto_delete_lock;           \
    pj_ioqueue_cfg      cfg;

/**
 * Additional settings that can be given during ioqueue creation. Application
 * MUST initialize this structure with #pj_ioqueue_cfg_default().
 */
typedef struct pj_ioqueue_cfg
{
    /**
     * Specify flags to control e.g. how events are handled when epoll backend
     * is used on Linux. The values are combination of pj_ioqueue_epoll_flag.
     * The default value is PJ_IOQUEUE_DEFAULT_EPOLL_FLAGS, which by default
     * is set to PJ_IOQUEUE_EPOLL_AUTO. This setting will be ignored for other
     * ioqueue backends.
     */
    unsigned  epoll_flags;

    /**
     * Default concurrency for the handles registered to this ioqueue. Setting
     * this to non-zero enables a handle to process more than one operations
     * at the same time using different threads. Default is
     * PJ_IOQUEUE_DEFAULT_ALLOW_CONCURRENCY. This setting is equivalent to
     * calling pj_ioqueue_set_default_concurrency() after creating the ioqueue.
     */
    pj_bool_t default_concurrency;

} pj_ioqueue_cfg;

/*
 * This describes the I/O queue.
 */
struct pj_ioqueue_t
{
    DECLARE_COMMON_IOQUEUE

    unsigned            max, count;
    //pj_ioqueue_key_t  hlist;
    pj_ioqueue_key_t    active_list;    
    int                 epfd;
    //struct epoll_event *events;
    //struct queue       *queue;

#if PJ_IOQUEUE_HAS_SAFE_UNREG
    pj_mutex_t         *ref_cnt_mutex;
    pj_ioqueue_key_t    closing_list;
    pj_ioqueue_key_t    free_list;
#endif
};
</code></pre>
<p>有三个 pj_ioqueue_key_t类型的队列active_list、closing_list、free_list，</p>
<h3 id="pj_ioqueue_key_t"><a class="header" href="#pj_ioqueue_key_t">pj_ioqueue_key_t</a></h3>
<pre><code class="language-c">#define DECLARE_COMMON_KEY                          \
    PJ_DECL_LIST_MEMBER(struct pj_ioqueue_key_t);   \
    pj_ioqueue_t           *ioqueue;                \
    pj_grp_lock_t          *grp_lock;               \
    pj_lock_t              *lock;                   \
    pj_bool_t               inside_callback;        \
    pj_bool_t               destroy_requested;      \
    pj_bool_t               allow_concurrent;       \
    pj_sock_t               fd;                     \
    int                     fd_type;                \
    void                   *user_data;              \
    pj_ioqueue_callback     cb;                     \
    int                     connecting;             \
    struct read_operation   read_list;              \
    struct write_operation  write_list;             \
    struct accept_operation accept_list;            \
    UNREG_FIELDS
    
/*
 * This describes each key.
 */
struct pj_ioqueue_key_t
{
    DECLARE_COMMON_KEY
    struct epoll_event ev;
};

</code></pre>
<p>pj_ioqueue_key_t中出现了epoll_event 是linux中结构</p>
<h3 id="epoll_event"><a class="header" href="#epoll_event">epoll_event</a></h3>
<pre><code class="language-c">typedef [union](https://so.csdn.net/so/search?q=union&amp;spm=1001.2101.3001.7020) epoll_data {
    void *ptr;
    int fd;
    __uint32_t u32;
    __uint64_t u64;
} epoll_data_t;//保存触发事件的某个文件描述符相关的数据

struct epoll_event {
    __uint32_t events;   /* [epoll](https://so.csdn.net/so/search?q=epoll&amp;spm=1001.2101.3001.7020) event */
    epoll_data_t data;   /* User data variable */
};
</code></pre>
<h3 id="pj_ioqueue_callback"><a class="header" href="#pj_ioqueue_callback">pj_ioqueue_callback</a></h3>
<p>接下来介绍I/O结束的回调函数</p>
<pre><code class="language-c">/**
 * This structure describes the callbacks to be called when I/O operation
 * completes.
 */
typedef struct pj_ioqueue_callback
{
    /**
     * This callback is called when #pj_ioqueue_recv or #pj_ioqueue_recvfrom
     * completes.
     *
     * @param key           The key.
     * @param op_key        Operation key.
     * @param bytes_read    &gt;= 0 to indicate the amount of data read,
     *                      otherwise negative value containing the error
     *                      code. To obtain the pj_status_t error code, use
     *                      (pj_status_t code = -bytes_read).
     */
    void (*on_read_complete)(pj_ioqueue_key_t *key,
                             pj_ioqueue_op_key_t *op_key,
                             pj_ssize_t bytes_read);

    /**
     * This callback is called when #pj_ioqueue_send or #pj_ioqueue_sendto
     * completes.
     *
     * @param key           The key.
     * @param op_key        Operation key.
     * @param bytes_sent    &gt;= 0 to indicate the amount of data written,
     *                      otherwise negative value containing the error
     *                      code. To obtain the pj_status_t error code, use
     *                      (pj_status_t code = -bytes_sent).
     */
    void (*on_write_complete)(pj_ioqueue_key_t *key,
                              pj_ioqueue_op_key_t *op_key,
                              pj_ssize_t bytes_sent);

    /**
     * This callback is called when #pj_ioqueue_accept completes.
     *
     * @param key           The key.
     * @param op_key        Operation key.
     * @param sock          Newly connected socket.
     * @param status        Zero if the operation completes successfully.
     */
    void (*on_accept_complete)(pj_ioqueue_key_t *key,
                               pj_ioqueue_op_key_t *op_key,
                               pj_sock_t sock,
                               pj_status_t status);

    /**
     * This callback is called when #pj_ioqueue_connect completes.
     *
     * @param key           The key.
     * @param status        PJ_SUCCESS if the operation completes successfully.
     */
    void (*on_connect_complete)(pj_ioqueue_key_t *key,
                                pj_status_t status);
} pj_ioqueue_callback;
</code></pre>
<h3 id="pj_ioqueue_op_key_t"><a class="header" href="#pj_ioqueue_op_key_t">pj_ioqueue_op_key_t</a></h3>
<pre><code class="language-c">typedef struct pj_ioqueue_op_key_t
{
    void *internal__[32];           /**&lt; Internal I/O Queue data.   */
    void *activesock_data;          /**&lt; Active socket data.        */
    void *user_data;                /**&lt; Application data.          */
} pj_ioqueue_op_key_t;
</code></pre>
<h2 id="初始化相关"><a class="header" href="#初始化相关">初始化相关</a></h2>
<h3 id="pj_ioqueue_create2"><a class="header" href="#pj_ioqueue_create2">pj_ioqueue_create2</a></h3>
<p>pj_ioqueue_create（空实现调用pj_ioqueue_create2）</p>
<pre><code class="language-c">status = pj_ioqueue_create( endpt-&gt;pool, PJSIP_MAX_TRANSPORTS, &amp;endpt-&gt;ioqueue);
if (status != PJ_SUCCESS) {
    goto on_error;
}
</code></pre>
<p>初始化ioqueue的空间、ioqueue-&gt;lock、ioqueue-&gt;auto_delete_lock、ioqueue-&gt;cfg（pj_ioqueue_cfg）、ioqueue-&gt;max、ioqueue-&gt;count、ioqueue-&gt;cfg.epoll_flags（epoll type）、ioqueue-&gt;ref_cnt_mutex、ioqueue-&gt;free_list（对max_fd个key初始化key-&gt;ref_count、key-&gt;lock然后加入freelist）、ioqueue-&gt;closing_list、ioqueue-&gt;epfd（epoll fd调用epoll create）</p>
<h3 id="ioqueue_init_key"><a class="header" href="#ioqueue_init_key">ioqueue_init_key</a></h3>
<pre><code class="language-c">static pj_status_t ioqueue_init_key( pj_pool_t *pool,
                                     pj_ioqueue_t *ioqueue,
                                     pj_ioqueue_key_t *key,
                                     pj_sock_t sock,
                                     pj_grp_lock_t *grp_lock,
                                     void *user_data,
                                     const pj_ioqueue_callback *cb)
</code></pre>
<p>初始化key的key-&gt;ioqueue、key-&gt;fd、key-&gt;user_data（这里放到是transport_udp）、key-&gt;read_list、key-&gt;write_list、key-&gt;accept_list、key-&gt;connecting = 0、key-&gt;cb（callback）、key-&gt;closing 、key-&gt;allow_concurrent（pj_ioqueue_set_concurrency）、key-&gt;fd_type、key-&gt;grp_lock</p>
<h3 id="pj_ioqueue_register_sock2"><a class="header" href="#pj_ioqueue_register_sock2">pj_ioqueue_register_sock2</a></h3>
<p>pjmedia_transport_udp_create3-&gt;pjmedia_transport_udp_attach-&gt;pj_ioqueue_register_sock2</p>
<p>os_ioctl 设置socket to nonblocking.</p>
<p>从ioqueue的freelist中取得key，ioqueue_init_key，然后初始化key-&gt;ev（epoll_event类型 data.ptr 是key本身）, os_epoll_ctl注册 fd-events监听其socket事件。</p>
<pre><code class="language-c">PJ_DEF(pj_status_t) pj_ioqueue_register_sock2(pj_pool_t *pool,
                                              pj_ioqueue_t *ioqueue,
                                              pj_sock_t sock,
                                              pj_grp_lock_t *grp_lock,
                                              void *user_data,
                                              const pj_ioqueue_callback *cb,
                                              pj_ioqueue_key_t **p_key)
  
    status = pj_ioqueue_register_sock2(pool, ioqueue, tp-&gt;rtp_sock, grp_lock,
                                       tp, &amp;rtp_cb, &amp;tp-&gt;rtp_key);
</code></pre>
<p>注意在<code>pjmedia_transport_udp_attach</code> 中调用pj_ioqueue_register_sock2传入的是tp-&gt;rtp_key，pj_ioqueue_register_sock2返回后，会将绑定socket后的key保存在rtp_key中</p>
<h2 id="ioqueue-读取写入流程"><a class="header" href="#ioqueue-读取写入流程">ioqueue 读取写入流程</a></h2>
<p>ioqueue 读取全流程</p>
<p>pj_ioqueue_poll，发现事件-》ioqueue_dispatch_read_event-》on_rx_request-》on_rx_request</p>
<h3 id="pj_ioqueue_poll"><a class="header" href="#pj_ioqueue_poll">pj_ioqueue_poll</a></h3>
<p>事件触发后执行主要使用os_epoll_wait，执行分发回调</p>
<p>一般会另开一个工作线程，不停循环，执行epoll_wait以监听读取/写入rtp包的事件请求</p>
<pre><code class="language-c">while(1){
		pj_ioqueue_poll()
}
</code></pre>
<p>下面详细介绍pj_ioqueue_poll</p>
<p>先调用os_epoll_wait，事件放到events中，遍历所有events。根据read,write事件放入到queue中，queue结构如下：</p>
<pre><code class="language-c">struct queue
{
    pj_ioqueue_key_t        *key;
    enum ioqueue_event_type  event_type;
};

enum ioqueue_event_type
{
    NO_EVENT,
    READABLE_EVENT  = 1,
    WRITEABLE_EVENT = 2,
    EXCEPTION_EVENT = 4,
};
</code></pre>
<p>最后在遍历queue，根据事件执行相应的处理函数</p>
<p>READABLE_EVENT：ioqueue_dispatch_read_event</p>
<p>WRITEABLE_EVENT：ioqueue_dispatch_write_event</p>
<p>EXCEPTION_EVENT：ioqueue_dispatch_exception_e</p>
<h3 id="ioqueue_dispatch_read_event-读取操作"><a class="header" href="#ioqueue_dispatch_read_event-读取操作">ioqueue_dispatch_read_event 读取操作</a></h3>
<p>首先要看一下read_operation</p>
<pre><code class="language-c">struct read_operation
{
    PJ_DECL_LIST_MEMBER(struct read_operation);
    pj_ioqueue_operation_e  op;

    void                   *buf;
    pj_size_t               size;
    unsigned                flags;
    pj_sockaddr_t          *rmt_addr;
    int                    *rmt_addrlen;
};
</code></pre>
<pre><code class="language-c">
/**
 * Types of pending I/O Queue operation. This enumeration is only used
 * internally within the ioqueue.
 */
typedef enum pj_ioqueue_operation_e
{
    PJ_IOQUEUE_OP_NONE          = 0,    /**&lt; No operation.          */
    PJ_IOQUEUE_OP_READ          = 1,    /**&lt; read() operation.      */
    PJ_IOQUEUE_OP_RECV          = 2,    /**&lt; recv() operation.      */
    PJ_IOQUEUE_OP_RECV_FROM     = 4,    /**&lt; recvfrom() operation.  */
    PJ_IOQUEUE_OP_WRITE         = 8,    /**&lt; write() operation.     */
    PJ_IOQUEUE_OP_SEND          = 16,   /**&lt; send() operation.      */
    PJ_IOQUEUE_OP_SEND_TO       = 32,   /**&lt; sendto() operation.    */
#if defined(PJ_HAS_TCP) &amp;&amp; PJ_HAS_TCP != 0
    PJ_IOQUEUE_OP_ACCEPT        = 64,   /**&lt; accept() operation.    */
    PJ_IOQUEUE_OP_CONNECT       = 128   /**&lt; connect() operation.   */
#endif  /* PJ_HAS_TCP */
} pj_ioqueue_operation_e;
</code></pre>
<p>众多read_operation会挂在key中<code>struct read_operation   read_list;</code> 上通过<code>key_has_pending_read</code> 判断是否有pending的read操作</p>
<p>具体流程：</p>
<p>先看key read_list上有没有pending_read,有的话，从read_list取出，根据read_list的read_op确定读入大小，pj_sock_recvfrom接受数据的函数，将数据读入到read_op中，最后调用on_read_complete，回调函数已在pj_ioqueue_register_sock2时设置过，传入read_op</p>
<pre><code class="language-c">(*h-&gt;cb.on_read_complete)(h, 
                                      (pj_ioqueue_op_key_t*)read_op,
                                      bytes_read);
</code></pre>
<h3 id="ioqueue_dispatch_write_event写操作"><a class="header" href="#ioqueue_dispatch_write_event写操作">ioqueue_dispatch_write_event写操作</a></h3>
<p>与ioqueue_dispatch_read_event相似，先看write_operation</p>
<pre><code class="language-c">struct write_operation
{
    PJ_DECL_LIST_MEMBER(struct write_operation);
    pj_ioqueue_operation_e  op;

    char                   *buf;
    pj_size_t               size;
    pj_ssize_t              written;
    unsigned                flags;
    pj_sockaddr_in          rmt_addr;
    int                     rmt_addrlen;
};
</code></pre>
<p>众多write_operation会挂在key中<code>struct write_operation  write_list;</code> 上通过<code>key_has_pending_write</code> 判断是否有pending的write操作</p>
<p>具体流程：</p>
<p>先看key write_list上有没有pending_write,有的话，从write_list取出，根据write_list的 write_op确定写大小，要写入的数据，将数据写入调用pj_sock_send函数Transmit data to the socket.，最后调用on_write_complete，回调函数已在pj_ioqueue_register_sock2时设置过，传入write_op</p>
<pre><code class="language-c">if (h-&gt;cb.on_write_complete &amp;&amp; !IS_CLOSING(h)) {
                (*h-&gt;cb.on_write_complete)(h, 
                                           (pj_ioqueue_op_key_t*)write_op,
                                           write_op-&gt;written);
            }
</code></pre>
<h3 id="on_rx_rtp-读取操作"><a class="header" href="#on_rx_rtp-读取操作">on_rx_rtp 读取操作</a></h3>
<p>on_rx_rtp是被下面调用</p>
<pre><code class="language-c">(*h-&gt;cb.on_read_complete)(h, 
                                      (pj_ioqueue_op_key_t*)read_op,
                                      bytes_read);
</code></pre>
<p>这里有一个很有意思的问题，就是read_op 在on_rx_rtp中竟然没有使用，下面来分析一下原因</p>
<pre><code>udp = (struct transport_udp*) pj_ioqueue_get_user_data(key);

</code></pre>
<p>我们的read_op是从readlist中取出的，readlist对于读操作添加是依靠pj_ioqueue_recvfrom函数，在data is not immediately available时将read_op加入readlist</p>
<pre><code class="language-c">read_op-&gt;op = PJ_IOQUEUE_OP_RECV_FROM;
read_op-&gt;buf = buffer;
read_op-&gt;size = *length;
read_op-&gt;flags = flags;
read_op-&gt;rmt_addr = addr;
read_op-&gt;rmt_addrlen = addrlen;

pj_ioqueue_lock_key(key);
/* Check again. Handle may have been closed after the previous check
 * in multithreaded app. If we add bad handle to the set it will
 * corrupt the ioqueue set. See #913
 */
if (IS_CLOSING(key)) {
    pj_ioqueue_unlock_key(key);
    return PJ_ECANCELLED;
}
pj_list_insert_before(&amp;key-&gt;read_list, read_op);
ioqueue_add_to_set(key-&gt;ioqueue, key, READABLE_EVENT);
</code></pre>
<p>这里read_op-&gt;buf = buffer;的buffer，来自udp-&gt;rtp_pkt,相当于直接写入了rtp_pkt,所以不用read_op了。</p>
<p>on_rx_rtp是一个while循环，条件如下status来自pj_ioqueue_recvfrom的结果</p>
<pre><code class="language-c">status != PJ_EPENDING &amp;&amp; status != PJ_ECANCELLED &amp;&amp;
             udp-&gt;started
</code></pre>
<h4 id="call_rtp_cb"><a class="header" href="#call_rtp_cb">call_rtp_cb</a></h4>
<p>在while循环里，先执行call_rtp_cb，设置pjmedia_tp_cb_param param;，调用(*cb2)(&amp;param);cb2由transport_attach2-》tp_attach设置为stream.c ::on_rx_rtp。注意param.pkt = udp-&gt;rtp_pkt;，这里rtp_pkt其实就是ioqueue_dispatch_read_event中read_op-&gt;buf中读到的数据rtp包</p>
<pre><code class="language-c">/* Call RTP cb. */
static void call_rtp_cb(struct transport_udp *udp, pj_ssize_t bytes_read, 
                        pj_bool_t *rem_switch)
{
    void (*cb)(void*,void*,pj_ssize_t);
    void (*cb2)(pjmedia_tp_cb_param*);
    void *user_data;

    cb = udp-&gt;rtp_cb;
    cb2 = udp-&gt;rtp_cb2;
    user_data = udp-&gt;user_data;

    if (cb2) {
        pjmedia_tp_cb_param param;

        param.user_data = user_data;
        param.pkt = udp-&gt;rtp_pkt;
        param.size = bytes_read;
        param.src_addr = &amp;udp-&gt;rtp_src_addr;
        param.rem_switch = PJ_FALSE;
        (*cb2)(&amp;param);
        if (rem_switch)
            *rem_switch = param.rem_switch;
    } else if (cb) {
        (*cb)(user_data, udp-&gt;rtp_pkt, bytes_read);
    }
}
</code></pre>
<p>param.user_data = user_data;  注意这个user_data，是pjmedia_stream *stream</p>
<h4 id="pj_ioqueue_recvfrom"><a class="header" href="#pj_ioqueue_recvfrom">pj_ioqueue_recvfrom</a></h4>
<p>接下来是调用pj_ioqueue_recvfrom，至于为什么明明ioqueue_dispatch_read_event已经读取了数据，此时还在读取数据，是因为可能有新的rtp包到达，pj_ioqueue_recvfrom查看有没有到达的包，如果有就调用pj_sock_recvfrom继续读读到udp-&gt;rtp_pkt，如果没有加到readlist中，返回PJ_EPENDING，结束on_rx_rtp中的while循环。</p>
<h3 id="on_rx_rtpcb2"><a class="header" href="#on_rx_rtpcb2">on_rx_rtp::cb2</a></h3>
<p>Stream.c中的回调 tp_attach中设置该回调</p>
<p>该函数处理接收到的rtp包, 解析成payload和head</p>
<p>Put "good" packet to jitter buffer，需要先把payload解析成frame，再把frame放入jitter buffer</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="epoll学习"><a class="header" href="#epoll学习">epoll学习</a></h2>
<ol>
<li><a href="https://so.csdn.net/so/search?q=struct&amp;spm=1001.2101.3001.7020">struct</a> epoll_event</li>
</ol>
<p>结构体epoll_event被用于注册所感兴趣的事件和回传所发生待处理的事件，定义如下：</p>
<p>typedef <a href="https://so.csdn.net/so/search?q=union&amp;spm=1001.2101.3001.7020">union</a> epoll_data {
void *ptr;
int fd;
__uint32_t u32;
__uint64_t u64;
} epoll_data_t;//保存触发事件的某个文件描述符相关的数据</p>
<p>struct epoll_event {
__uint32_t events;   /* <a href="https://so.csdn.net/so/search?q=epoll&amp;spm=1001.2101.3001.7020">epoll</a> event <em>/
epoll_data_t data;   /</em> User data variable */
};</p>
<p>其中events表示感兴趣的事件和被触发的事件，可能的取值为：
EPOLLIN：表示对应的文件描述符可以读；
EPOLLOUT：表示对应的文件描述符可以写；
EPOLLPRI：表示对应的文件描述符有紧急的数可读；</p>
<p>EPOLLERR：表示对应的文件描述符发生错误；
EPOLLHUP：表示对应的文件描述符被挂断；
EPOLLET：  ET的epoll工作模式；</p>
<p>所涉及到的函数有：</p>
<p>1、epoll_create函数
函数声明：int epoll_create(int size)</p>
<p>功能：该函数生成一个epoll专用的文件描述符，其中的参数是指定生成描述符的最大范围；</p>
<p>2、epoll_ctl函数
函数声明：int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)   在epfd上注册一个fd-events, 监听event-&gt;events的事件类型</p>
<p>功能：用于控制某个文件描述符上的事件，可以注册事件，修改事件，删除事件。</p>
<p>@epfd：由epoll_create生成的epoll专用的文件描述符；</p>
<p>@op：要进行的操作，EPOLL_CTL_ADD注册、EPOLL_CTL_MOD修改、EPOLL_CTL_DEL删除；</p>
<p>@fd：关联的文件描述符；</p>
<p>@event：指向epoll_event的指针；</p>
<p>成功：0；失败：-1</p>
<p>3、epoll_wait函数
函数声明:int epoll_wait(int epfd,struct epoll_event * events,int maxevents,int timeout)</p>
<p>功能：该函数用于轮询I/O事件的发生；</p>
<p>@epfd：由epoll_create生成的epoll专用的文件描述符；</p>
<p>@epoll_event：用于回传代处理事件的数组；</p>
<p>@maxevents：每次能处理的事件数；</p>
<p>@timeout：等待I/O事件发生的超时值；</p>
<p>成功：返回发生的事件数；失败：-1</p>
<p><code>epoll_ctl</code> 是用于控制 epoll 实例的系统调用之一，它用于向 epoll 实例注册或删除事件，并指定相应的文件描述符和事件类型。</p>
<p><code>epoll_ctl</code> 的原型如下：</p>
<pre><code>cCopy code
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
</code></pre>
<p>其中参数的含义如下：</p>
<ul>
<li>
<p><code>epfd</code>：epoll 实例的文件描述符，通过 <code>epoll_create</code> 创建得到。</p>
</li>
<li>
<pre><code>op
</code></pre>
<p>：操作类型，可以是以下几种值之一：</p>
<ul>
<li><code>EPOLL_CTL_ADD</code>：添加一个新的文件描述符到 epoll 实例中。</li>
<li><code>EPOLL_CTL_MOD</code>：修改一个已注册的文件描述符的事件类型。</li>
<li><code>EPOLL_CTL_DEL</code>：从 epoll 实例中删除一个文件描述符。</li>
</ul>
</li>
<li>
<p><code>fd</code>：要添加、修改或删除的文件描述符。</p>
</li>
<li>
<p><code>event</code>：一个指向 <code>struct epoll_event</code> 结构体的指针，用于描述要注册的事件类型和相关的数据。</p>
</li>
</ul>
<p><code>struct epoll_event</code> 结构体定义如下：</p>
<pre><code>cCopy code


解释struct epoll_event {
    uint32_t events;  // 事件类型，可以是 EPOLLIN、EPOLLOUT、EPOLLERR 等
    epoll_data_t data; // 事件关联的数据，通常是一个联合体
};
</code></pre>
<p><code>epoll_ctl</code> 的主要作用是管理 epoll 实例中的文件描述符和事件，可以添加、修改或删除特定的文件描述符以及相应的事件类型。通过这个系统调用，可以实现高效的 I/O 多路复用机制，使得应用程序能够监视多个文件描述符上的事件，并在事件发生时做出相应的处理。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/epoll.h&gt;

#define MAX_EVENTS 10

int main() {
    int epoll_fd, nfds, i;
    struct epoll_event event, events[MAX_EVENTS];

    // 创建 epoll 实例
    epoll_fd = epoll_create1(0);
    if (epoll_fd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }

    // 打开一个文件描述符（这里以标准输入描述符为例）
    int stdin_fd = STDIN_FILENO;

    // 配置要监听的事件
    event.events = EPOLLIN; // 监听读事件
    event.data.fd = stdin_fd; // 将标准输入描述符与事件关联

    // 将事件添加到 epoll 实例中
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, stdin_fd, &amp;event) == -1) {
        perror("epoll_ctl: EPOLL_CTL_ADD");
        close(epoll_fd);
        exit(EXIT_FAILURE);
    }

    // 等待事件发生
    while (1) {
        nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
        if (nfds == -1) {
            perror("epoll_wait");
            close(epoll_fd);
            exit(EXIT_FAILURE);
        }

        // 处理所有发生的事件
        for (i = 0; i &lt; nfds; ++i) {
            if (events[i].events &amp; EPOLLIN) {
                printf("Event on file descriptor %d: EPOLLIN\n", events[i].data.fd);

                // 从标准输入读取数据并进行处理
                char buffer[1024];
                ssize_t bytes_read = read(events[i].data.fd, buffer, sizeof(buffer));
                if (bytes_read == -1) {
                    perror("read");
                    close(epoll_fd);
                    exit(EXIT_FAILURE);
                }
                // 处理读取的数据
                // ...
            }
        }
    }

    // 关闭 epoll 实例
    close(epoll_fd);

    return 0;
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="transport"><a class="header" href="#transport">Transport</a></h2>
<p>媒体传输封装了网络收发细节，pjmedia_transport可以是udp、srtp、ice等，这里以udp为例。</p>
<h3 id="相关结构体"><a class="header" href="#相关结构体">相关结构体</a></h3>
<h4 id="结构体pjmedia_transport"><a class="header" href="#结构体pjmedia_transport"><strong>结构体pjmedia_transport</strong></a></h4>
<pre><code class="language-cpp">/**
 * This structure declares media transport. A media transport is called
 * by the stream to transmit a packet, and will notify stream when
 * incoming packet is arrived.
 */
struct pjmedia_transport
{
    /** Transport name (for logging purpose). */
    char		     name[PJ_MAX_OBJ_NAME];
 
    /** Transport type. */
    pjmedia_transport_type   type;
 
    /** Transport's "virtual" function table. */
    pjmedia_transport_op    *op;
 
    /** Application/user data */
    void		    *user_data;
};
</code></pre>
<p>type：传输类型，上面讲过，这里以udp为例。</p>
<p>op：操作集，每种传输类型实现了同一组接口。</p>
<p>user_data：应用层用户数据</p>
<h4 id="pjmedia_transport_op"><a class="header" href="#pjmedia_transport_op">pjmedia_transport_op</a></h4>
<p>操作集是核心，这里列举重要的一些函数。<a href="https://docs.pjsip.org/en/latest/api/generated/pjmedia/group/group__PJMEDIA__TRANSPORT.html#_CPPv420pjmedia_transport_op">pjmedia_transport_op</a></p>
<pre><code class="language-cpp">/**
 * This structure describes the operations for the stream transport.
 */
struct pjmedia_transport_op
{
 
    /**
     * This function is called by the stream when the transport is about
     * to be used by the stream for the first time, and it tells the transport
     * about remote RTP address to send the packet and some callbacks to be 
     * called for incoming packets. This function exists for backwards
     * compatibility. Transports should implement attach2 instead.
     *
     * Application should call #pjmedia_transport_attach() instead of 
     * calling this function directly.
     */
    pj_status_t (*attach)(pjmedia_transport *tp,
			  void *user_data,
			  const pj_sockaddr_t *rem_addr,
			  const pj_sockaddr_t *rem_rtcp,
			  unsigned addr_len,
			  void (*rtp_cb)(void *user_data,
					 void *pkt,
					 pj_ssize_t size),
			  void (*rtcp_cb)(void *user_data,
					  void *pkt,
					  pj_ssize_t size));
 
    /**
     * This function is called by the stream to send RTP packet using the 
     * transport.
     *
     * Application should call #pjmedia_transport_send_rtp() instead of 
     * calling this function directly.
     */
    pj_status_t (*send_rtp)(pjmedia_transport *tp,
			    const void *pkt,
			    pj_size_t size);
 
    /**
     * Prepare the transport for a new media session.
     *
     * Application should call #pjmedia_transport_media_create() instead of 
     * calling this function directly.
     */
    pj_status_t (*media_create)(pjmedia_transport *tp,
				pj_pool_t *sdp_pool,
				unsigned options,
				const pjmedia_sdp_session *remote_sdp,
				unsigned media_index);
 
    /**
     * This function is called by application to start the transport
     * based on local and remote SDP.
     *
     * Application should call #pjmedia_transport_media_start() instead of 
     * calling this function directly.
     */
    pj_status_t (*media_start) (pjmedia_transport *tp,
			        pj_pool_t *tmp_pool,
			        const pjmedia_sdp_session *sdp_local,
			        const pjmedia_sdp_session *sdp_remote,
				unsigned media_index);
 
    /**
     * This function is called by application to stop the transport.
     *
     * Application should call #pjmedia_transport_media_stop() instead of 
     * calling this function directly.
     */
    pj_status_t (*media_stop)  (pjmedia_transport *tp);
 
 
    /**
     * This function can be called to destroy this transport.
     *
     * Application should call #pjmedia_transport_close() instead of 
     * calling this function directly.
     */
    pj_status_t (*destroy)(pjmedia_transport *tp);
 
    /**
     * This function is called by the stream when the transport is about
     * to be used by the stream for the first time, and it tells the transport
     * about remote RTP address to send the packet and some callbacks to be
     * called for incoming packets.
     *
     * Application should call #pjmedia_transport_attach2() instead of
     * calling this function directly.
     */
    pj_status_t (*attach2)(pjmedia_transport *tp,
			   pjmedia_transport_attach_param *att_param);
};
</code></pre>
<p>op的默认初始化方法</p>
<pre><code class="language-c">static pjmedia_transport_op transport_udp_op = 
{
    &amp;transport_get_info,
    &amp;transport_attach,
    &amp;transport_detach,
    &amp;transport_send_rtp,
    &amp;transport_send_rtcp,
    &amp;transport_send_rtcp2,
    &amp;transport_media_create,
    &amp;transport_encode_sdp,
    &amp;transport_media_start,
    &amp;transport_media_stop,
    &amp;transport_simulate_lost,
    &amp;transport_destroy,
    &amp;transport_attach2
};
</code></pre>
<p>这里主要看attach2，这个函数传入rtp和rtcp的回调函数指针，当从网络收到数据时，会通过该回调通知。</p>
<h4 id="pjmedia_transport_attach_param"><a class="header" href="#pjmedia_transport_attach_param">pjmedia_transport_attach_param</a></h4>
<pre><code class="language-c">/**
 * This structure describes the data passed when calling
 * #pjmedia_transport_attach2().
 */
struct pjmedia_transport_attach_param
{
    /**
     * The media stream.
     */
    void *stream;

    /**
     * Indicate the stream type, either it's audio (PJMEDIA_TYPE_AUDIO) 
     * or video (PJMEDIA_TYPE_VIDEO).
     */
    pjmedia_type media_type;

    /**
     * Remote RTP address to send RTP packet to.
     */
    pj_sockaddr rem_addr;

    /**
     * Optional remote RTCP address. If the argument is NULL
     * or if the address is zero, the RTCP address will be
     * calculated from the RTP address (which is RTP port plus one).
     */
    pj_sockaddr rem_rtcp;

    /**
     * Length of the remote address.
     */
    unsigned addr_len;

    /**
     * Arbitrary user data to be set when the callbacks are called.
     */
    void *user_data;

    /**
     * Callback to be called when RTP packet is received on the transport.
     */
    void (*rtp_cb)(void *user_data, void *pkt, pj_ssize_t);

    /**
     * Callback to be called when RTCP packet is received on the transport.
     */
    void (*rtcp_cb)(void *user_data, void *pkt, pj_ssize_t);

    /**
     * Callback to be called when RTP packet is received on the transport.
     */
    void (*rtp_cb2)(pjmedia_tp_cb_param *param);

};

</code></pre>
<h4 id="transport_udp"><a class="header" href="#transport_udp">transport_udp</a></h4>
<pre><code class="language-c">struct transport_udp
{
    pjmedia_transport   base;           /**&lt; Base transport.                */

    pj_pool_t          *pool;           /**&lt; Memory pool                    */
    unsigned            options;        /**&lt; Transport options.             */
    unsigned            media_options;  /**&lt; Transport media options.       */
    void               *user_data;      /**&lt; Only valid when attached       */
    //pj_bool_t         attached;       /**&lt; Has attachment?                */
    pj_bool_t           started;        /**&lt; Has started?                   */
    pj_sockaddr         rem_rtp_addr;   /**&lt; Remote RTP address             */
    pj_sockaddr         rem_rtcp_addr;  /**&lt; Remote RTCP address            */
    int                 addr_len;       /**&lt; Length of addresses.           */
    void  (*rtp_cb)(    void*,          /**&lt; To report incoming RTP.        */
                        void*,
                        pj_ssize_t);
    void  (*rtp_cb2)(pjmedia_tp_cb_param*); /**&lt; To report incoming RTP.    */
    void  (*rtcp_cb)(   void*,          /**&lt; To report incoming RTCP.       */
                        void*,
                        pj_ssize_t);

    unsigned            tx_drop_pct;    /**&lt; Percent of tx pkts to drop.    */
    unsigned            rx_drop_pct;    /**&lt; Percent of rx pkts to drop.    */
    pj_ioqueue_t        *ioqueue;       /**&lt; Ioqueue instance.              */

    pj_sock_t           rtp_sock;       /**&lt; RTP socket                     */
    pj_sockaddr         rtp_addr_name;  /**&lt; Published RTP address.         */
    pj_ioqueue_key_t   *rtp_key;        /**&lt; RTP socket key in ioqueue      */
    pj_ioqueue_op_key_t rtp_read_op;    /**&lt; Pending read operation         */
    unsigned            rtp_write_op_id;/**&lt; Next write_op to use           */
    pending_write       rtp_pending_write[MAX_PENDING];  /**&lt; Pending write */
    pj_sockaddr         rtp_src_addr;   /**&lt; Actual packet src addr.        */
    int                 rtp_addrlen;    /**&lt; Address length.                */
    char                rtp_pkt[RTP_LEN];/**&lt; Incoming RTP packet buffer    */

    pj_bool_t           enable_rtcp_mux;/**&lt; Enable RTP &amp; RTCP multiplexing?*/
    pj_bool_t           use_rtcp_mux;   /**&lt; Use RTP &amp; RTCP multiplexing?   */
    pj_sock_t           rtcp_sock;      /**&lt; RTCP socket                    */
    pj_sockaddr         rtcp_addr_name; /**&lt; Published RTCP address.        */
    pj_sockaddr         rtcp_src_addr;  /**&lt; Actual source RTCP address.    */
    unsigned            rtcp_src_cnt;   /**&lt; How many pkt from this addr.   */
    int                 rtcp_addr_len;  /**&lt; Length of RTCP src address.    */
    pj_ioqueue_key_t   *rtcp_key;       /**&lt; RTCP socket key in ioqueue     */
    pj_ioqueue_op_key_t rtcp_read_op;   /**&lt; Pending read operation         */
    pj_ioqueue_op_key_t rtcp_write_op;  /**&lt; Pending write operation        */
    char                rtcp_pkt[RTCP_LEN];/**&lt; Incoming RTCP packet buffer */
};

</code></pre>
<h4 id="pj_ioqueue_callback-1"><a class="header" href="#pj_ioqueue_callback-1">pj_ioqueue_callback</a></h4>
<pre><code class="language-c">/**
 * This structure describes the callbacks to be called when I/O operation
 * completes.
 */
typedef struct pj_ioqueue_callback
{
    /**
     * This callback is called when #pj_ioqueue_recv or #pj_ioqueue_recvfrom
     * completes.
     *
     * @param key           The key.
     * @param op_key        Operation key.
     * @param bytes_read    &gt;= 0 to indicate the amount of data read,
     *                      otherwise negative value containing the error
     *                      code. To obtain the pj_status_t error code, use
     *                      (pj_status_t code = -bytes_read).
     */
    void (*on_read_complete)(pj_ioqueue_key_t *key,
                             pj_ioqueue_op_key_t *op_key,
                             pj_ssize_t bytes_read);

    /**
     * This callback is called when #pj_ioqueue_send or #pj_ioqueue_sendto
     * completes.
     *
     * @param key           The key.
     * @param op_key        Operation key.
     * @param bytes_sent    &gt;= 0 to indicate the amount of data written,
     *                      otherwise negative value containing the error
     *                      code. To obtain the pj_status_t error code, use
     *                      (pj_status_t code = -bytes_sent).
     */
    void (*on_write_complete)(pj_ioqueue_key_t *key,
                              pj_ioqueue_op_key_t *op_key,
                              pj_ssize_t bytes_sent);

    /**
     * This callback is called when #pj_ioqueue_accept completes.
     *
     * @param key           The key.
     * @param op_key        Operation key.
     * @param sock          Newly connected socket.
     * @param status        Zero if the operation completes successfully.
     */
    void (*on_accept_complete)(pj_ioqueue_key_t *key,
                               pj_ioqueue_op_key_t *op_key,
                               pj_sock_t sock,
                               pj_status_t status);

    /**
     * This callback is called when #pj_ioqueue_connect completes.
     *
     * @param key           The key.
     * @param status        PJ_SUCCESS if the operation completes successfully.
     */
    void (*on_connect_complete)(pj_ioqueue_key_t *key,
                                pj_status_t status);
} pj_ioqueue_callback;
</code></pre>
<h3 id="创建udp-media-transport"><a class="header" href="#创建udp-media-transport"><strong>创建udp media transport</strong></a></h3>
<p>在simpleua.c初始化时，创建完媒体端点pjmedia_endpt后，还会预先创建好udp媒体传输在main.c在sdp和invite session之前</p>
<pre><code class="language-cpp">    /* 
     * Create media transport used to send/receive RTP/RTCP socket.
     * One media transport is needed for each call. Application may
     * opt to re-use the same media transport for subsequent calls.
     */
    for (i = 0; i &lt; PJ_ARRAY_SIZE(g_med_transport); ++i) {
      status = pjmedia_transport_udp_create3(g_med_endpt, AF, NULL, NULL, 
                     RTP_PORT + i*2, 0, 
                     &amp;g_med_transport[i]);
</code></pre>
<p>pjmedia_transport_udp_create最终调用pjmedia_transport_udp_create3，这个函数先创建rtp和rtcp两个socket，然后调用pjmedia_transport_udp_attach。</p>
<h4 id="transport_udp_create调用流"><a class="header" href="#transport_udp_create调用流">transport_udp_create调用流</a></h4>
<p>pjmedia_transport_udp_create3 (Create &amp; Bind RTP &amp; RTCP socket)-&gt;pjmedia_transport_udp_attach(创建transport_udp,初始化socket infos，pj_ioqueue_register_sock2：注册socket到 I/O queue同时设置回调函数，以便异步接受消息)</p>
<h5 id="pjmedia_transport_udp_create3"><a class="header" href="#pjmedia_transport_udp_create3">pjmedia_transport_udp_create3</a></h5>
<pre><code class="language-cpp">/**
 * Create UDP stream transport.
 */
PJ_DEF(pj_status_t) pjmedia_transport_udp_create3(pjmedia_endpt *endpt,
						  int af,
						  const char *name,
						  const pj_str_t *addr,
						  int port,
						  unsigned options,
						  pjmedia_transport **p_tp)
{
    pjmedia_sock_info si;
    pj_status_t status;
 
    
    /* Sanity check */
    PJ_ASSERT_RETURN(endpt &amp;&amp; port &amp;&amp; p_tp, PJ_EINVAL);
 
 
    pj_bzero(&amp;si, sizeof(pjmedia_sock_info));
    si.rtp_sock = si.rtcp_sock = PJ_INVALID_SOCKET;
 
    /* Create RTP socket */
    status = pj_sock_socket(af, pj_SOCK_DGRAM(), 0, &amp;si.rtp_sock);
    if (status != PJ_SUCCESS)
			goto on_error;
 
    /* Bind RTP socket */
    status = pj_sockaddr_init(af, &amp;si.rtp_addr_name, addr, (pj_uint16_t)port);
    if (status != PJ_SUCCESS)
			goto on_error;
 
    status = pj_sock_bind(si.rtp_sock, &amp;si.rtp_addr_name, 
			  pj_sockaddr_get_len(&amp;si.rtp_addr_name));
    if (status != PJ_SUCCESS)
			goto on_error;
 
 
    /* Create RTCP socket */
    status = pj_sock_socket(af, pj_SOCK_DGRAM(), 0, &amp;si.rtcp_sock);
    if (status != PJ_SUCCESS)
			goto on_error;
 
    /* Bind RTCP socket */
    status = pj_sockaddr_init(af, &amp;si.rtcp_addr_name, addr, 
			      (pj_uint16_t)(port+1));
    if (status != PJ_SUCCESS)
			goto on_error;
 
    status = pj_sock_bind(si.rtcp_sock, &amp;si.rtcp_addr_name,
			  pj_sockaddr_get_len(&amp;si.rtcp_addr_name));
    if (status != PJ_SUCCESS)
			goto on_error;
 
    
    /* Create UDP transport by attaching socket info */
    return pjmedia_transport_udp_attach( endpt, name, &amp;si, options, p_tp);
 
 
on_error:
    if (si.rtp_sock != PJ_INVALID_SOCKET)
			pj_sock_close(si.rtp_sock);
    if (si.rtcp_sock != PJ_INVALID_SOCKET)
			pj_sock_close(si.rtcp_sock);
    return status;
}
</code></pre>
<p>Create &amp; Bind RTP &amp; RTCP socket、Create UDP transport by attaching socket info</p>
<h5 id="pjmedia_transport_udp_attach"><a class="header" href="#pjmedia_transport_udp_attach">pjmedia_transport_udp_attach</a></h5>
<p><a href="html/pjmedia_transport_udp_attach.html">pjmedia_transport_udp_attach</a></p>
<pre><code class="language-c">/**
 * Create UDP stream transport from existing socket info.
 */
PJ_DEF(pj_status_t) pjmedia_transport_udp_attach( pjmedia_endpt *endpt,
                                                  const char *name,
                                                  const pjmedia_sock_info *si,
                                                  unsigned options,
                                                  pjmedia_transport **p_tp)
{
    struct transport_udp *tp;
    pj_pool_t *pool;
    pj_ioqueue_t *ioqueue;
    pj_ioqueue_callback rtp_cb, rtcp_cb;
    pj_grp_lock_t *grp_lock;
    pj_status_t status;


    /* Sanity check */
    PJ_ASSERT_RETURN(endpt &amp;&amp; si &amp;&amp; p_tp, PJ_EINVAL);

    /* Get ioqueue instance */
    ioqueue = pjmedia_endpt_get_ioqueue(endpt);

    if (name==NULL)
        name = "udp%p";

    /* Create transport structure */
    pool = pjmedia_endpt_create_pool(endpt, name, 512, 512);
    if (!pool)
        return PJ_ENOMEM;
		
    tp = PJ_POOL_ZALLOC_T(pool, struct transport_udp);
    tp-&gt;pool = pool;
    tp-&gt;options = options;
    pj_memcpy(tp-&gt;base.name, pool-&gt;obj_name, PJ_MAX_OBJ_NAME);
    tp-&gt;base.op = &amp;transport_udp_op;
    tp-&gt;base.type = PJMEDIA_TRANSPORT_TYPE_UDP;

    /* Copy socket infos */
    tp-&gt;rtp_sock = si-&gt;rtp_sock;
    tp-&gt;rtp_addr_name = si-&gt;rtp_addr_name;
    tp-&gt;rtcp_sock = si-&gt;rtcp_sock;
    tp-&gt;rtcp_addr_name = si-&gt;rtcp_addr_name;

    /* If address is 0.0.0.0, use host's IP address */
    if (!pj_sockaddr_has_addr(&amp;tp-&gt;rtp_addr_name)) {
        pj_sockaddr hostip;

        status = pj_gethostip(tp-&gt;rtp_addr_name.addr.sa_family, &amp;hostip);
        if (status != PJ_SUCCESS)
            goto on_error;

        pj_memcpy(pj_sockaddr_get_addr(&amp;tp-&gt;rtp_addr_name), 
                  pj_sockaddr_get_addr(&amp;hostip),
                  pj_sockaddr_get_addr_len(&amp;hostip));
    }

    /* Same with RTCP */
    if (!pj_sockaddr_has_addr(&amp;tp-&gt;rtcp_addr_name)) {
        pj_memcpy(pj_sockaddr_get_addr(&amp;tp-&gt;rtcp_addr_name),
                  pj_sockaddr_get_addr(&amp;tp-&gt;rtp_addr_name),
                  pj_sockaddr_get_addr_len(&amp;tp-&gt;rtp_addr_name));
    }

    /* Create group lock */
    status = pj_grp_lock_create(pool, NULL, &amp;grp_lock);
    if (status != PJ_SUCCESS)
        goto on_error;

    pj_grp_lock_add_ref(grp_lock);
    tp-&gt;base.grp_lock = grp_lock;

    /* Setup RTP socket with the ioqueue */
    pj_bzero(&amp;rtp_cb, sizeof(rtp_cb));
    rtp_cb.on_read_complete = &amp;on_rx_rtp;
    rtp_cb.on_write_complete = &amp;on_rtp_data_sent;

    status = pj_ioqueue_register_sock2(pool, ioqueue, tp-&gt;rtp_sock, grp_lock,
                                       tp, &amp;rtp_cb, &amp;tp-&gt;rtp_key);
    if (status != PJ_SUCCESS)
        goto on_error;
    
    /* Disallow concurrency so that detach() and destroy() are
     * synchronized with the callback.
     *
     * Note that we still need this even after group lock is added to
     * maintain the above behavior.
     */
    status = pj_ioqueue_set_concurrency(tp-&gt;rtp_key, PJ_FALSE);
    if (status != PJ_SUCCESS)
        goto on_error;
        
    /* Setup RTCP socket with ioqueue */
    pj_bzero(&amp;rtcp_cb, sizeof(rtcp_cb));
    rtcp_cb.on_read_complete = &amp;on_rx_rtcp;

    status = pj_ioqueue_register_sock2(pool, ioqueue, tp-&gt;rtcp_sock, grp_lock,
                                       tp, &amp;rtcp_cb, &amp;tp-&gt;rtcp_key);
    if (status != PJ_SUCCESS)
        goto on_error;

    status = pj_ioqueue_set_concurrency(tp-&gt;rtcp_key, PJ_FALSE);
    if (status != PJ_SUCCESS)
        goto on_error;

    tp-&gt;ioqueue = ioqueue;

    /* Done */
    *p_tp = &amp;tp-&gt;base;
    return PJ_SUCCESS;


on_error:
    transport_destroy(&amp;tp-&gt;base);
    return status;
}


</code></pre>
<p>创建transport_udp ：PJ_POOL_ZALLOC_T，Copy socket infos 到transport_udp、 Setup RTP/RTCP socket with the ioqueue（设置回调函数on_rx_rtp、on_rtp_data_sent、on_rx_rtcp）。</p>
<p>udp_attach先申请UDP媒体传输结构体transport_udp *tp的内存，注意，此结构体包含了媒体传输pjmedia_transport和一些回调，但是这些回调还没有设置。其中的操作集指向transport_udp_op。接着把socket注册到媒体端点中的io队列，io队列的读完成回调是on_rx_rtp。从这里可以知道，从网络读到数据时，会调用transport_udp.c中的on_rx_rtp，而在这个回调里，会再调用transport_udp中的回调rtp_cb和rtp_cb2，而这两个回调，创建的时候还没有设置，要等到调用操作集的attach才会设置。</p>
<p>注意，这里有两个attach的地方，一个是创建的时候，调用pjmedia_transport_udp_attach，这个attach会把socket注册到ioqueue，同时ioqueue的读完成回调为transport_udp.c中的on_rx_rtp。</p>
<h5 id="pj_ioqueue_register_sock2-1"><a class="header" href="#pj_ioqueue_register_sock2-1">pj_ioqueue_register_sock2</a></h5>
<p>注册一个套接字到I/O队列框架。当一个套接字注册到IO队列时，它可以被修改为使用非阻塞IO。如果被修改了，就不能保证在套接字取消注册后会恢复这种修改。</p>
<ul>
<li><strong>pool</strong> – To allocate the resource for the specified handle, which must be valid until the handle/key is unregistered from I/O Queue.</li>
<li><strong>ioque</strong> – The I/O Queue.</li>
<li><strong>sock</strong> – The socket.</li>
<li><strong>user_data</strong> – User data to be associated with the key, which can be retrieved later.</li>
<li><strong>cb</strong> – Callback to be called when I/O opertion completes.</li>
<li><strong>key</strong> – Pointer to receive the key to be associated with this socket. Subsequent I/O queue operation will need this key.</li>
</ul>
<p>第二个attach是transport_attach/transport_attach2，这个attach会再传入rtp_cb和rtcp_cb，而这两个回调，会被on_rx_rtp调用，所以这里有两个回调。总结数据流方向，从网络收到数据，最后会进入attach传入的rtp_cb。但是这个rtp_cb什么时候设置，设置的是谁，这个是在 stream 中实现，下一篇再说。</p>
<h4 id="pjmedia_transport_attach2调用流"><a class="header" href="#pjmedia_transport_attach2调用流">pjmedia_transport_attach2调用流</a></h4>
<p>pjmedia_transport_attach2-》transport_attach2-》tp_attach</p>
<p>tp_attach最重要就是设置了pjmedia_transport 的cb2 为on_rx_request，还有Copy remote RTP address</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="port--audio"><a class="header" href="#port--audio">Port &amp; Audio</a></h1>
<h2 id="结构体"><a class="header" href="#结构体">结构体</a></h2>
<h3 id="pjmedia_port"><a class="header" href="#pjmedia_port">pjmedia_port</a></h3>
<pre><code class="language-c">
/**
 * Port interface.
 */
typedef struct pjmedia_port
{
    pjmedia_port_info    info;              /**&lt; Port information.  */

    /** Port data can be used by the port creator to attach arbitrary
     *  value to be associated with the port.
     */
    struct port_data {
        void            *pdata;             /**&lt; Pointer data.      */
        long             ldata;             /**&lt; Long data.         */
    } port_data;

    /**
     * Group lock.
     *
     * This is optional, but if this port is registered to the audio/video
     * conference bridge, the bridge will create one if the port has none.
     */
    pj_grp_lock_t       *grp_lock;

    /**
     * Get clock source.
     * This should only be called by #pjmedia_port_get_clock_src().
     */
    pjmedia_clock_src* (*get_clock_src)(struct pjmedia_port *this_port,
                                        pjmedia_dir dir);

    /**
     * Sink interface. 
     * This should only be called by #pjmedia_port_put_frame().
     */
    pj_status_t (*put_frame)(struct pjmedia_port *this_port, 
                             pjmedia_frame *frame);

    /**
     * Source interface. 
     * This should only be called by #pjmedia_port_get_frame().
     */
    pj_status_t (*get_frame)(struct pjmedia_port *this_port, 
                             pjmedia_frame *frame);

    /**
     * Called to destroy this port.
     */
    pj_status_t (*on_destroy)(struct pjmedia_port *this_port);

} pjmedia_port;
</code></pre>
<h3 id="pjmedia_snd_port"><a class="header" href="#pjmedia_snd_port">pjmedia_snd_port</a></h3>
<pre><code class="language-c">struct pjmedia_snd_port
{
    int			 rec_id;
    int			 play_id;
    pj_uint32_t		 aud_caps;
    pjmedia_aud_param	 aud_param;
    pjmedia_aud_stream	*aud_stream;
    pjmedia_dir		 dir;
    pjmedia_port	*port;
 
    pjmedia_clock_src    cap_clocksrc,
                         play_clocksrc;
 
    unsigned		 clock_rate;
    unsigned		 channel_count;
    unsigned		 samples_per_frame;
    unsigned		 bits_per_sample;
    unsigned		 options;
    unsigned		 prm_ec_options;
 
 
    /* audio frame preview callbacks */
    void		*user_data;
    pjmedia_aud_play_cb  on_play_frame;
    pjmedia_aud_rec_cb   on_rec_frame;
};
</code></pre>
<h3 id="pjmedia_snd_port_param"><a class="header" href="#pjmedia_snd_port_param">pjmedia_snd_port_param</a></h3>
<pre><code class="language-c">/**
 * This structure specifies the parameters to create the sound port.
 * Use pjmedia_snd_port_param_default() to initialize this structure with
 * default values (mostly zeroes)
 */
typedef struct pjmedia_snd_port_param
{
    /**
     * Base structure.
     */
    pjmedia_aud_param base;
    
    /**
     * Sound port creation options.
     */
    unsigned options;

    /**
     * Echo cancellation options/flags.
     */
    unsigned ec_options;

    /**
     * Arbitrary user data for playback and record preview callbacks below.
     */
    void *user_data;

    /**
     * Optional callback for audio frame preview right before queued to
     * the speaker.
     * Notes:
     * - application MUST NOT block or perform long operation in the callback
     *   as the callback may be executed in sound device thread
     * - when using software echo cancellation, application MUST NOT modify
     *   the audio data from within the callback, otherwise the echo canceller
     *   will not work properly.
     * - the return value of the callback will be ignored
     */
    pjmedia_aud_play_cb on_play_frame;

    /**
     * Optional callback for audio frame preview recorded from the microphone
     * before being processed by any media component such as software echo
     * canceller.
     * Notes:
     * - application MUST NOT block or perform long operation in the callback
     *   as the callback may be executed in sound device thread
     * - when using software echo cancellation, application MUST NOT modify
     *   the audio data from within the callback, otherwise the echo canceller
     *   will not work properly.
     * - the return value of the callback will be ignored
     */
    pjmedia_aud_rec_cb on_rec_frame;

} pjmedia_snd_port_param;
</code></pre>
<h3 id="pjmedia_aud_param"><a class="header" href="#pjmedia_aud_param">pjmedia_aud_param</a></h3>
<pre><code class="language-c">/**
 * This structure specifies the parameters to open the audio stream.
 */
typedef struct pjmedia_aud_param
{
    /**
     * The audio direction. This setting is mandatory.
     */
    pjmedia_dir dir;

    /**
     * The audio recorder device ID. This setting is mandatory if the audio
     * direction includes input/capture direction.
     */
    pjmedia_aud_dev_index rec_id;

    /**
     * The audio playback device ID. This setting is mandatory if the audio
     * direction includes output/playback direction.
     */
    pjmedia_aud_dev_index play_id;

    /** 
     * Clock rate/sampling rate. This setting is mandatory. 
     */
    unsigned clock_rate;

    /** 
     * Number of channels. This setting is mandatory. 
     */
    unsigned channel_count;

    /** 
     * Number of samples per frame. This setting is mandatory. 
     */
    unsigned samples_per_frame;

    /** 
     * Number of bits per sample. This setting is mandatory. 
     */
    unsigned bits_per_sample;

    /** 
     * This flags specifies which of the optional settings are valid in this
     * structure. The flags is bitmask combination of pjmedia_aud_dev_cap.
     */
    unsigned flags;

    /** 
     * Set the audio format. This setting is optional, and will only be used
     * if PJMEDIA_AUD_DEV_CAP_EXT_FORMAT is set in the flags.
     */
    pjmedia_format ext_fmt;

    /**
     * Input latency, in milliseconds. This setting is optional, and will 
     * only be used if PJMEDIA_AUD_DEV_CAP_INPUT_LATENCY is set in the flags.
     */
    unsigned input_latency_ms;

    /**
     * Input latency, in milliseconds. This setting is optional, and will 
     * only be used if PJMEDIA_AUD_DEV_CAP_OUTPUT_LATENCY is set in the flags.
     */
    unsigned output_latency_ms;

    /**
     * Input volume setting, in percent. This setting is optional, and will 
     * only be used if PJMEDIA_AUD_DEV_CAP_INPUT_VOLUME_SETTING is set in 
     * the flags.
     */
    unsigned input_vol;

    /**
     * Output volume setting, in percent. This setting is optional, and will 
     * only be used if PJMEDIA_AUD_DEV_CAP_OUTPUT_VOLUME_SETTING is set in 
     * the flags.
     */
    unsigned output_vol;

    /** 
     * Set the audio input route/source. This setting is optional, and
     * will only be used if PJMEDIA_AUD_DEV_CAP_INPUT_ROUTE/
     * PJMEDIA_AUD_DEV_CAP_INPUT_SOURCE is set in the flags.
     */
    pjmedia_aud_dev_route input_route;

    /** 
     * Set the audio output route. This setting is optional, and will only be
     * used if PJMEDIA_AUD_DEV_CAP_OUTPUT_ROUTE is set in the flags.
     */
    pjmedia_aud_dev_route output_route;

    /**
     * Enable/disable echo canceller, if the device supports it. This setting
     * is optional, and will only be used if PJMEDIA_AUD_DEV_CAP_EC is set in
     * the flags.
     */
    pj_bool_t ec_enabled;

    /**
     * Set echo canceller tail length in milliseconds, if the device supports
     * it. This setting is optional, and will only be used if
     * PJMEDIA_AUD_DEV_CAP_EC_TAIL is set in the flags.
     */
    unsigned ec_tail_ms;

    /** 
     * Enable/disable PLC. This setting is optional, and will only be used
     * if PJMEDIA_AUD_DEV_CAP_PLC is set in the flags.
     */
    pj_bool_t plc_enabled;

    /** 
     * Enable/disable CNG. This setting is optional, and will only be used
     * if PJMEDIA_AUD_DEV_CAP_CNG is set in the flags.
     */
    pj_bool_t cng_enabled;

    /** 
     * Enable/disable VAD. This setting is optional, and will only be used
     * if PJMEDIA_AUD_DEV_CAP_VAD is set in the flags.
     */
    pj_bool_t vad_enabled;

} pjmedia_aud_param;
</code></pre>
<h3 id="设备抽象"><a class="header" href="#设备抽象">设备抽象</a></h3>
<h4 id="pjmedia_aud_stream-在设备的进一步抽象中绑定rec_cb-play_cb"><a class="header" href="#pjmedia_aud_stream-在设备的进一步抽象中绑定rec_cb-play_cb">pjmedia_aud_stream 在设备的进一步抽象中绑定rec_cb play_cb</a></h4>
<pre><code class="language-c">/**
 * This structure describes the audio device stream.
 */
struct pjmedia_aud_stream
{
    /** Internal data to be initialized by audio subsystem */
    struct {
        /** Driver index */
        unsigned drv_idx;
    } sys;

    /** Operations */
    pjmedia_aud_stream_op *op;
};

</code></pre>
<h4 id="pjmedia_aud_stream_op"><a class="header" href="#pjmedia_aud_stream_op">pjmedia_aud_stream_op</a></h4>
<pre><code class="language-c">/**
 * Sound stream operations.
 */
typedef struct pjmedia_aud_stream_op
{
    /**
     * See #pjmedia_aud_stream_get_param()
     */
    pj_status_t (*get_param)(pjmedia_aud_stream *strm,
                             pjmedia_aud_param *param);

    /**
     * See #pjmedia_aud_stream_get_cap()
     */
    pj_status_t (*get_cap)(pjmedia_aud_stream *strm,
                           pjmedia_aud_dev_cap cap,
                           void *value);

    /**
     * See #pjmedia_aud_stream_set_cap()
     */
    pj_status_t (*set_cap)(pjmedia_aud_stream *strm,
                           pjmedia_aud_dev_cap cap,
                           const void *value);

    /**
     * See #pjmedia_aud_stream_start()
     */
    pj_status_t (*start)(pjmedia_aud_stream *strm);

    /**
     * See #pjmedia_aud_stream_stop().
     */
    pj_status_t (*stop)(pjmedia_aud_stream *strm);

    /**
     * See #pjmedia_aud_stream_destroy().
     */
    pj_status_t (*destroy)(pjmedia_aud_stream *strm);

} pjmedia_aud_stream_op;
</code></pre>
<h4 id="factory相关"><a class="header" href="#factory相关">factory相关</a></h4>
<pre><code class="language-c">
/**
 * Sound device factory operations.
 */
typedef struct pjmedia_aud_dev_factory_op
{
    /**
     * Initialize the audio device factory.
     *
     * @param f         The audio device factory.
     */
    pj_status_t (*init)(pjmedia_aud_dev_factory *f);

    /**
     * Close this audio device factory and release all resources back to the
     * operating system.
     *
     * @param f         The audio device factory.
     */
    pj_status_t (*destroy)(pjmedia_aud_dev_factory *f);

    /**
     * Get the number of audio devices installed in the system.
     *
     * @param f         The audio device factory.
     */
    unsigned (*get_dev_count)(pjmedia_aud_dev_factory *f);

    /**
     * Get the audio device information and capabilities.
     *
     * @param f         The audio device factory.
     * @param index     Device index.
     * @param info      The audio device information structure which will be
     *                  initialized by this function once it returns 
     *                  successfully.
     */
    pj_status_t (*get_dev_info)(pjmedia_aud_dev_factory *f, 
                                unsigned index,
                                pjmedia_aud_dev_info *info);

    /**
     * Initialize the specified audio device parameter with the default
     * values for the specified device.
     *
     * @param f         The audio device factory.
     * @param index     Device index.
     * @param param     The audio device parameter.
     */
    pj_status_t (*default_param)(pjmedia_aud_dev_factory *f,
                                 unsigned index,
                                 pjmedia_aud_param *param);

    /**
     * Open the audio device and create audio stream. See
     * #pjmedia_aud_stream_create()
     */
    pj_status_t (*create_stream)(pjmedia_aud_dev_factory *f,
                                 const pjmedia_aud_param *param,
                                 pjmedia_aud_rec_cb rec_cb,
                                 pjmedia_aud_play_cb play_cb,
                                 void *user_data,
                                 pjmedia_aud_stream **p_aud_strm);

    /**
     * Refresh the list of audio devices installed in the system.
     *
     * @param f         The audio device factory.
     */
    pj_status_t (*refresh)(pjmedia_aud_dev_factory *f);

} pjmedia_aud_dev_factory_op;


/**
 * This structure describes an audio device factory. 
 */
struct pjmedia_aud_dev_factory
{
    /** Internal data to be initialized by audio subsystem. */
    struct {
        /** Driver index */
        unsigned drv_idx;
    } sys;

    /** Operations */
    pjmedia_aud_dev_factory_op *op;
};
</code></pre>
<h2 id="相关方法"><a class="header" href="#相关方法">相关方法</a></h2>
<h3 id="初始化方法"><a class="header" href="#初始化方法">初始化方法</a></h3>
<h4 id="snd_port_parampjmedia_snd_port_param_default"><a class="header" href="#snd_port_parampjmedia_snd_port_param_default">（snd_port_param）pjmedia_snd_port_param_default</a></h4>
<pre><code class="language-c">/* Initialize with default values (zero) */
PJ_DEF(void) pjmedia_snd_port_param_default(pjmedia_snd_port_param *prm)
{
    pj_bzero(prm, sizeof(*prm));
}
</code></pre>
<h4 id="pjmedia_stream_get_port"><a class="header" href="#pjmedia_stream_get_port">pjmedia_stream_get_port</a></h4>
<pre><code>PJ_DEF(pj_status_t) pjmedia_stream_get_port( pjmedia_stream *stream,
                                             pjmedia_port **p_port )
{
    *p_port = &amp;stream-&gt;port;
    return PJ_SUCCESS;
}
</code></pre>
<p>stream-&gt;port，返回p_port</p>
<h4 id="aud_dev_default_parampjmedia_aud_dev_default_param"><a class="header" href="#aud_dev_default_parampjmedia_aud_dev_default_param">（aud_dev_default_param）pjmedia_aud_dev_default_param</a></h4>
<pre><code class="language-c">/* API: Initialize the audio device parameters with default values for the
 * specified device.
 */
PJ_DEF(pj_status_t) pjmedia_aud_dev_default_param(pjmedia_aud_dev_index id,
                                                  pjmedia_aud_param *param)
{
    pjmedia_aud_dev_factory *f;
    unsigned index;
    pj_status_t status;

    PJ_ASSERT_RETURN(param &amp;&amp; id!=PJMEDIA_AUD_INVALID_DEV, PJ_EINVAL);
    PJ_ASSERT_RETURN(aud_subsys.pf, PJMEDIA_EAUD_INIT);

    status = lookup_dev(id, &amp;f, &amp;index);  //Internal: lookup valid device id
    if (status != PJ_SUCCESS)
        return status;

    status = f-&gt;op-&gt;default_param(f, index, param);
    if (status != PJ_SUCCESS)
        return status;

    /* Normalize device IDs */
    make_global_index(f-&gt;sys.drv_idx, &amp;param-&gt;rec_id);
    make_global_index(f-&gt;sys.drv_idx, &amp;param-&gt;play_id);

    return PJ_SUCCESS;
}
</code></pre>
<h3 id="create-port"><a class="header" href="#create-port">Create port</a></h3>
<h4 id="pjmedia_snd_port_create"><a class="header" href="#pjmedia_snd_port_create">pjmedia_snd_port_create</a></h4>
<p>初始化pjmedia_snd_port_param的各种信息，调用pjmedia_snd_port_create2</p>
<pre><code class="language-c">pj_status_t pjmedia_snd_port_create_player(pj_pool_t *pool, int dev_id, unsigned int clock_rate, unsigned int channel_count, unsigned int samples_per_frame, unsigned int bits_per_sample, unsigned int options, pjmedia_snd_port **p_port)
</code></pre>
<p>Create unidirectional sound device port for playing audio streams with the specified parameters.</p>
<p><strong>参数:</strong>
<code>pool</code> – Pool to allocate sound port structure.
<code>index</code> – Device index, or -1 to let the library choose the first available device.
<code>clock_rate</code> – Sound device's clock rate to set.
<code>channel_count</code> – Set number of channels, 1 for mono, or 2 for stereo. The channel count determines the format of the frame.
<code>samples_per_frame</code> – Number of samples per frame.
<code>bits_per_sample</code> – Set the number of bits per sample. The normal value for this parameter is 16 bits per sample.
<code>options</code> – Options flag.
<code>p_port</code> – Pointer to receive the sound device port instance.</p>
<h4 id="pjmedia_snd_port_create2"><a class="header" href="#pjmedia_snd_port_create2">pjmedia_snd_port_create2</a></h4>
<p>用pjmedia_snd_port_creat中传入的pjmedia_snd_port_param，初始化pjmedia_snd_port（此时声音port创建），最后调用start_sound_device，Start the sound stream.</p>
<h4 id="start_sound_device"><a class="header" href="#start_sound_device">start_sound_device</a></h4>
<ul>
<li>
<p>Get device caps：获取dev_id，根据id调用函数pjmedia_aud_dev_get_info获取pjmedia_aud_dev_info</p>
</li>
<li>
<p>Process EC settings</p>
</li>
<li>
<p>Open the device</p>
<p>设置了两个回调snd_rec_cb、snd_play_cb分别为 rec_cb、play_cb</p>
<pre><code class="language-c">    status = pjmedia_aud_stream_create(&amp;param_copy,
                                       snd_rec_cb,
                                       snd_play_cb,
                                       snd_port,
                                       &amp;snd_port-&gt;aud_stream);
</code></pre>
</li>
<li>
<p>Start sound stream.：pjmedia_aud_stream_start(snd_port-&gt;aud_stream);</p>
</li>
</ul>
<h4 id="pjmedia_aud_stream_create"><a class="header" href="#pjmedia_aud_stream_create">pjmedia_aud_stream_create</a></h4>
<p>先通过lookup_dev搜索rec_id、play_id设备对应的工厂，然后通过工厂创建设备f-&gt;op-&gt;create_stream并设置给设备两个回调函数 rec_cb、play_cb给设备抽象pjmedia_aud_stream的ca_cb、pb_cb，lookup_dev中aud_subsys已经存储了所有的音频设备是在创建媒体端点endpoint时初始化举例来说：初始化的时候创建媒体端点pjmedia_endpt，同时初始化了音频子系统aud_subsys，把各种类型的音频设备工厂添加到全局变量<a href="https://so.csdn.net/so/search?q=static&amp;spm=1001.2101.3001.7020">static</a> pjmedia_aud_subsys aud_subsys;。这样当创建设备时，就可以遍历这些工厂，寻找合适的工厂，通过工厂创建设备实例。比如alsa类型的设备在alsa_dev.c</p>
<h4 id="pjmedia_aud_stream_start"><a class="header" href="#pjmedia_aud_stream_start">pjmedia_aud_stream_start</a></h4>
<p>以alsa为例，在alsa_dev.c中，调用alsa_stream_start函数，在alsa_dev.c alsa_stream_start中，会创建播放和采集两条线程。</p>
<pre><code class="language-c">static pj_status_t alsa_stream_start (pjmedia_aud_stream *s)
{
    struct alsa_stream *stream = (struct alsa_stream*)s;
    pj_status_t status = PJ_SUCCESS;
 
    stream-&gt;quit = 0;
    if (stream-&gt;param.dir &amp; PJMEDIA_DIR_PLAYBACK) {
	status = pj_thread_create (stream-&gt;pool,
				   "alsasound_playback",
				   pb_thread_func,
				   stream,
				   0, //ZERO,
				   0,
				   &amp;stream-&gt;pb_thread);
 
 
    if (stream-&gt;param.dir &amp; PJMEDIA_DIR_CAPTURE) {
	status = pj_thread_create (stream-&gt;pool,
				   "alsasound_playback",
				   ca_thread_func,
				   stream,
				   0, //ZERO,
				   0,
				   &amp;stream-&gt;ca_thread);
 
    }
 
    return status;
}
</code></pre>
<p>以播放线程为例</p>
<pre><code class="language-c">static int pb_thread_func (void *arg)
{
    struct alsa_stream* stream = (struct alsa_stream*) arg;
    snd_pcm_t* pcm             = stream-&gt;pb_pcm;
    int size                   = stream-&gt;pb_buf_size;
    snd_pcm_uframes_t nframes  = stream-&gt;pb_frames;
    void* user_data            = stream-&gt;user_data;
    char* buf 		       = stream-&gt;pb_buf;
    pj_timestamp tstamp;
    int result;
 
    pj_bzero (buf, size);
    tstamp.u64 = 0;
 
 
    snd_pcm_prepare (pcm);
 
    while (!stream-&gt;quit) {
        pjmedia_frame frame;

        frame.type = PJMEDIA_FRAME_TYPE_AUDIO;
        frame.buf = buf;
        frame.size = size;
        frame.timestamp.u64 = tstamp.u64;
        frame.bit_info = 0;

        result = stream-&gt;pb_cb (user_data, &amp;frame);
        if (result != PJ_SUCCESS || stream-&gt;quit)
            break;

        if (frame.type != PJMEDIA_FRAME_TYPE_AUDIO)
            pj_bzero (buf, size);

        result = snd_pcm_writei (pcm, buf, nframes);
        if (result == -EPIPE) {
            PJ_LOG (4,(THIS_FILE, "pb_thread_func: underrun!"));
            snd_pcm_prepare (pcm);
        } else if (result &lt; 0) {
            PJ_LOG (4,(THIS_FILE, "pb_thread_func: error writing data!"));
        }

        tstamp.u64 += nframes;
    }
 
    snd_pcm_drain (pcm);
    TRACE_((THIS_FILE, "pb_thread_func: Stopped"));
    return PJ_SUCCESS;
}
</code></pre>
<p>播放线程先通过回调拿到待播放的音频数据stream-&gt;pb_cb ，然后写到声卡snd_pcm_writei。pb_cb就是sound_port.c中的play_cb，来看下play_cb的流程。</p>
<pre><code class="language-c">static pj_status_t play_cb(void *user_data, pjmedia_frame *frame)
{
    pjmedia_snd_port *snd_port = (pjmedia_snd_port*) user_data;
    pjmedia_port *port;
    const unsigned required_size = (unsigned)frame-&gt;size;
    pj_status_t status;
 
    port = snd_port-&gt;port;
    status = pjmedia_port_get_frame(port, frame);
 
    /* Invoke preview callback */
    if (snd_port-&gt;on_play_frame)
	(*snd_port-&gt;on_play_frame)(snd_port-&gt;user_data, frame);
 
    return PJ_SUCCESS;
}
</code></pre>
<p>通过pjmedia_port* port获取一帧数据</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="stream"><a class="header" href="#stream">Stream</a></h2>
<h3 id="pjmedia_stream_info"><a class="header" href="#pjmedia_stream_info">pjmedia_stream_info</a></h3>
<p>对应sdp中的 m=字段 （媒体名称和传输地址）</p>
<pre><code class="language-makefile">m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 126
//m=audio说明本会话包含音频，9代表音频使用端口9来传输，但是在webrtc中一现在一般不使用，如果设置为0，代表不
//传输音频,UDP/TLS/RTP/SAVPF是表示用户来传输音频支持的协议，udp，tls,rtp代表使用udp来传输rtp包，并使用tls加密
//SAVPF代表使用srtcp的反馈机制来控制通信过程,后台111 103 104 9 0 8 106 105 13 126表示本会话音频支持的编码，后台几行会有详细补充说明
</code></pre>
<pre><code class="language-c">/**
 * This structure describes media stream information. Each media stream
 * corresponds to one "m=" line in SDP session descriptor, and it has
 * its own RTP/RTCP socket pair.
 */
typedef struct pjmedia_stream_info
{
    pjmedia_type        type;       /**&lt; Media type (audio, video)          */
    pjmedia_tp_proto    proto;      /**&lt; Transport protocol (RTP/AVP, etc.) */
    pjmedia_dir         dir;        /**&lt; Media direction.                   */
    pj_sockaddr         local_addr; /**&lt; Local RTP address                  */
    pj_sockaddr         rem_addr;   /**&lt; Remote RTP address                 */
    pj_sockaddr         rem_rtcp;   /**&lt; Optional remote RTCP address. If
                                         sin_family is zero, the RTP address
                                         will be calculated from RTP.       */
    pj_bool_t           rtcp_mux;   /**&lt; Use RTP and RTCP multiplexing.     */
#if defined(PJMEDIA_HAS_RTCP_XR) &amp;&amp; (PJMEDIA_HAS_RTCP_XR != 0)
    pj_bool_t           rtcp_xr_enabled;
                                    /**&lt; Specify whether RTCP XR is enabled.*/
    pj_uint32_t         rtcp_xr_interval; /**&lt; RTCP XR interval.            */
    pj_sockaddr         rtcp_xr_dest;/**&lt;Additional remote RTCP XR address.
                                         This is useful for third-party (e.g:
                                         network monitor) to monitor the 
                                         stream. If sin_family is zero, 
                                         this will be ignored.              */
#endif
    pjmedia_rtcp_fb_info loc_rtcp_fb; /**&lt; Local RTCP-FB info.              */
    pjmedia_rtcp_fb_info rem_rtcp_fb; /**&lt; Remote RTCP-FB info.             */
    pjmedia_codec_info  fmt;        /**&lt; Incoming codec format info.        */
    pjmedia_codec_param *param;     /**&lt; Optional codec param.              */
    unsigned            tx_pt;      /**&lt; Outgoing codec paylaod type.       */
    unsigned            rx_pt;      /**&lt; Incoming codec paylaod type.       */
    unsigned            tx_maxptime;/**&lt; Outgoing codec max ptime.          */
    int                 tx_event_pt;/**&lt; Outgoing pt for telephone-events.  */
    int                 rx_event_pt;/**&lt; Incoming pt for telephone-events.  */
    pj_uint32_t         ssrc;       /**&lt; RTP SSRC.                          */
    pj_str_t            cname;      /**&lt; RTCP CNAME.                        */
    pj_bool_t           has_rem_ssrc;/**&lt;Has remote RTP SSRC?               */
    pj_uint32_t         rem_ssrc;   /**&lt; Remote RTP SSRC.                   */
    pj_str_t            rem_cname;  /**&lt; Remote RTCP CNAME.                 */
    pj_uint32_t         rtp_ts;     /**&lt; Initial RTP timestamp.             */
    pj_uint16_t         rtp_seq;    /**&lt; Initial RTP sequence number.       */
    pj_uint8_t          rtp_seq_ts_set;
                                    /**&lt; Bitmask flags if initial RTP sequence 
                                         and/or timestamp for sender are set.
                                         bit 0/LSB : sequence flag 
                                         bit 1     : timestamp flag         */
    int                 jb_init;    /**&lt; Jitter buffer init delay in msec.  
                                         (-1 for default).                  */
    int                 jb_min_pre; /**&lt; Jitter buffer minimum prefetch
                                         delay in msec (-1 for default).    */
    int                 jb_max_pre; /**&lt; Jitter buffer maximum prefetch
                                         delay in msec (-1 for default).    */
    int                 jb_max;     /**&lt; Jitter buffer max delay in msec.   */
    pjmedia_jb_discard_algo jb_discard_algo;
                                    /**&lt; Jitter buffer discard algorithm.   */

#if defined(PJMEDIA_STREAM_ENABLE_KA) &amp;&amp; PJMEDIA_STREAM_ENABLE_KA!=0
    pj_bool_t           use_ka;     /**&lt; Stream keep-alive and NAT hole punch
                                         (see #PJMEDIA_STREAM_ENABLE_KA)
                                         is enabled?                        */
    pjmedia_stream_ka_config ka_cfg;
                                    /**&lt; Stream send kep-alive settings.    */
#endif
    pj_bool_t           rtcp_sdes_bye_disabled; 
                                    /**&lt; Disable automatic sending of RTCP
                                         SDES and BYE.                      */
} pjmedia_stream_info;
</code></pre>
<h3 id="pjmedia_stream"><a class="header" href="#pjmedia_stream">pjmedia_stream</a></h3>
<pre><code class="language-c">/**
 * This structure describes media stream.
 * A media stream is bidirectional media transmission between two endpoints.
 * It consists of two channels, i.e. encoding and decoding channels.
 * A media stream corresponds to a single "m=" line in a SDP session
 * description.
 */
struct pjmedia_stream
{
    pjmedia_endpt           *endpt;         /**&lt; Media endpoint.            */
    pjmedia_codec_mgr       *codec_mgr;     /**&lt; Codec manager instance.    */
    pjmedia_stream_info      si;            /**&lt; Creation parameter.        */
    pjmedia_port             port;          /**&lt; Port interface.            */
    pjmedia_channel         *enc;           /**&lt; Encoding channel.          */
    pjmedia_channel         *dec;           /**&lt; Decoding channel.          */

    pj_pool_t               *own_pool;      /**&lt; Only created if not given  */

 
    pjmedia_dir              dir;           /**&lt; Stream direction.          */
    void                    *user_data;     /**&lt; User data.                 */
    pj_str_t                 cname;         /**&lt; SDES CNAME                 */

    pjmedia_transport       *transport;     /**&lt; Stream transport.          */

    pjmedia_codec           *codec;         /**&lt; Codec instance being used. */
    pjmedia_codec_param      codec_param;   /**&lt; Codec param.               */
    pj_int16_t              *enc_buf;       /**&lt; Encoding buffer, when enc's
                                                 ptime is different than dec.
                                                 Otherwise it's NULL.       */

    unsigned                 enc_samples_per_pkt;
    unsigned                 enc_buf_size;  /**&lt; Encoding buffer size, in
                                                 samples.                   */
    unsigned                 enc_buf_pos;   /**&lt; First position in buf.     */
    unsigned                 enc_buf_count; /**&lt; Number of samples in the
                                                 encoding buffer.           */

    pj_int16_t              *dec_buf;       /**&lt; Decoding buffer.           */
    unsigned                 dec_buf_size;  /**&lt; Decoding buffer size, in
                                                 samples.                   */
    unsigned                 dec_buf_pos;   /**&lt; First position in buf.     */
    unsigned                 dec_buf_count; /**&lt; Number of samples in the
                                                 decoding buffer.           */

    pj_uint16_t              dec_ptime;     /**&lt; Decoder frame ptime in ms. */
    pj_uint8_t               dec_ptime_denum;/**&lt; Decoder ptime denum.      */
    pj_bool_t                detect_ptime_change;
                                            /**&lt; Detect decode ptime change */

    unsigned                 plc_cnt;       /**&lt; # of consecutive PLC frames*/
    unsigned                 max_plc_cnt;   /**&lt; Max # of PLC frames        */

    unsigned                 vad_enabled;   /**&lt; VAD enabled in param.      */
    unsigned                 frame_size;    /**&lt; Size of encoded base frame.*/
    pj_bool_t                is_streaming;  /**&lt; Currently streaming?. This
                                                 is used to put RTP marker
                                                 bit.                       */
    pj_uint32_t              ts_vad_disabled;/**&lt; TS when VAD was disabled. */
    pj_uint32_t              tx_duration;   /**&lt; TX duration in timestamp.  */

    pj_mutex_t              *jb_mutex;
    pjmedia_jbuf            *jb;            /**&lt; Jitter buffer.             */
    char                     jb_last_frm;   /**&lt; Last frame type from jb    */
    unsigned                 jb_last_frm_cnt;/**&lt; Last JB frame type counter*/
    unsigned                 soft_start_cnt;/**&lt; Stream soft start counter */

    pjmedia_rtcp_session     rtcp;          /**&lt; RTCP for incoming RTP.     */

    pj_uint32_t              rtcp_last_tx;  /**&lt; RTCP tx time in timestamp  */
    pj_uint32_t              rtcp_interval; /**&lt; Interval, in timestamp.    */
    pj_bool_t                initial_rr;    /**&lt; Initial RTCP RR sent       */
    pj_bool_t                rtcp_sdes_bye_disabled;/**&lt; Send RTCP SDES/BYE?*/
    void                    *out_rtcp_pkt;  /**&lt; Outgoing RTCP packet.      */
    unsigned                 out_rtcp_pkt_size;
                                            /**&lt; Outgoing RTCP packet size. */
    pj_int16_t              *zero_frame;    /**&lt; Zero frame buffer.         */

    /* RFC 2833 DTMF transmission queue: */
    unsigned                 dtmf_duration; /**&lt; DTMF duration(in timestamp)*/
    int                      tx_event_pt;   /**&lt; Outgoing pt for dtmf.      */
    int                      tx_dtmf_count; /**&lt; # of digits in tx dtmf buf.*/
    struct dtmf              tx_dtmf_buf[32];/**&lt; Outgoing dtmf queue.      */

    /* Incoming DTMF: */
    int                      rx_event_pt;   /**&lt; Incoming pt for dtmf.      */
    int                      last_dtmf;     /**&lt; Current digit, or -1.      */
    pj_uint32_t              last_dtmf_dur; /**&lt; Start ts for cur digit.    */
    pj_bool_t                last_dtmf_ended;
    unsigned                 rx_dtmf_count; /**&lt; # of digits in dtmf rx buf.*/
    char                     rx_dtmf_buf[32];/**&lt; Incoming DTMF buffer.     */

    /* DTMF callback */
    void                    (*dtmf_cb)(pjmedia_stream*, void*, int);
    void                     *dtmf_cb_user_data;

    void                    (*dtmf_event_cb)(pjmedia_stream*, void*,
                                             const pjmedia_stream_dtmf_event*);
    void                     *dtmf_event_cb_user_data;

#if defined(PJMEDIA_HANDLE_G722_MPEG_BUG) &amp;&amp; (PJMEDIA_HANDLE_G722_MPEG_BUG!=0)
    /* Enable support to handle codecs with inconsistent clock rate
     * between clock rate in SDP/RTP &amp; the clock rate that is actually used.
     * This happens for example with G.722 and MPEG audio codecs.
     */
    pj_bool_t                has_g722_mpeg_bug;
                                            /**&lt; Flag to specify whether
                                                 normalization process
                                                 is needed                  */
    unsigned                 rtp_tx_ts_len_per_pkt;
                                            /**&lt; Normalized ts length per packet
                                                 transmitted according to
                                                 'erroneous' definition     */
    unsigned                 rtp_rx_ts_len_per_frame;
                                            /**&lt; Normalized ts length per frame
                                                 received according to
                                                 'erroneous' definition     */
    unsigned                 rtp_rx_last_cnt;/**&lt; Nb of frames in last pkt  */
    unsigned                 rtp_rx_check_cnt;
                                            /**&lt; Counter of remote timestamp
                                                 checking */
#endif


    pj_sockaddr              rem_rtp_addr;     /**&lt; Remote RTP address      */
    unsigned                 rem_rtp_flag;     /**&lt; Indicator flag about
                                                    packet from this addr.
                                                    0=no pkt, 1=good ssrc,
                                                    2=bad ssrc pkts         */
    unsigned                 rtp_src_cnt;      /**&lt; How many pkt from
                                                    this addr.              */
    pj_uint32_t              rtp_rx_last_ts;        /**&lt; Last received RTP
                                                         timestamp          */
    pj_uint32_t              rtp_tx_err_cnt;        /**&lt; The number of RTP
                                                         send() error       */
    pj_uint32_t              rtcp_tx_err_cnt;       /**&lt; The number of RTCP
                                                         send() error       */

    /* RTCP Feedback */
    pj_bool_t                send_rtcp_fb_nack;     /**&lt; Send NACK?         */
    pjmedia_rtcp_fb_nack     rtcp_fb_nack;          /**&lt; TX NACK state.     */
    int                      rtcp_fb_nack_cap_idx;  /**&lt; RX NACK cap idx.   */


};

</code></pre>
<h2 id="初始化pjmedia_stream_create"><a class="header" href="#初始化pjmedia_stream_create">初始化pjmedia_stream_create</a></h2>
<pre><code class="language-c">PJ_DEF(pj_status_t) pjmedia_stream_create( pjmedia_endpt *endpt,
                                           pj_pool_t *pool,
                                           const pjmedia_stream_info *info,
                                           pjmedia_transport *tp,
                                           void *user_data,
                                           pjmedia_stream **p_stream)
</code></pre>
<p>创建stream对象stream = PJ_POOL_ZALLOC_T(pool, pjmedia_stream);</p>
<p>好的，以下是所有变量以及它们的类型和描述的表格：</p>
<div class="table-wrapper"><table><thead><tr><th>变量</th><th>类型</th><th>描述</th><th style="text-align: left">初始化</th></tr></thead><tbody>
<tr><td><code>endpt</code></td><td><code>pjmedia_endpt*</code></td><td>媒体端点。</td><td style="text-align: left">endpt 函数参数</td></tr>
<tr><td><code>codec_mgr</code></td><td><code>pjmedia_codec_mgr*</code></td><td>编解码器管理器实例。</td><td style="text-align: left">pjmedia_endpt_get_codec_mgr(endpt);</td></tr>
<tr><td><code>si</code></td><td><code>pjmedia_stream_info</code></td><td>流的创建参数。</td><td style="text-align: left">create参数info</td></tr>
<tr><td><code>port</code></td><td><code>pjmedia_port</code></td><td>端口接口。</td><td style="text-align: left">port.info初始化pjmedia_port_info_init ，stream-&gt;port.info.fmt</td></tr>
<tr><td><code>enc</code></td><td><code>pjmedia_channel*</code></td><td>编码通道。</td><td style="text-align: left">f</td></tr>
<tr><td><code>dec</code></td><td><code>pjmedia_channel*</code></td><td>解码通道。</td><td style="text-align: left"></td></tr>
<tr><td><code>own_pool</code></td><td><code>pj_pool_t*</code></td><td>只有在未给定时才会创建。</td><td style="text-align: left"></td></tr>
<tr><td><code>dir</code></td><td><code>pjmedia_dir</code></td><td>流的方向。</td><td style="text-align: left">info-&gt;dir</td></tr>
<tr><td><code>user_data</code></td><td><code>void*</code></td><td>用户数据。</td><td style="text-align: left">user_data参数</td></tr>
<tr><td><code>cname</code></td><td><code>pj_str_t</code></td><td>SDES CNAME。</td><td style="text-align: left"></td></tr>
<tr><td><code>transport</code></td><td><code>pjmedia_transport*</code></td><td>流传输。</td><td style="text-align: left"></td></tr>
<tr><td><code>codec</code></td><td><code>pjmedia_codec*</code></td><td>正在使用的编解码器实例。</td><td style="text-align: left">pjmedia_codec_mgr_alloc_codec( stream-&gt;codec_mgr, &amp;info-&gt;fmt, &amp;stream-&gt;codec);</td></tr>
<tr><td><code>codec_param</code></td><td><code>pjmedia_codec_param</code></td><td>编解码器参数。</td><td style="text-align: left">stream-&gt;codec_param = *stream-&gt;si.param;或pjmedia_codec_mgr_get_default_param(stream-&gt;codec_mgr,&amp;info&gt;fmt,&amp;stream&gt;codec_param);</td></tr>
<tr><td><code>enc_buf</code></td><td><code>pj_int16_t*</code></td><td>编码缓冲区，当编码的 ptime 与解码的不同时有效。</td><td style="text-align: left"></td></tr>
<tr><td><code>enc_samples_per_pkt</code></td><td><code>unsigned</code></td><td>每个包的编码样本数。</td><td style="text-align: left"></td></tr>
<tr><td><code>enc_buf_size</code></td><td><code>unsigned</code></td><td>编码缓冲区大小，以样本为单位。</td><td style="text-align: left"></td></tr>
<tr><td><code>enc_buf_pos</code></td><td><code>unsigned</code></td><td>缓冲区中的第一个位置。</td><td style="text-align: left"></td></tr>
<tr><td><code>enc_buf_count</code></td><td><code>unsigned</code></td><td>编码缓冲区中的样本数。</td><td style="text-align: left"></td></tr>
<tr><td><code>dec_buf</code></td><td><code>pj_int16_t*</code></td><td>解码缓冲区。</td><td style="text-align: left"></td></tr>
<tr><td><code>dec_buf_size</code></td><td><code>unsigned</code></td><td>解码缓冲区大小，以样本为单位。</td><td style="text-align: left"></td></tr>
<tr><td><code>dec_buf_pos</code></td><td><code>unsigned</code></td><td>缓冲区中的第一个位置。</td><td style="text-align: left"></td></tr>
<tr><td><code>dec_buf_count</code></td><td><code>unsigned</code></td><td>解码缓冲区中的样本数。</td><td style="text-align: left"></td></tr>
<tr><td><code>dec_ptime</code></td><td><code>pj_uint16_t</code></td><td>解码器帧的时间，以毫秒为单位。</td><td style="text-align: left"></td></tr>
<tr><td><code>dec_ptime_denum</code></td><td><code>pj_uint8_t</code></td><td>解码器帧的时间分母。</td><td style="text-align: left"></td></tr>
<tr><td><code>detect_ptime_change</code></td><td><code>pj_bool_t</code></td><td>检测解码 ptime 的变化。</td><td style="text-align: left"></td></tr>
<tr><td><code>plc_cnt</code></td><td><code>unsigned</code></td><td>连续 PLC 帧的数量。</td><td style="text-align: left"></td></tr>
<tr><td><code>max_plc_cnt</code></td><td><code>unsigned</code></td><td>最大的 PLC 帧数量。</td><td style="text-align: left"></td></tr>
<tr><td><code>vad_enabled</code></td><td><code>unsigned</code></td><td>参数中是否启用了 VAD。</td><td style="text-align: left"></td></tr>
<tr><td><code>frame_size</code></td><td><code>unsigned</code></td><td>编码基本帧的大小。</td><td style="text-align: left"></td></tr>
<tr><td><code>is_streaming</code></td><td><code>pj_bool_t</code></td><td>当前是否正在流式传输？</td><td style="text-align: left"></td></tr>
<tr><td><code>ts_vad_disabled</code></td><td><code>pj_uint32_t</code></td><td>禁用 VAD 时的时间戳。</td><td style="text-align: left"></td></tr>
<tr><td><code>tx_duration</code></td><td><code>pj_uint32_t</code></td><td>时间戳中的 TX 时长。</td><td style="text-align: left"></td></tr>
<tr><td><code>jb_mutex</code></td><td><code>pj_mutex_t*</code></td><td>抖动缓冲区互斥锁。</td><td style="text-align: left">status = pj_mutex_create_simple(pool, NULL, &amp;stream-&gt;jb_mutex);</td></tr>
<tr><td><code>jb</code></td><td><code>pjmedia_jbuf*</code></td><td>抖动缓冲区。</td><td style="text-align: left"></td></tr>
<tr><td><code>jb_last_frm</code></td><td><code>char</code></td><td>最后一帧的类型。</td><td style="text-align: left"></td></tr>
<tr><td><code>jb_last_frm_cnt</code></td><td><code>unsigned</code></td><td>上一个 JB 帧类型的计数器。</td><td style="text-align: left"></td></tr>
<tr><td><code>soft_start_cnt</code></td><td><code>unsigned</code></td><td>流软启动计数器。</td><td style="text-align: left"></td></tr>
<tr><td><code>rtcp</code></td><td><code>pjmedia_rtcp_session</code></td><td>传入 RTP 的 RTCP。</td><td style="text-align: left"></td></tr>
<tr><td><code>rtcp_last_tx</code></td><td><code>pj_uint32_t</code></td><td>RTCP 的上次发送时间戳。</td><td style="text-align: left"></td></tr>
<tr><td><code>rtcp_interval</code></td><td><code>pj_uint32_t</code></td><td>间隔时间戳。</td><td style="text-align: left"></td></tr>
<tr><td><code>initial_rr</code></td><td><code>pj_bool_t</code></td><td>是否已发送初始的 RTCP RR。</td><td style="text-align: left"></td></tr>
<tr><td><code>rtcp_sdes_bye_disabled</code></td><td><code>pj_bool_t</code></td><td>是否发送 RTCP SDES/BYE？</td><td style="text-align: left"></td></tr>
<tr><td><code>out_rtcp_pkt</code></td><td><code>void*</code></td><td>出站 RTCP 数据包。</td><td style="text-align: left"></td></tr>
<tr><td><code>out_rtcp_pkt_size</code></td><td><code>unsigned</code></td><td>出站 RTCP 数据包大小。</td><td style="text-align: left"></td></tr>
<tr><td><code>zero_frame</code></td><td><code>pj_int16_t*</code></td><td>零帧缓冲区。</td><td style="text-align: left"></td></tr>
<tr><td><code>dtmf_duration</code></td><td><code>unsigned</code></td><td>DTMF 时长（时间戳）。</td><td style="text-align: left"></td></tr>
<tr><td><code>tx_event_pt</code></td><td><code>int</code></td><td>DTMF 的传输事件 PT。</td><td style="text-align: left"></td></tr>
<tr><td><code>tx_dtmf_count</code></td><td><code>int</code></td><td>发送 DTMF 缓冲区中的数字数量。</td><td style="text-align: left"></td></tr>
<tr><td><code>tx_dtmf_buf</code></td><td><code>struct dtmf[32]</code></td><td>发送 DTMF 队列。</td><td style="text-align: left"></td></tr>
<tr><td><code>rx_event_pt</code></td><td><code>int</code></td><td>接收 DTMF 的事件 PT。</td><td style="text-align: left"></td></tr>
<tr><td><code>last_dtmf</code></td><td><code>int</code></td><td>当前数字，或 -1。</td><td style="text-align: left"></td></tr>
<tr><td><code>last_dtmf_dur</code></td><td><code>pj_uint32_t</code></td><td>当前数字的开始时间戳。</td><td style="text-align: left"></td></tr>
<tr><td><code>last_dtmf_ended</code></td><td><code>pj_bool_t</code></td><td>上一个 DTMF 是否结束。</td><td style="text-align: left"></td></tr>
<tr><td><code>rx_dtmf_count</code></td><td><code>unsigned</code></td><td>接收 DTMF 缓冲区中的数字数量。</td><td style="text-align: left"></td></tr>
<tr><td><code>rx_dtmf_buf</code></td><td><code>char[32]</code></td><td>接收 DTMF 缓冲区。</td><td style="text-align: left"></td></tr>
<tr><td><code>dtmf_cb</code></td><td><code>void (*)(pjmedia_stream*, void*, int)</code></td><td>DTMF 回调函数。</td><td style="text-align: left"></td></tr>
<tr><td><code>dtmf_cb_user_data</code></td><td><code>void*</code></td><td>DTMF 回调函数的用户数据。</td><td style="text-align: left"></td></tr>
<tr><td><code>dtmf_event_cb</code></td><td><code>void (*)(pjmedia_stream*, void*, const pjmedia_stream_dtmf_event*)</code></td><td>DTMF 事件回调函数。</td><td style="text-align: left"></td></tr>
<tr><td><code>dtmf_event_cb_user_data</code></td><td><code>void*</code></td><td>DTMF 事件回调函数的用户数据。</td><td style="text-align: left"></td></tr>
<tr><td><code>has_g722_mpeg_bug</code></td><td><code>pj_bool_t</code></td><td>是否存在 G722 MPEG Bug。</td><td style="text-align: left"></td></tr>
<tr><td><code>rtp_tx_ts_len_per_pkt</code></td><td><code>unsigned</code></td><td>每个发送包的标准化 TS 长度。</td><td style="text-align: left"></td></tr>
<tr><td><code>rtp_rx_ts_len_per_frame</code></td><td><code>unsigned</code></td><td>每个接收帧的标准化 TS 长度。</td><td style="text-align: left"></td></tr>
<tr><td><code>rtp_rx_last_cnt</code></td><td><code>unsigned</code></td><td>上一个包中的帧数。</td><td style="text-align: left"></td></tr>
<tr><td><code>rtp_rx_check_cnt</code></td><td><code>unsigned</code></td><td>远程时间戳检查计数器。</td><td style="text-align: left"></td></tr>
<tr><td><code>rtcp_xr_last_tx</code></td><td><code>pj_uint32_t</code></td><td>上次发送 RTCP XR 的时间戳。</td><td style="text-align: left"></td></tr>
<tr><td><code>rtcp_xr_interval</code></td><td><code>pj_uint32_t</code></td><td>RTCP XR 的间隔时间戳。</td><td style="text-align: left"></td></tr>
<tr><td><code>rtcp_xr_dest</code></td><td><code>pj_sockaddr</code></td><td>附加的远程 RTCP XR 目标。</td><td style="text-align: left"></td></tr>
<tr><td><code>rtcp_xr_dest_len</code></td><td><code>unsigned</code></td><td>RTCP XR 目标地址的长度。</td><td style="text-align: left"></td></tr>
<tr><td><code>use_ka</code></td><td><code>pj_bool_t</code></td><td>是否启用了流的保活机制。</td><td style="text-align: left"></td></tr>
<tr><td><code>ka_interval</code></td><td><code>unsigned</code></td><td>发送保活的间隔。</td><td style="text-align: left"></td></tr>
<tr><td><code>last_frm_ts_sent</code></td><td><code>pj_time_val</code></td><td>上次发送包的时间。</td><td style="text-align: left"></td></tr>
<tr><td><code>start_ka_count</code></td><td><code>unsigned</code></td><td>创建后要发送的保活数量。</td><td style="text-align: left"></td></tr>
<tr><td><code>start_ka_interval</code></td><td><code>unsigned</code></td><td>流创建后的保活发送间隔。</td><td style="text-align: left"></td></tr>
<tr><td><code>rem_rtp_addr</code></td><td><code>pj_sockaddr</code></td><td>远程 RTP 地址。</td><td style="text-align: left"></td></tr>
<tr><td><code>rem_rtp_flag</code></td><td><code>unsigned</code></td><td>来自该地址的数据包指示标志。</td><td style="text-align: left"></td></tr>
<tr><td><code>rtp_src_cnt</code></td><td><code>unsigned</code></td><td>来自该地址的数据包数量。</td><td style="text-align: left"></td></tr>
<tr><td><code>trace_jb_fd</code></td><td><code>pj_oshandle_t</code></td><td>抖动跟踪文件句柄。</td><td style="text-align: left"></td></tr>
<tr><td><code>trace_jb_buf</code></td><td><code>char*</code></td><td>抖动跟踪缓冲区。</td><td style="text-align: left"></td></tr>
<tr><td><code>rtp_rx_last_ts</code></td><td><code>pj_uint32_t</code></td><td>上次接收的 RTP 时间戳。</td><td style="text-align: left"></td></tr>
<tr><td><code>rtp_tx_err_cnt</code></td><td><code>pj_uint32_t</code></td><td>RTP 发送错误计数。</td><td style="text-align: left"></td></tr>
<tr><td><code>rtcp_tx_err_cnt</code></td><td><code>pj_uint32_t</code></td><td>RTCP 发送错误计数。</td><td style="text-align: left"></td></tr>
<tr><td><code>send_rtcp_fb_nack</code></td><td><code>pj_bool_t</code></td><td>是否发送 RTCP 反馈 NACK？</td><td style="text-align: left"></td></tr>
<tr><td><code>rtcp_fb_nack</code></td><td><code>pjmedia_rtcp_fb_nack</code></td><td>TX NACK 状态。</td><td style="text-align: left"></td></tr>
<tr><td><code>rtcp_fb_nack_cap_idx</code></td><td><code>int</code></td><td>RX NACK 能力索引。</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<pre><code class="language-c">    stream-&gt;endpt = endpt;
    stream-&gt;codec_mgr = pjmedia_endpt_get_codec_mgr(endpt);
    stream-&gt;dir = info-&gt;dir;
    stream-&gt;user_data = user_data;
    stream-&gt;rtcp_interval = (PJMEDIA_RTCP_INTERVAL-500 + (pj_rand()%1000)) *
                            info-&gt;fmt.clock_rate / 1000;
    stream-&gt;rtcp_sdes_bye_disabled = info-&gt;rtcp_sdes_bye_disabled;

    stream-&gt;tx_event_pt = info-&gt;tx_event_pt ? info-&gt;tx_event_pt : -1;
    stream-&gt;rx_event_pt = info-&gt;rx_event_pt ? info-&gt;rx_event_pt : -1;
    stream-&gt;last_dtmf = -1;
    stream-&gt;jb_last_frm = PJMEDIA_JB_NORMAL_FRAME;
    stream-&gt;rtcp_fb_nack.pid = -1;
    stream-&gt;soft_start_cnt = PJMEDIA_STREAM_SOFT_START;
		stream-&gt;cname = info-&gt;cname;
</code></pre>
<p>Create mutex to protect jitter buffer:</p>
<p>codec： <strong>Create and initialize codec</strong>: pjmedia_codec_mgr_alloc_codec   <strong>Get codec param:</strong> pjmedia_codec_mgr_get_default_param <strong>Init the codec</strong> pjmedia_codec_init(stream-&gt;codec, pool); <strong>Open the codec.</strong></p>
<p>pjmedia_codec_open(stream-&gt;codec, &amp;stream-&gt;codec_param);</p>
<pre><code class="language-c">    stream-&gt;dec_ptime = stream-&gt;codec_param.info.frm_ptime;
    stream-&gt;dec_ptime_denum = PJ_MAX(stream-&gt;codec_param.info.frm_ptime_denum,
                                     1);
    afd-&gt;bits_per_sample = 16;
    afd-&gt;frame_time_usec = stream-&gt;codec_param.info.frm_ptime *
                           stream-&gt;codec_param.setting.frm_per_pkt * 1000 /
                           stream-&gt;codec_param.info.frm_ptime_denum;
    stream-&gt;port.info.fmt.id = stream-&gt;codec_param.info.fmt_id;
</code></pre>
<p>重要stream对应port的回调</p>
<p>stream-&gt;port.put_frame = &amp;put_frame;</p>
<p>stream-&gt;port.get_frame = &amp;get_frame;</p>
<p>/* Init jitter buffer parameters: */</p>
<p>/* Create jitter buffer */</p>
<pre><code>status = pjmedia_jbuf_create(pool, &amp;stream-&gt;port.info.name,
                                 stream-&gt;frame_size,
                                 stream-&gt;codec_param.info.frm_ptime,
                                 jb_max, &amp;stream-&gt;jb);
</code></pre>
<p>Create decoder channel</p>
<p>Create encoder channel</p>
<pre><code class="language-c">status = create_channel( pool, stream, PJMEDIA_DIR_ENCODING,
                             info-&gt;tx_pt, info, &amp;stream-&gt;enc);
</code></pre>
<p>Init RTCP session:</p>
<p>Only attach transport when stream is ready.在attach之前初始化att_param 看两个回调</p>
<pre><code class="language-c">    att_param.rtp_cb2 = &amp;on_rx_rtp;
    att_param.rtcp_cb = &amp;on_rx_rtcp;
</code></pre>
<pre><code class="language-c">    stream-&gt;transport = tp;
    status = pjmedia_transport_attach2(tp, &amp;att_param);
    if (status != PJ_SUCCESS)
        goto err_cleanup;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pjsua_call"><a class="header" href="#pjsua_call">pjsua_call</a></h2>
<pre><code class="language-c">/** 
 * Structure to be attached to invite dialog. 
 * Given a dialog "dlg", application can retrieve this structure
 * by accessing dlg-&gt;mod_data[pjsua.mod.id].
 */
struct pjsua_call
{
    unsigned             index;     /**&lt; Index in pjsua array.              */
    pjsua_call_setting   opt;       /**&lt; Call setting.                      */
    pj_bool_t            opt_inited;/**&lt; Initial call setting has been set,
                                         to avoid different opt in answer.  */
    pjsip_inv_session   *inv;       /**&lt; The invite session.                */
    void                *user_data; /**&lt; User/application data.             */
    pjsip_status_code    last_code; /**&lt; Last status code seen.             */
    pj_str_t             last_text; /**&lt; Last status text seen.             */
    pj_time_val          start_time;/**&lt; First INVITE sent/received.        */
    pj_time_val          res_time;  /**&lt; First response sent/received.      */
    pj_time_val          conn_time; /**&lt; Connected/confirmed time.          */
    pj_time_val          dis_time;  /**&lt; Disconnect time.                   */
    pjsua_acc_id         acc_id;    /**&lt; Account index being used.          */
    int                  secure_level;/**&lt; Signaling security level.        */
    pjsua_call_hold_type call_hold_type; /**&lt; How to do call hold.          */
    pj_bool_t            local_hold;/**&lt; Flag for call-hold by local.       */
    void                *hold_msg;  /**&lt; Outgoing hold tx_data.             */
    pj_str_t             cname;     /**&lt; RTCP CNAME.                        */
    char                 cname_buf[16];/**&lt; cname buffer.                   */

    unsigned             med_cnt;   /**&lt; Number of media in SDP.            */
    pjsua_call_media     media[PJSUA_MAX_CALL_MEDIA]; /**&lt; Array of media   */
    unsigned             med_prov_cnt;/**&lt; Number of provisional media.     */
    pjsua_call_media     media_prov[PJSUA_MAX_CALL_MEDIA];
                                    /**&lt; Array of provisional media.        */
    pj_bool_t            med_update_success;
                                    /**&lt; Is media update successful?        */
    pj_bool_t            hanging_up;/**&lt; Is call in the process of hangup?  */

    int                  audio_idx; /**&lt; First active audio media.          */
    pj_mutex_t          *med_ch_mutex;/**&lt; Media channel callback's mutex.  */
    pjsua_med_tp_state_cb   med_ch_cb;/**&lt; Media channel callback.          */
    pjsua_med_tp_state_info med_ch_info;/**&lt; Media channel info.            */

    pjsip_evsub         *xfer_sub;  /**&lt; Xfer server subscription, if this
                                         call was triggered by xfer.        */
    pj_stun_nat_type     rem_nat_type; /**&lt; NAT type of remote endpoint.    */

    char    last_text_buf_[128];    /**&lt; Buffer for last_text.              */

    struct {
        int              retry_cnt;  /**&lt; Retry count.                      */
    } lock_codec;                    /**&lt; Data for codec locking when answer
                                          contains multiple codecs.         */

    struct {
        pjsip_dialog        *dlg;    /**&lt; Call dialog.                      */
        pjmedia_sdp_session *rem_sdp;/**&lt; Remote SDP.                       */
        pj_pool_t           *pool_prov;/**&lt; Provisional pool.               */
        pj_bool_t            med_ch_deinit;/**&lt; Media channel de-init-ed?   */
        union {
            struct {
                pjsua_msg_data  *msg_data;/**&lt; Headers for outgoing INVITE. */
                pj_bool_t        hangup;  /**&lt; Call is hangup?              */
            } out_call;
            struct {            
                call_answer      answers;/**&lt; A list of call answers.       */
                pj_bool_t        hangup;/**&lt; Call is hangup?                */
                pjsip_dialog    *replaced_dlg; /**&lt; Replaced dialog.        */
            } inc_call;
        } call_var;
    } async_call;                      /**&lt; Temporary storage for async
                                            outgoing/incoming call.         */

    pj_bool_t            rem_offerer;  /**&lt; Was remote SDP offerer?         */
    unsigned             rem_aud_cnt;  /**&lt; No of active audio in last remote
                                            offer.                          */
    unsigned             rem_vid_cnt;  /**&lt; No of active video in last remote
                                            offer.                          */
    
    pj_bool_t            rx_reinv_async;/**&lt; on_call_rx_reinvite() async.   */
    pj_timer_entry       reinv_timer;  /**&lt; Reinvite retry timer.           */
    pj_bool_t            reinv_pending;/**&lt; Pending until CONFIRMED state.  */
    pj_bool_t            reinv_ice_sent;/**&lt; Has reinvite for ICE upd sent? */
    pjsip_rx_data       *incoming_data;/**&lt; Cloned incoming call rdata.
                                            On pjsua2, when handling incoming 
                                            call, onCreateMediaTransport() will
                                            not be called since the call isn't
                                            created yet. This temporary 
                                            variable is used to handle such 
                                            case, see ticket #1916.         */

    struct {
        pj_bool_t        enabled;
        pj_bool_t        remote_sup;
        pj_bool_t        remote_dlg_est;
        pjsua_op_state   trickling;
        int              retrans18x_count;
        pj_bool_t        pending_info;
        pj_timer_entry   timer;
    } trickle_ice;

    pj_timer_entry       hangup_timer;  /**&lt; Hangup retry timer.            */
    unsigned             hangup_retry;  /**&lt; Number of hangup retries.      */
    unsigned             hangup_code;   /**&lt; Hangup code.                   */
    pj_str_t             hangup_reason; /**&lt; Hangup reason.                 */
    pjsua_msg_data      *hangup_msg_data;/**&lt; Hangup message data.          */
};
</code></pre>
<h3 id="pjsua_call_hold_type"><a class="header" href="#pjsua_call_hold_type">pjsua_call_hold_type</a></h3>
<pre><code class="language-c">/**
 * This enumeration specifies how we should offer call hold request to
 * remote peer. The default value is set by compile time constant
 * PJSUA_CALL_HOLD_TYPE_DEFAULT, and application may control the setting
 * on per-account basis by manipulating \a call_hold_type field in
 * #pjsua_acc_config.
 */
typedef enum pjsua_call_hold_type
{
    /**
     * This will follow RFC 3264 recommendation to use a=sendonly,
     * a=recvonly, and a=inactive attribute as means to signal call
     * hold status. This is the correct value to use.
     */
    PJSUA_CALL_HOLD_TYPE_RFC3264,

    /**
     * This will use the old and deprecated method as specified in RFC 2543,
     * and will offer c=0.0.0.0 in the SDP instead. Using this has many
     * drawbacks such as inability to keep the media transport alive while
     * the call is being put on hold, and should only be used if remote
     * does not understand RFC 3264 style call hold offer.
     */
    PJSUA_CALL_HOLD_TYPE_RFC2543

} pjsua_call_hold_type;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pjsua_acc"><a class="header" href="#pjsua_acc">pjsua_acc</a></h2>
<pre><code class="language-c">/**
 * Account
 */
typedef struct pjsua_acc
{
    pj_pool_t       *pool;          /**&lt; Pool for this account.         */
    pjsua_acc_config cfg;           /**&lt; Account configuration.         */
    pj_bool_t        valid;         /**&lt; Is this account valid?         */

    int              index;         /**&lt; Index in accounts array.       */
    pj_str_t         display;       /**&lt; Display name, if any.          */
    pj_str_t         user_part;     /**&lt; User part of local URI.        */
    pj_bool_t        is_sips;       /**&lt; Local URI uses "sips"?         */
    pj_str_t         contact;       /**&lt; Our Contact header.            */
    pj_str_t         reg_contact;   /**&lt; Contact header for REGISTER.
                                         It may be different than acc
                                         contact if outbound is used    */
    pj_bool_t        contact_rewritten;
                                    /**&lt; Contact rewrite has been done? */
    pjsip_host_port  via_addr;      /**&lt; Address for Via header         */
    pjsip_transport *via_tp;        /**&lt; Transport associated with
                                         the Via address                */

    pj_str_t         srv_domain;    /**&lt; Host part of reg server.       */
    int              srv_port;      /**&lt; Port number of reg server.     */

    pjsip_regc      *regc;          /**&lt; Client registration session.   */
    pj_status_t      reg_last_err;  /**&lt; Last registration error.       */
    int              reg_last_code; /**&lt; Last status last register.     */

    pj_str_t         reg_mapped_addr;/**&lt; Our addr as seen by reg srv.
                                          Only if allow_sdp_nat_rewrite
                                          is set                        */

    struct {
        pj_bool_t        active;    /**&lt; Flag of reregister status.     */
        pj_timer_entry   timer;     /**&lt; Timer for reregistration.      */
        void            *reg_tp;    /**&lt; Transport for registration.    */
        unsigned         attempt_cnt; /**&lt; Attempt counter.             */
    } auto_rereg;                   /**&lt; Reregister/reconnect data.     */

    pj_timer_entry   ka_timer;      /**&lt; Keep-alive timer for UDP.      */
    pjsip_transport *ka_transport;  /**&lt; Transport for keep-alive.      */
    pj_sockaddr      ka_target;     /**&lt; Destination address for K-A    */
    unsigned         ka_target_len; /**&lt; Length of ka_target.           */

    pjsip_route_hdr  route_set;     /**&lt; Complete route set inc. outbnd.*/
    pj_uint32_t      global_route_crc; /** CRC of global route setting. */
    pj_uint32_t      local_route_crc;  /** CRC of account route setting.*/

    unsigned         rfc5626_status;/**&lt; SIP outbound status:
                                           0: not used
                                           1: requested
                                           2: acknowledged by servers   */
    pj_str_t         rfc5626_instprm;/**&lt; SIP outbound instance param.  */
    pj_str_t         rfc5626_regprm;/**&lt; SIP outbound reg param.        */
    unsigned         rfc5626_flowtmr;/**&lt; SIP outbound flow timer.      */

    unsigned         cred_cnt;      /**&lt; Number of credentials.         */
    pjsip_cred_info  cred[PJSUA_ACC_MAX_PROXIES]; /**&lt; Complete creds.  */

    pj_bool_t        online_status; /**&lt; Our online status.             */
    pjrpid_element   rpid;          /**&lt; RPID element information.      */
    pjsua_srv_pres   pres_srv_list; /**&lt; Server subscription list.      */
    pjsip_publishc  *publish_sess;  /**&lt; Client publication session.    */
    pj_bool_t        publish_state; /**&lt; Last published online status   */

    pjsip_evsub     *mwi_sub;       /**&lt; MWI client subscription        */
    pjsip_dialog    *mwi_dlg;       /**&lt; Dialog for MWI sub.            */

    pj_uint16_t      next_rtp_port; /**&lt; Next RTP port to be used.      */
    pjsip_transport_type_e tp_type; /**&lt; Transport type (for local acc or
                                         transport binding)             */
    pjsua_ip_change_op ip_change_op;/**&lt; IP change process progress.    */
} pjsua_acc;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pjsua_data--pjsua_var"><a class="header" href="#pjsua_data--pjsua_var">pjsua_data  pjsua_var</a></h2>
<pre><code class="language-c">/**
 * Global pjsua application data.
 */
struct pjsua_data
{

    /* Control: */
    pj_caching_pool      cp;        /**&lt; Global pool factory.           */
    pj_pool_t           *pool;      /**&lt; pjsua's private pool.          */
    pj_pool_t           *timer_pool;/**&lt; pjsua's timer pool.            */
    pj_mutex_t          *mutex;     /**&lt; Mutex protection for this data */
    unsigned             mutex_nesting_level; /**&lt; Mutex nesting level. */
    pj_thread_t         *mutex_owner; /**&lt; Mutex owner.                 */
    pjsua_state          state;     /**&lt; Library state.                 */

    /* Logging: */
    pjsua_logging_config log_cfg;   /**&lt; Current logging config.        */
    pj_oshandle_t        log_file;  /**&lt;Output log file handle          */

    /* SIP: */
    pjsip_endpoint      *endpt;     /**&lt; Global endpoint.               */
    pjsip_module         mod;       /**&lt; pjsua's PJSIP module.          */
    pjsua_transport_data tpdata[8]; /**&lt; Array of transports.           */
    pjsip_tp_state_callback old_tp_cb; /**&lt; Old transport callback.     */

    /* Threading: */
    pj_bool_t            thread_quit_flag;  /**&lt; Thread quit flag.      */
    pj_thread_t         *thread[4];         /**&lt; Array of threads.      */

    /* STUN and resolver */
    pj_stun_config       stun_cfg;  /**&lt; Global STUN settings.          */
    pj_sockaddr          stun_srv;  /**&lt; Resolved STUN server address   */
    pj_status_t          stun_status; /**&lt; STUN server status.          */
    pjsua_stun_resolve   stun_res;  /**&lt; List of pending STUN resolution*/
    unsigned             stun_srv_idx; /**&lt; Resolved STUN server index  */
    unsigned             stun_opt;  /**&lt; STUN resolution option.        */
    pj_dns_resolver     *resolver;  /**&lt; DNS resolver.                  */   

    /* UPnP */
    pj_status_t          upnp_status; /**&lt; UPnP status.                 */

    /* Detected NAT type */
    pj_stun_nat_type     nat_type;      /**&lt; NAT type.                  */
    pj_status_t          nat_status;    /**&lt; Detection status.          */
    pj_bool_t            nat_in_progress; /**&lt; Detection in progress    */

    /* List of outbound proxies: */
    pjsip_route_hdr      outbound_proxy;

    /* Account: */
    unsigned             acc_cnt;            /**&lt; Number of accounts.   */
    pjsua_acc_id         default_acc;        /**&lt; Default account ID    */
    pjsua_acc            acc[PJSUA_MAX_ACC]; /**&lt; Account array.        */
    pjsua_acc_id         acc_ids[PJSUA_MAX_ACC]; /**&lt; Acc sorted by prio*/

    /* Calls: */
    pjsua_config         ua_cfg;                /**&lt; UA config.         */
    unsigned             call_cnt;              /**&lt; Call counter.      */
    pjsua_call           calls[PJSUA_MAX_CALLS];/**&lt; Calls array.       */
    pjsua_call_id        next_call_id;          /**&lt; Next call id to use*/

    /* Buddy; */
    unsigned             buddy_cnt;                 /**&lt; Buddy count.   */
    pjsua_buddy          buddy[PJSUA_MAX_BUDDIES];  /**&lt; Buddy array.   */

    /* Presence: */
    pj_timer_entry       pres_timer;/**&lt; Presence refresh timer.        */

    /* Media: */
    pjsua_media_config   media_cfg; /**&lt; Media config.                  */
    pjmedia_endpt       *med_endpt; /**&lt; Media endpoint.                */
    pjsua_conf_setting   mconf_cfg; /**&lt; Additionan conf. bridge. param */
    pjmedia_conf        *mconf;     /**&lt; Conference bridge.             */
    pj_bool_t            is_mswitch;/**&lt; Are we using audio switchboard
                                         (a.k.a APS-Direct)             */

    /* Sound device */
    pjmedia_aud_dev_index cap_dev;  /**&lt; Capture device ID.             */
    pjmedia_aud_dev_index play_dev; /**&lt; Playback device ID.            */
    pj_uint32_t          aud_svmask;/**&lt; Which settings to save         */
    pjmedia_aud_param    aud_param; /**&lt; User settings to sound dev     */
    pj_bool_t            aud_open_cnt;/**&lt; How many # device is opened  */
    pj_bool_t            no_snd;    /**&lt; No sound (app will manage it)  */
    pj_pool_t           *snd_pool;  /**&lt; Sound's private pool.          */
    pjmedia_snd_port    *snd_port;  /**&lt; Sound port.                    */
    pj_timer_entry       snd_idle_timer;/**&lt; Sound device idle timer.   */
    pjmedia_master_port *null_snd;  /**&lt; Master port for null sound.    */
    pjmedia_port        *null_port; /**&lt; Null port.                     */
    pj_bool_t            snd_is_on; /**&lt; Media flow is currently active */
    unsigned             snd_mode;  /**&lt; Sound device mode.             */

    /* Video device */
    pjmedia_vid_dev_index vcap_dev;  /**&lt; Capture device ID.            */
    pjmedia_vid_dev_index vrdr_dev;  /**&lt; Playback device ID.           */

    /* For keeping video device settings */
#if PJSUA_HAS_VIDEO
    pjmedia_vid_conf     *vid_conf;
    pj_uint32_t           vid_caps[PJMEDIA_VID_DEV_MAX_DEVS];
    pjmedia_vid_dev_param vid_param[PJMEDIA_VID_DEV_MAX_DEVS];
#endif

    /* File players: */
    unsigned             player_cnt;/**&lt; Number of file players.        */
    pjsua_file_data      player[PJSUA_MAX_PLAYERS];/**&lt; Array of players.*/

    /* File recorders: */
    unsigned             rec_cnt;   /**&lt; Number of file recorders.      */
    pjsua_file_data      recorder[PJSUA_MAX_RECORDERS];/**&lt; Array of recs.*/

    /* Video windows */
#if PJSUA_HAS_VIDEO
    pjsua_vid_win        win[PJSUA_MAX_VID_WINS]; /**&lt; Array of windows */
#endif

    /* Timer entry and event list */
    pjsua_timer_list     active_timer_list;
    pjsua_timer_list     timer_list;
    pjsua_event_list     event_list;
    pj_mutex_t          *timer_mutex;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sdp"><a class="header" href="#sdp">SDP</a></h2>
<p><a href="https://www.jianshu.com/p/94b118b8fd97">SDP协议简介</a></p>
<h3 id="pjmedia_sdp_session"><a class="header" href="#pjmedia_sdp_session">pjmedia_sdp_session</a></h3>
<pre><code class="language-c">/**
 * This structure describes SDP session description. A SDP session descriptor
 * contains complete information about a session, and normally is exchanged
 * with remote media peer using signaling protocol such as SIP.
 */
struct pjmedia_sdp_session
{
    /** Session origin (o= line) */
    struct
    {
        pj_str_t    user;           /**&lt; User                           */
        pj_uint_t   id;             /**&lt; Session ID                     */
        pj_uint_t   version;        /**&lt; Session version                */
        pj_str_t    net_type;       /**&lt; Network type ("IN")            */
        pj_str_t    addr_type;      /**&lt; Address type ("IP4", "IP6")    */
        pj_str_t    addr;           /**&lt; The address.                   */
    } origin;

    pj_str_t           name;        /**&lt; Subject line (s=)              */
    pjmedia_sdp_conn  *conn;        /**&lt; Connection line (c=)           */
    unsigned           bandw_count; /**&lt; Number of bandwidth info (b=)  */
    pjmedia_sdp_bandw *bandw[PJMEDIA_MAX_SDP_BANDW];
                                    /**&lt; Bandwidth info array (b=)      */
    
    /** Session time (t= line)  */
    struct
    {
        pj_uint_t start;            /**&lt; Start time.                    */
        pj_uint_t stop;             /**&lt; Stop time.                     */
    } time;

    unsigned           attr_count;              /**&lt; Number of attributes.  */
    pjmedia_sdp_attr  *attr[PJMEDIA_MAX_SDP_ATTR]; /**&lt; Attributes array.   */

    unsigned           media_count;             /**&lt; Number of media.       */
    pjmedia_sdp_media *media[PJMEDIA_MAX_SDP_MEDIA];    /**&lt; Media array.   */

};

</code></pre>
<h3 id="pjmedia_sdp_attr"><a class="header" href="#pjmedia_sdp_attr">pjmedia_sdp_attr</a></h3>
<pre><code class="language-c">/** 
 * Generic representation of attribute.
 */
struct pjmedia_sdp_attr
{
    pj_str_t            name;       /**&lt; Attribute name.    */
    pj_str_t            value;      /**&lt; Attribute value.   */
};

</code></pre>
<h3 id="pjmedia_sdp_media"><a class="header" href="#pjmedia_sdp_media">pjmedia_sdp_media</a></h3>
<pre><code class="language-c">/**
 * This structure describes SDP media descriptor. A SDP media descriptor
 * starts with "m=" line and contains the media attributes and optional
 * connection line.
 */
struct pjmedia_sdp_media
{
    /** Media descriptor line ("m=" line) */
    struct
    {
        pj_str_t    media;              /**&lt; Media type ("audio", "video")  */
        pj_uint16_t port;               /**&lt; Port number.                   */
        unsigned    port_count;         /**&lt; Port count, used only when &gt;2  */
        pj_str_t    transport;          /**&lt; Transport ("RTP/AVP")          */
        unsigned    fmt_count;          /**&lt; Number of formats.             */
        pj_str_t    fmt[PJMEDIA_MAX_SDP_FMT];       /**&lt; Media formats.     */
    } desc;

    pjmedia_sdp_conn   *conn;           /**&lt; Optional connection info.      */
    unsigned            bandw_count;    /**&lt; Number of bandwidth info.      */
    pjmedia_sdp_bandw  *bandw[PJMEDIA_MAX_SDP_BANDW]; /**&lt; Bandwidth info.  */
    unsigned            attr_count;     /**&lt; Number of attributes.          */
    pjmedia_sdp_attr   *attr[PJMEDIA_MAX_SDP_ATTR];   /**&lt; Attributes.      */

};
</code></pre>
<h3 id="pjmedia_sdp_conn"><a class="header" href="#pjmedia_sdp_conn">pjmedia_sdp_conn</a></h3>
<pre><code class="language-c">/**
 * This structure describes SDP connection info ("c=" line). 
 */
struct pjmedia_sdp_conn
{
    pj_str_t    net_type;       /**&lt; Network type ("IN").               */
    pj_str_t    addr_type;      /**&lt; Address type ("IP4", "IP6").       */
    pj_str_t    addr;           /**&lt; The address.                       */
    pj_uint8_t  ttl;            /**&lt; Multicast address TTL              */
    pj_uint8_t  no_addr;        /**&lt; Multicast number of addresses      */
};
</code></pre>
<h3 id="pjmedia_sdp_bandw"><a class="header" href="#pjmedia_sdp_bandw">pjmedia_sdp_bandw</a></h3>
<pre><code class="language-c">/**
 * This structure describes SDP bandwidth info ("b=" line). 
 */
typedef struct pjmedia_sdp_bandw
{
    pj_str_t    modifier;       /**&lt; Bandwidth modifier.                */
    pj_uint32_t value;          /**&lt; Bandwidth value.                   */
} pjmedia_sdp_bandw;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dialog"><a class="header" href="#dialog"><strong>Dialog</strong></a></h2>
<p><img src="../img/dialog.png" alt="img" /></p>
<h3 id="dialog-structure"><a class="header" href="#dialog-structure"><strong>Dialog Structure</strong></a></h3>
<pre><code class="language-c"> // This structure is used to describe dialog's participants, local and remote party.
struct pjsip_dlg_party
{
    pjsip_fromto_hdr *info; // From/To header, inc tag
    pj_uint32_t tag_hval; // Hashed value of the tag
    pjsip_contact_hdr *contact; // Contact header.
    pj_int32_t first_cseq; // First CSeq seen.
    pj_int32_t cseq; // Next sequence number.
};
// This structure describes basic dialog.
struct pjsip_dialog
{
    PJ_DECL_LIST_MEMBER(pjsip_dialog); // List node in dialog set.
// Static properties:
   char obj_name[PJ_MAX_OBJ_NAME]; // Log identification
    pj_pool_t *pool; // Dialog’s memory pool.
    pj_mutex_t *mutex; // Dialog's mutex.
    pjsip_user_agent *ua; // User agent instance.
    void *dlg_set; // The dialog set.
// Dialog session properties.
    pjsip_uri *target; // Current target.
    pjsip_dlg_party local; // Local party info.
    pjsip_dlg_party remote; // Remote party info.
    pjsip_role_e role; // Initial role.
    pj_bool_t secure; // Use secure transport?
    pjsip_cid_hdr *call_id; // Call-ID header.
    pjsip_route_hdr route_set; // Route set list.
    pjsip_auth_clt_sess auth_sess; // Client authentication session.
// Session Management
    int sess_count; // Session counter.
    int tsx_count; // Active transaction counter.
// Dialog usages
    unsigned usage_cnt; // Number of registered usages.
    pjsip_module *usage[PJSIP_MAX_MODULE]; // Usages, priority sorted
// Module specific data.
    void *mod_data[PJSIP_M AX_MODULE];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="session"><a class="header" href="#session">Session</a></h2>
<h3 id="invite-session"><a class="header" href="#invite-session">invite session</a></h3>
<pre><code class="language-c">/**
 * This structure describes the invite session.
 *
 * Note regarding the invite session's pools. The inv_sess used to have
 * only one pool, which is just a pointer to the dialog's pool. Ticket
 * https://github.com/pjsip/pjproject/issues/877 has found that the memory
 * usage will grow considerably everytime re-INVITE or UPDATE is
 * performed.
 *
 * Ticket #877 then created two more memory pools for the inv_sess, so
 * now we have three memory pools:
 *  - pool: to be used to allocate long term data for the session
 *  - pool_prov and pool_active: this is a flip-flop pools to be used
 *     interchangably during re-INVITE and UPDATE. pool_prov is
 *     "provisional" pool, used to allocate SDP offer or answer for
 *     the re-INVITE and UPDATE. Once SDP negotiation is done, the
 *     provisional pool will be made as the active pool, then the
 *     existing active pool will be reset, to release the memory
 *     back to the OS. So these pool's lifetime is synchronized to
 *     the SDP offer-answer negotiation.
 *
 * Higher level application such as PJSUA-LIB has been modified to
 * make use of these flip-flop pools, i.e. by creating media objects
 * from the provisional pool rather than from the long term pool.
 *
 * Other applications that want to use these pools must understand
 * that the flip-flop pool's lifetimes are synchronized to the
 * SDP offer-answer negotiation.
 *
 * The lifetime of this session is controlled by the reference counter in this
 * structure, which is manipulated by calling #pjsip_inv_add_ref and
 * #pjsip_inv_dec_ref. When the reference counter has reached zero, then
 * this session will be destroyed.
 */
struct pjsip_inv_session
{
    char                 obj_name[PJ_MAX_OBJ_NAME]; /**&lt; Log identification */
    pj_pool_t           *pool;                      /**&lt; Long term pool.    */
    pj_pool_t           *pool_prov;                 /**&lt; Provisional pool   */
    pj_pool_t           *pool_active;               /**&lt; Active/current pool*/
    pjsip_inv_state      state;                     /**&lt; Invite sess state. */
    pj_bool_t            cancelling;                /**&lt; CANCEL requested   */
    pj_bool_t            pending_cancel;            /**&lt; Wait to send CANCEL*/
    pjsip_tx_data       *pending_bye;               /**&lt; BYE to send later  */
    pjsip_status_code    cause;                     /**&lt; Disconnect cause.  */
    pj_str_t             cause_text;                /**&lt; Cause text.        */
    pj_bool_t            notify;                    /**&lt; Internal.          */
    pj_bool_t            sdp_done_early_rel;        /**&lt; Nego done in early
                                                         med was reliable?  */
    unsigned             cb_called;                 /**&lt; Cb has been called */
    pjsip_dialog        *dlg;                       /**&lt; Underlying dialog. */
    pjsip_role_e         role;                      /**&lt; Invite role.       */
    unsigned             options;                   /**&lt; Options in use.    */
    pjmedia_sdp_neg     *neg;                       /**&lt; Negotiator.        */
    unsigned             sdp_neg_flags;             /**&lt; SDP neg flags.     */
    pjsip_transaction   *invite_tsx;                /**&lt; 1st invite tsx.    */
    pjsip_tx_data       *invite_req;                /**&lt; Saved invite req   */
    pjsip_tx_data       *last_answer;               /**&lt; Last INVITE resp.  */
    pjsip_tx_data       *last_ack;                  /**&lt; Last ACK request   */
    pj_int32_t           last_ack_cseq;             /**&lt; CSeq of last ACK   */
    void                *mod_data[PJSIP_MAX_MODULE];/**&lt; Modules data.      */
    struct pjsip_timer  *timer;                     /**&lt; Session Timers.    */
    pj_bool_t            following_fork;            /**&lt; Internal, following
                                                         forked media?      */
    pj_atomic_t         *ref_cnt;                   /**&lt; Reference counter. */
    pj_bool_t            updated_sdp_answer;        /**&lt; SDP answer just been
                                                         updated?           */
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="transaction"><a class="header" href="#transaction">transaction</a></h2>
<h3 id="invite-session-data-to-be-attached-to-transaction"><a class="header" href="#invite-session-data-to-be-attached-to-transaction">Invite session data to be attached to transaction.</a></h3>
<pre><code class="language-c">/* Invite session data to be attached to transaction. */
struct tsx_inv_data
{
    pjsip_inv_session   *inv;       /* The invite session                   */
    pj_bool_t            sdp_done;  /* SDP negotiation done for this tsx?   */
    pj_bool_t            retrying;  /* Resend (e.g. due to 401/407)         */
    pj_str_t             done_tag;  /* To tag in RX response with answer    */
    pj_bool_t            done_early;/* Negotiation was done for early med?  */
    pj_bool_t            done_early_rel;/* Early med was realiable?         */
    pj_bool_t            has_sdp;   /* Message with SDP?                    */
};

</code></pre>
<h3 id="pjsip_transaction"><a class="header" href="#pjsip_transaction">pjsip_transaction</a></h3>
<pre><code class="language-c">/**
 * This structure describes SIP transaction object. The transaction object
 * is used to handle both UAS and UAC transaction.
 */
struct pjsip_transaction
{
    /*
     * Administrivia
     */
    pj_pool_t                  *pool;           /**&lt; Pool owned by the tsx. */
    pjsip_module               *tsx_user;       /**&lt; Transaction user.      */
    pjsip_endpoint             *endpt;          /**&lt; Endpoint instance.     */
    pj_bool_t                   terminating;    /**&lt; terminate() was called */
    pj_grp_lock_t              *grp_lock;       /**&lt; Transaction grp lock.  */
    pj_mutex_t                 *mutex_b;        /**&lt; Second mutex to avoid
                                                     deadlock. It is used to
                                                     protect timer.         */

    /*
     * Transaction identification.
     */
    char                        obj_name[PJ_MAX_OBJ_NAME];  /**&lt; Log info.  */
    pjsip_role_e                role;           /**&lt; Role (UAS or UAC)      */
    pjsip_method                method;         /**&lt; The method.            */
    pj_int32_t                  cseq;           /**&lt; The CSeq               */
    pj_str_t                    transaction_key;/**&lt; Hash table key.        */
    pj_str_t                    transaction_key2;/**&lt; Hash table key (2)   
                                                     for merged requests
                                                     tsx lookup.            */
    pj_uint32_t                 hashed_key;     /**&lt; Key's hashed value.    */
    pj_uint32_t                 hashed_key2;    /**&lt; Key's hashed value (2).*/
    pj_str_t                    branch;         /**&lt; The branch Id.         */

    /*
     * State and status.
     */
    int                         status_code;    /**&lt; Last status code seen. */
    pj_str_t                    status_text;    /**&lt; Last reason phrase.    */
    pjsip_tsx_state_e           state;          /**&lt; State.                 */
    int                         handle_200resp; /**&lt; UAS 200/INVITE  retrsm.*/
    int                         tracing;        /**&lt; Tracing enabled?       */

    /** Handler according to current state. */
    pj_status_t (*state_handler)(struct pjsip_transaction *, pjsip_event *);

    /*
     * Transport.
     */
    pjsip_transport            *transport;      /**&lt; Transport to use.      */
    pj_bool_t                   is_reliable;    /**&lt; Transport is reliable. */
    pj_sockaddr                 addr;           /**&lt; Destination address.   */
    int                         addr_len;       /**&lt; Address length.        */
    pjsip_response_addr         res_addr;       /**&lt; Response address.      */
    unsigned                    transport_flag; /**&lt; Miscelaneous flag.     */
    pj_status_t                 transport_err;  /**&lt; Internal error code.   */
    pjsip_tpselector            tp_sel;         /**&lt; Transport selector.    */
    pjsip_tx_data              *pending_tx;     /**&lt; Tdata which caused
                                                     pending transport flag
                                                     to be set on tsx.      */
    pjsip_tp_state_listener_key *tp_st_key;     /**&lt; Transport state listener
                                                     key.                   */

    /*
     * Messages and timer.
     */
    pjsip_tx_data              *last_tx;        /**&lt; Msg kept for retrans.  */
    int                         retransmit_count;/**&lt; Retransmission count. */
    pj_timer_entry              retransmit_timer;/**&lt; Retransmit timer.     */
    pj_timer_entry              timeout_timer;  /**&lt; Timeout timer.         */

    /** Module specific data. */
    void                       *mod_data[PJSIP_MAX_MODULE];
};
</code></pre>
<pre><code class="language-mermaid">graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="transport-1"><a class="header" href="#transport-1">transport</a></h2>
<pre><code class="language-c">/**
 * This structure represent the "public" interface of a SIP transport.
 * Applications normally extend this structure to include transport
 * specific members.
 */
struct pjsip_transport
{
    char                    obj_name[PJ_MAX_OBJ_NAME];  /**&lt; Name. */

    pj_pool_t              *pool;           /**&lt; Pool used by transport.    */
    pj_atomic_t            *ref_cnt;        /**&lt; Reference counter.         */
    pj_lock_t              *lock;           /**&lt; Lock object.               */
    pj_grp_lock_t          *grp_lock;       /**&lt; Group lock for sync with
                                                 ioqueue and timer.         */
    pj_bool_t               tracing;        /**&lt; Tracing enabled?           */
    pj_bool_t               is_shutdown;    /**&lt; Being shutdown?            */
    pj_bool_t               is_destroying;  /**&lt; Destroy in progress?       */

    /** Key for indexing this transport in hash table. */
    pjsip_transport_key     key;

    char                   *type_name;      /**&lt; Type name.                 */
    unsigned                flag;           /**&lt; #pjsip_transport_flags_e   */
    char                   *info;           /**&lt; Transport info/description.*/

    int                     addr_len;       /**&lt; Length of addresses.       */
    pj_sockaddr             local_addr;     /**&lt; Bound address.             */
    pjsip_host_port         local_name;     /**&lt; Published name (eg. STUN). */
    pjsip_host_port         remote_name;    /**&lt; Remote address name.       */
    pjsip_transport_dir     dir;            /**&lt; Connection direction.      */
    
    pjsip_endpoint         *endpt;          /**&lt; Endpoint instance.         */
    pjsip_tpmgr            *tpmgr;          /**&lt; Transport manager.         */
    pjsip_tpfactory        *factory;        /**&lt; Factory instance. Note: it
                                                 may be invalid/shutdown.   */
    pj_timer_entry          idle_timer;     /**&lt; Timer when ref cnt is zero.*/

    pj_timestamp            last_recv_ts;   /**&lt; Last time receiving data.  */
    pj_size_t               last_recv_len;  /**&lt; Last received data length. */

    void                   *data;           /**&lt; Internal transport data.   */
    unsigned                initial_timeout;/**&lt; Initial timeout interval
                                                 to be applied to incoming
                                                 TCP/TLS transports when no
                                                 valid data received after
                                                 a successful connection.   */

    /**
     * Function to be called by transport manager to send SIP message.
     *
     * @param transport     The transport to send the message.
     * @param packet        The buffer to send.
     * @param length        The length of the buffer to send.
     * @param op_key        Completion token, which will be supplied to
     *                      caller when pending send operation completes.
     * @param rem_addr      The remote destination address.
     * @param addr_len      Size of remote address.
     * @param callback      If supplied, the callback will be called
     *                      once a pending transmission has completed. If
     *                      the function completes immediately (i.e. return
     *                      code is not PJ_EPENDING), the callback will not
     *                      be called.
     *
     * @return              Should return PJ_SUCCESS only if data has been
     *                      succesfully queued to operating system for 
     *                      transmission. Otherwise it may return PJ_EPENDING
     *                      if the underlying transport can not send the
     *                      data immediately and will send it later, which in
     *                      this case caller doesn't have to do anything 
     *                      except wait the calback to be called, if it 
     *                      supplies one.
     *                      Other return values indicate the error code.
     */
    pj_status_t (*send_msg)(pjsip_transport *transport, 
                            pjsip_tx_data *tdata,
                            const pj_sockaddr_t *rem_addr,
                            int addr_len,
                            void *token,
                            pjsip_transport_callback callback);

    /**
     * Instruct the transport to initiate graceful shutdown procedure.
     * After all objects release their reference to this transport,
     * the transport will be deleted.
     *
     * Note that application MUST use #pjsip_transport_shutdown() instead.
     *
     * @param transport     The transport.
     *
     * @return              PJ_SUCCESS on success.
     */
    pj_status_t (*do_shutdown)(pjsip_transport *transport);

    /**
     * Forcefully destroy this transport regardless whether there are
     * objects that currently use this transport. This function should only
     * be called by transport manager or other internal objects (such as the
     * transport itself) who know what they're doing. Application should use
     * #pjsip_transport_shutdown() instead.
     *
     * @param transport     The transport.
     *
     * @return              PJ_SUCCESS on success.
     */
    pj_status_t (*destroy)(pjsip_transport *transport);

    /*
     * Application may extend this structure..
     */
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="data-structure-for-sending-outgoing-message"><a class="header" href="#data-structure-for-sending-outgoing-message">Data structure for sending outgoing message</a></h2>
<pre><code class="language-c">/**
 * Data structure for sending outgoing message. Application normally creates
 * this buffer by calling #pjsip_endpt_create_tdata.
 *
 * The lifetime of this buffer is controlled by the reference counter in this
 * structure, which is manipulated by calling #pjsip_tx_data_add_ref and
 * #pjsip_tx_data_dec_ref. When the reference counter has reached zero, then
 * this buffer will be destroyed.
 *
 * A transaction object normally will add reference counter to this buffer
 * when application calls #pjsip_tsx_send_msg, because it needs to keep the
 * message for retransmission. The transaction will release the reference
 * counter once its state has reached final state.
 */
struct pjsip_tx_data
{
    /** This is for transmission queue; it's managed by transports. */
    PJ_DECL_LIST_MEMBER(struct pjsip_tx_data);

    /** Memory pool for this buffer. */
    pj_pool_t           *pool;

    /** A name to identify this buffer. */
    char                 obj_name[PJ_MAX_OBJ_NAME];

    /** Short information describing this buffer and the message in it. 
     *  Application should use #pjsip_tx_data_get_info() instead of
     *  directly accessing this member.
     */
    char                *info;

    /** For response message, this contains the reference to timestamp when 
     *  the original request message was received. The value of this field
     *  is set when application creates response message to a request by
     *  calling #pjsip_endpt_create_response.
     */
    pj_time_val          rx_timestamp;

    /** The transport manager for this buffer. */
    pjsip_tpmgr         *mgr;

    /** Ioqueue asynchronous operation key. */
    pjsip_tx_data_op_key op_key;

    /** Lock object. */
    pj_lock_t           *lock;

    /** The message in this buffer. */
    pjsip_msg           *msg;

    /** Strict route header saved by #pjsip_process_route_set(), to be
     *  restored by #pjsip_restore_strict_route_set().
     */
    pjsip_route_hdr     *saved_strict_route;

    /** Buffer to the printed text representation of the message. When the
     *  content of this buffer is set, then the transport will send the content
     *  of this buffer instead of re-printing the message structure. If the
     *  message structure has changed, then application must invalidate this
     *  buffer by calling #pjsip_tx_data_invalidate_msg.
     */
    pjsip_buffer         buf;

    /** Reference counter. */
    pj_atomic_t         *ref_cnt;

    /** Being processed by transport? */
    int                  is_pending;

    /** Transport manager internal. */
    void                *token;

    /** Callback to be called when this tx_data has been transmitted.   */
    void               (*cb)(void*, pjsip_tx_data*, pj_ssize_t);

    /** Destination information, to be used to determine the network address
     *  of the message. For a request, this information is  initialized when
     *  the request is sent with #pjsip_endpt_send_request_stateless() and
     *  network address is resolved. For CANCEL request, this information
     *  will be copied from the original INVITE to make sure that the CANCEL
     *  request goes to the same physical network address as the INVITE
     *  request.
     */
    struct
    {
        /** Server name. 
         */
        pj_str_t                 name;

        /** Server addresses resolved. 
         */
        pjsip_server_addresses   addr;

        /** Current server address being tried. 
         */
        unsigned cur_addr;

    } dest_info;

    /** Transport information, only valid during on_tx_request() and 
     *  on_tx_response() callback.
     */
    struct
    {
        pjsip_transport     *transport;     /**&lt; Transport being used.  */
        pj_sockaddr          dst_addr;      /**&lt; Destination address.   */
        int                  dst_addr_len;  /**&lt; Length of address.     */
        char                 dst_name[PJ_INET6_ADDRSTRLEN]; /**&lt; Destination address.   */
        int                  dst_port;      /**&lt; Destination port.      */
    } tp_info;

    /** 
     * Transport selector, to specify which transport to be used. 
     * The value here must be set with pjsip_tx_data_set_transport(),
     * to allow reference counter to be set properly.
     */
    pjsip_tpselector        tp_sel;

    /**
     * Special flag to indicate that this transmit data is a request that has
     * been updated with proper authentication response and is ready to be
     * sent for retry.
     */
    pj_bool_t               auth_retry;

    /**
     * Arbitrary data attached by PJSIP modules.
     */
    void                    *mod_data[PJSIP_MAX_MODULE];

    /**
     * If via_addr is set, it will be used as the "sent-by" field of the
     * Via header for outgoing requests as long as the request uses via_tp
     * transport. Normally application should not use or access these fields.
     */
    pjsip_host_port          via_addr;      /**&lt; Via address.           */
    const void              *via_tp;        /**&lt; Via transport.         */
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pjsip-log"><a class="header" href="#pjsip-log">PJSIP log</a></h1>
<p><strong>日志用法</strong></p>
<p>使用之前需要初始化日志，但这一步是内部函数pj_init自己调用的，应用程序无需显示调用。</p>
<pre><code class="language-cpp">/**
 * Internal function to be called by pj_init()
 */

pj_status_t pj_log_init(void);
*   PJ_LOG(3, ("main.c", "Starting hello..."));

*   PJ_LOG(3, ("main.c", "Hello world from process %d", pj_getpid()));
</code></pre>
<p>3表示日志级别，级别越高值越小，main.c表示日志发送者，即写日志的模块，类似于tag，后面就是格式化字符串。</p>
<p><strong>日志API</strong></p>
<pre><code class="language-cpp">#define PJ_LOG(level,arg)	do { \

				    if (level &lt;= pj_log_get_level()) { \

						pj_log_wrapper_##level(arg); \

				    } \
				    
				} while (0)
</code></pre>
<p>日志一般使用上面的宏，该宏会判断输入等级是否高于设置的等级（等级越高值越小，所以是&lt;=），是则调用对应的等级函数。</p>
<p>pj_log_wrapper_1到pj_log_wrapper_6最终都是调用最底层的函数pj_log。</p>
<pre><code class="language-cpp">/**
 * Write to log.
 *
 * @param sender    Source of the message.
 * @param level	    Verbosity level.
 * @param format    Format.
 * @param marker    Marker.
 */

PJ_DECL(void) pj_log(const char *sender, int level, const char *format, va_list marker);
</code></pre>
<p>pj_log根据样式的配置组织字符串，最后调用log_writer写入不同的对象。</p>
<p><strong>日志配置</strong></p>
<p>日志的配置非常灵活，有哪些配置呢</p>
<pre><code class="language-cpp">/**
 * Log decoration flag, to be specified with #pj_log_set_decor().
 */

enum pj_log_decoration
{

    PJ_LOG_HAS_DAY_NAME   =    1, /**&lt; Include day name [default: no] 	      */

    PJ_LOG_HAS_YEAR       =    2, /**&lt; Include year digit [no]		      */

    PJ_LOG_HAS_MONTH	  =    4, /**&lt; Include month [no]		      */

    PJ_LOG_HAS_DAY_OF_MON =    8, /**&lt; Include day of month [no]	      */

    PJ_LOG_HAS_TIME	  =   16, /**&lt; Include time [yes]		      */

    PJ_LOG_HAS_MICRO_SEC  =   32, /**&lt; Include microseconds [yes]             */

    PJ_LOG_HAS_SENDER	  =   64, /**&lt; Include sender in the log [yes] 	      */

    PJ_LOG_HAS_NEWLINE	  =  128, /**&lt; Terminate each call with newline [yes] */

    PJ_LOG_HAS_CR	  =  256, /**&lt; Include carriage return [no] 	      */

    PJ_LOG_HAS_SPACE	  =  512, /**&lt; Include two spaces before log [yes]    */

    PJ_LOG_HAS_COLOR	  = 1024, /**&lt; Colorize logs [yes on win32]	      */

    PJ_LOG_HAS_LEVEL_TEXT = 2048, /**&lt; Include level text string [no]	      */

    PJ_LOG_HAS_THREAD_ID  = 4096, /**&lt; Include thread identification [no]     */

    PJ_LOG_HAS_THREAD_SWC = 8192, /**&lt; Add mark when thread has switched [yes]*/

    PJ_LOG_HAS_INDENT     =16384  /**&lt; Indentation. Say yes! [yes]            */

};
</code></pre>
<p>从上面看，比较重要的有时间格式，发送者tag，和线程名字，可以通过pj_log_set_decor接口设置，比如。</p>
<pre><code class="language-cpp">int param_log_decor = PJ_LOG_HAS_NEWLINE | PJ_LOG_HAS_TIME | PJ_LOG_HAS_MICRO_SEC;

pj_log_set_decor(param_log_decor);
</code></pre>
<p>设置日志等级</p>
<pre><code class="language-cpp">PJ_DECL(void) pj_log_set_level(int level);
</code></pre>
<p>设置颜色</p>
<pre><code class="language-cpp">PJ_DECL(void) pj_log_set_color(int level, pj_color_t color);
</code></pre>
<p>设置缩进排版</p>
<pre><code class="language-cpp">/**
 * Add indentation to log message. Indentation will add PJ_LOG_INDENT_CHAR
 * before the message, and is useful to show the depth of function calls.
 *
 * @param indent    The indentation to add or substract. Positive value
 * 		    adds current indent, negative value subtracts current
 * 		    indent.
 */

PJ_DECL(void) pj_log_add_indent(int indent);

/**
 * Push indentation to the right by default value (PJ_LOG_INDENT).
 */

PJ_DECL(void) pj_log_push_indent(void);

/**
 * Pop indentation (to the left) by default value (PJ_LOG_INDENT).
 */

PJ_DECL(void) pj_log_pop_indent(void);
</code></pre>
<p><strong>输出对象</strong></p>
<p>pj_log最终调用log_writer写到输出对象，log_writer是一个函数回调指针</p>
<pre><code class="language-cpp">/**
 * Signature for function to be registered to the logging subsystem to
 * write the actual log message to some output device.
 *
 * @param level	    Log level.
 * @param data	    Log message, which will be NULL terminated.
 * @param len	    Message length.
 */

typedef void pj_log_func(int level, const char *data, int len);

static pj_log_func *log_writer = &amp;pj_log_write;
</code></pre>
<p>pj_log_write则在编译时指定编译为printk、printf等。对应log_write_printk.c、log_write_stdout.c，可以看出，如果我们想把日志保存的文件，自己实现一个pj_log_write函数，在函数里写到文件即可。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
