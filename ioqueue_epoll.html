<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ioqueue_epoll - PJSIP_STUDY</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="SIP.html"><strong aria-hidden="true">1.</strong> sip协议概述</a></li><li class="chapter-item expanded "><a href="pjsip_doc.html"><strong aria-hidden="true">2.</strong> pjsip文档翻译</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> make call流程</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="State.html"><strong aria-hidden="true">3.1.</strong> 状态机</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> 流程图</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="html/make_call.html"><strong aria-hidden="true">3.2.1.</strong> make call流程图</a></li><li class="chapter-item expanded "><a href="html/pjsip_dlg_create_uac.html"><strong aria-hidden="true">3.2.2.</strong> Create an UAC dialog</a></li><li class="chapter-item expanded "><a href="html/on_make_call_med_tp_complete.html"><strong aria-hidden="true">3.2.3.</strong> Outgoing call callback when media transport creation is completed</a></li><li class="chapter-item expanded "><a href="html/tsx_on_state_null.html"><strong aria-hidden="true">3.2.4.</strong> tsx_on_state_null状态处理</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> pjmedia学习</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="发送数据全流程.html"><strong aria-hidden="true">4.1.</strong> 发送数据过程</a></li><li class="chapter-item expanded "><a href="数据全流程.html"><strong aria-hidden="true">4.2.</strong> 接收数据过程</a></li><li class="chapter-item expanded "><a href="全流程思考.html"><strong aria-hidden="true">4.3.</strong> 初始化过程</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> 相关数据结构</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ioqueue_epoll.html" class="active"><strong aria-hidden="true">4.4.1.</strong> ioqueue_epoll</a></li><li class="chapter-item expanded "><a href="epoll学习.html"><strong aria-hidden="true">4.4.2.</strong> epoll</a></li><li class="chapter-item expanded "><a href="pjmedia_transport.html"><strong aria-hidden="true">4.4.3.</strong> pjmedia_transport</a></li><li class="chapter-item expanded "><a href="Port.html"><strong aria-hidden="true">4.4.4.</strong> pjmedia_port</a></li><li class="chapter-item expanded "><a href="Stream.html"><strong aria-hidden="true">4.4.5.</strong> pjmedia_stream</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 常见数据结构与工具</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="pjsua_call.html"><strong aria-hidden="true">5.1.</strong> pjsua_call</a></li><li class="chapter-item expanded "><a href="pjsua_acc.html"><strong aria-hidden="true">5.2.</strong> pjsua_acc</a></li><li class="chapter-item expanded "><a href="pjsua_data.html"><strong aria-hidden="true">5.3.</strong> pjsua_data</a></li><li class="chapter-item expanded "><a href="SDP.html"><strong aria-hidden="true">5.4.</strong> SDP</a></li><li class="chapter-item expanded "><a href="Dialog.html"><strong aria-hidden="true">5.5.</strong> Dialog</a></li><li class="chapter-item expanded "><a href="Session.html"><strong aria-hidden="true">5.6.</strong> Session</a></li><li class="chapter-item expanded "><a href="transaction.html"><strong aria-hidden="true">5.7.</strong> transaction</a></li><li class="chapter-item expanded "><a href="transport.html"><strong aria-hidden="true">5.8.</strong> transport</a></li><li class="chapter-item expanded "><a href="sendData.html"><strong aria-hidden="true">5.9.</strong> 数据发送数据结构</a></li><li class="chapter-item expanded "><a href="PJSIP_log.html"><strong aria-hidden="true">5.10.</strong> pjsip log</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PJSIP_STUDY</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="ioqueue_epoll"><a class="header" href="#ioqueue_epoll">ioqueue_epoll</a></h2>
<h3 id="pj_ioqueue_t"><a class="header" href="#pj_ioqueue_t">pj_ioqueue_t</a></h3>
<p>ioqueue的整体结构pj_ioqueue_t，使用epoll的在ioqueue_epoll.c  下列出ioqueue相关的<code>DECLARE_COMMON_IOQUEUE宏</code>、<code>pj_ioqueue_cfg</code>、<code>pj_ioqueue_t</code></p>
<pre><code class="language-c">#define DECLARE_COMMON_IOQUEUE                      \
    pj_lock_t          *lock;                       \
    pj_bool_t           auto_delete_lock;           \
    pj_ioqueue_cfg      cfg;

/**
 * Additional settings that can be given during ioqueue creation. Application
 * MUST initialize this structure with #pj_ioqueue_cfg_default().
 */
typedef struct pj_ioqueue_cfg
{
    /**
     * Specify flags to control e.g. how events are handled when epoll backend
     * is used on Linux. The values are combination of pj_ioqueue_epoll_flag.
     * The default value is PJ_IOQUEUE_DEFAULT_EPOLL_FLAGS, which by default
     * is set to PJ_IOQUEUE_EPOLL_AUTO. This setting will be ignored for other
     * ioqueue backends.
     */
    unsigned  epoll_flags;

    /**
     * Default concurrency for the handles registered to this ioqueue. Setting
     * this to non-zero enables a handle to process more than one operations
     * at the same time using different threads. Default is
     * PJ_IOQUEUE_DEFAULT_ALLOW_CONCURRENCY. This setting is equivalent to
     * calling pj_ioqueue_set_default_concurrency() after creating the ioqueue.
     */
    pj_bool_t default_concurrency;

} pj_ioqueue_cfg;

/*
 * This describes the I/O queue.
 */
struct pj_ioqueue_t
{
    DECLARE_COMMON_IOQUEUE

    unsigned            max, count;
    //pj_ioqueue_key_t  hlist;
    pj_ioqueue_key_t    active_list;    
    int                 epfd;
    //struct epoll_event *events;
    //struct queue       *queue;

#if PJ_IOQUEUE_HAS_SAFE_UNREG
    pj_mutex_t         *ref_cnt_mutex;
    pj_ioqueue_key_t    closing_list;
    pj_ioqueue_key_t    free_list;
#endif
};
</code></pre>
<p>有三个 pj_ioqueue_key_t类型的队列active_list、closing_list、free_list，</p>
<h3 id="pj_ioqueue_key_t"><a class="header" href="#pj_ioqueue_key_t">pj_ioqueue_key_t</a></h3>
<pre><code class="language-c">#define DECLARE_COMMON_KEY                          \
    PJ_DECL_LIST_MEMBER(struct pj_ioqueue_key_t);   \
    pj_ioqueue_t           *ioqueue;                \
    pj_grp_lock_t          *grp_lock;               \
    pj_lock_t              *lock;                   \
    pj_bool_t               inside_callback;        \
    pj_bool_t               destroy_requested;      \
    pj_bool_t               allow_concurrent;       \
    pj_sock_t               fd;                     \
    int                     fd_type;                \
    void                   *user_data;              \
    pj_ioqueue_callback     cb;                     \
    int                     connecting;             \
    struct read_operation   read_list;              \
    struct write_operation  write_list;             \
    struct accept_operation accept_list;            \
    UNREG_FIELDS
    
/*
 * This describes each key.
 */
struct pj_ioqueue_key_t
{
    DECLARE_COMMON_KEY
    struct epoll_event ev;
};

</code></pre>
<p>pj_ioqueue_key_t中出现了epoll_event 是linux中结构</p>
<h3 id="epoll_event"><a class="header" href="#epoll_event">epoll_event</a></h3>
<pre><code class="language-c">typedef [union](https://so.csdn.net/so/search?q=union&amp;spm=1001.2101.3001.7020) epoll_data {
    void *ptr;
    int fd;
    __uint32_t u32;
    __uint64_t u64;
} epoll_data_t;//保存触发事件的某个文件描述符相关的数据

struct epoll_event {
    __uint32_t events;   /* [epoll](https://so.csdn.net/so/search?q=epoll&amp;spm=1001.2101.3001.7020) event */
    epoll_data_t data;   /* User data variable */
};
</code></pre>
<h3 id="pj_ioqueue_callback"><a class="header" href="#pj_ioqueue_callback">pj_ioqueue_callback</a></h3>
<p>接下来介绍I/O结束的回调函数</p>
<pre><code class="language-c">/**
 * This structure describes the callbacks to be called when I/O operation
 * completes.
 */
typedef struct pj_ioqueue_callback
{
    /**
     * This callback is called when #pj_ioqueue_recv or #pj_ioqueue_recvfrom
     * completes.
     *
     * @param key           The key.
     * @param op_key        Operation key.
     * @param bytes_read    &gt;= 0 to indicate the amount of data read,
     *                      otherwise negative value containing the error
     *                      code. To obtain the pj_status_t error code, use
     *                      (pj_status_t code = -bytes_read).
     */
    void (*on_read_complete)(pj_ioqueue_key_t *key,
                             pj_ioqueue_op_key_t *op_key,
                             pj_ssize_t bytes_read);

    /**
     * This callback is called when #pj_ioqueue_send or #pj_ioqueue_sendto
     * completes.
     *
     * @param key           The key.
     * @param op_key        Operation key.
     * @param bytes_sent    &gt;= 0 to indicate the amount of data written,
     *                      otherwise negative value containing the error
     *                      code. To obtain the pj_status_t error code, use
     *                      (pj_status_t code = -bytes_sent).
     */
    void (*on_write_complete)(pj_ioqueue_key_t *key,
                              pj_ioqueue_op_key_t *op_key,
                              pj_ssize_t bytes_sent);

    /**
     * This callback is called when #pj_ioqueue_accept completes.
     *
     * @param key           The key.
     * @param op_key        Operation key.
     * @param sock          Newly connected socket.
     * @param status        Zero if the operation completes successfully.
     */
    void (*on_accept_complete)(pj_ioqueue_key_t *key,
                               pj_ioqueue_op_key_t *op_key,
                               pj_sock_t sock,
                               pj_status_t status);

    /**
     * This callback is called when #pj_ioqueue_connect completes.
     *
     * @param key           The key.
     * @param status        PJ_SUCCESS if the operation completes successfully.
     */
    void (*on_connect_complete)(pj_ioqueue_key_t *key,
                                pj_status_t status);
} pj_ioqueue_callback;
</code></pre>
<h3 id="pj_ioqueue_op_key_t"><a class="header" href="#pj_ioqueue_op_key_t">pj_ioqueue_op_key_t</a></h3>
<pre><code class="language-c">typedef struct pj_ioqueue_op_key_t
{
    void *internal__[32];           /**&lt; Internal I/O Queue data.   */
    void *activesock_data;          /**&lt; Active socket data.        */
    void *user_data;                /**&lt; Application data.          */
} pj_ioqueue_op_key_t;
</code></pre>
<h2 id="初始化相关"><a class="header" href="#初始化相关">初始化相关</a></h2>
<h3 id="pj_ioqueue_create2"><a class="header" href="#pj_ioqueue_create2">pj_ioqueue_create2</a></h3>
<p>pj_ioqueue_create（空实现调用pj_ioqueue_create2）</p>
<pre><code class="language-c">status = pj_ioqueue_create( endpt-&gt;pool, PJSIP_MAX_TRANSPORTS, &amp;endpt-&gt;ioqueue);
if (status != PJ_SUCCESS) {
    goto on_error;
}
</code></pre>
<p>初始化ioqueue的空间、ioqueue-&gt;lock、ioqueue-&gt;auto_delete_lock、ioqueue-&gt;cfg（pj_ioqueue_cfg）、ioqueue-&gt;max、ioqueue-&gt;count、ioqueue-&gt;cfg.epoll_flags（epoll type）、ioqueue-&gt;ref_cnt_mutex、ioqueue-&gt;free_list（对max_fd个key初始化key-&gt;ref_count、key-&gt;lock然后加入freelist）、ioqueue-&gt;closing_list、ioqueue-&gt;epfd（epoll fd调用epoll create）</p>
<h3 id="ioqueue_init_key"><a class="header" href="#ioqueue_init_key">ioqueue_init_key</a></h3>
<pre><code class="language-c">static pj_status_t ioqueue_init_key( pj_pool_t *pool,
                                     pj_ioqueue_t *ioqueue,
                                     pj_ioqueue_key_t *key,
                                     pj_sock_t sock,
                                     pj_grp_lock_t *grp_lock,
                                     void *user_data,
                                     const pj_ioqueue_callback *cb)
</code></pre>
<p>初始化key的key-&gt;ioqueue、key-&gt;fd、key-&gt;user_data（这里放到是transport_udp）、key-&gt;read_list、key-&gt;write_list、key-&gt;accept_list、key-&gt;connecting = 0、key-&gt;cb（callback）、key-&gt;closing 、key-&gt;allow_concurrent（pj_ioqueue_set_concurrency）、key-&gt;fd_type、key-&gt;grp_lock</p>
<h3 id="pj_ioqueue_register_sock2"><a class="header" href="#pj_ioqueue_register_sock2">pj_ioqueue_register_sock2</a></h3>
<p>pjmedia_transport_udp_create3-&gt;pjmedia_transport_udp_attach-&gt;pj_ioqueue_register_sock2</p>
<p>os_ioctl 设置socket to nonblocking.</p>
<p>从ioqueue的freelist中取得key，ioqueue_init_key，然后初始化key-&gt;ev（epoll_event类型 data.ptr 是key本身）, os_epoll_ctl注册 fd-events监听其socket事件。</p>
<pre><code class="language-c">PJ_DEF(pj_status_t) pj_ioqueue_register_sock2(pj_pool_t *pool,
                                              pj_ioqueue_t *ioqueue,
                                              pj_sock_t sock,
                                              pj_grp_lock_t *grp_lock,
                                              void *user_data,
                                              const pj_ioqueue_callback *cb,
                                              pj_ioqueue_key_t **p_key)
  
    status = pj_ioqueue_register_sock2(pool, ioqueue, tp-&gt;rtp_sock, grp_lock,
                                       tp, &amp;rtp_cb, &amp;tp-&gt;rtp_key);
</code></pre>
<p>注意在<code>pjmedia_transport_udp_attach</code> 中调用pj_ioqueue_register_sock2传入的是tp-&gt;rtp_key，pj_ioqueue_register_sock2返回后，会将绑定socket后的key保存在rtp_key中</p>
<h2 id="ioqueue-读取写入流程"><a class="header" href="#ioqueue-读取写入流程">ioqueue 读取写入流程</a></h2>
<p>ioqueue 读取全流程</p>
<p>pj_ioqueue_poll，发现事件-》ioqueue_dispatch_read_event-》on_rx_request-》on_rx_request</p>
<h3 id="pj_ioqueue_poll"><a class="header" href="#pj_ioqueue_poll">pj_ioqueue_poll</a></h3>
<p>事件触发后执行主要使用os_epoll_wait，执行分发回调</p>
<p>一般会另开一个工作线程，不停循环，执行epoll_wait以监听读取/写入rtp包的事件请求</p>
<pre><code class="language-c">while(1){
		pj_ioqueue_poll()
}
</code></pre>
<p>下面详细介绍pj_ioqueue_poll</p>
<p>先调用os_epoll_wait，事件放到events中，遍历所有events。根据read,write事件放入到queue中，queue结构如下：</p>
<pre><code class="language-c">struct queue
{
    pj_ioqueue_key_t        *key;
    enum ioqueue_event_type  event_type;
};

enum ioqueue_event_type
{
    NO_EVENT,
    READABLE_EVENT  = 1,
    WRITEABLE_EVENT = 2,
    EXCEPTION_EVENT = 4,
};
</code></pre>
<p>最后在遍历queue，根据事件执行相应的处理函数</p>
<p>READABLE_EVENT：ioqueue_dispatch_read_event</p>
<p>WRITEABLE_EVENT：ioqueue_dispatch_write_event</p>
<p>EXCEPTION_EVENT：ioqueue_dispatch_exception_e</p>
<h3 id="ioqueue_dispatch_read_event-读取操作"><a class="header" href="#ioqueue_dispatch_read_event-读取操作">ioqueue_dispatch_read_event 读取操作</a></h3>
<p>首先要看一下read_operation</p>
<pre><code class="language-c">struct read_operation
{
    PJ_DECL_LIST_MEMBER(struct read_operation);
    pj_ioqueue_operation_e  op;

    void                   *buf;
    pj_size_t               size;
    unsigned                flags;
    pj_sockaddr_t          *rmt_addr;
    int                    *rmt_addrlen;
};
</code></pre>
<pre><code class="language-c">
/**
 * Types of pending I/O Queue operation. This enumeration is only used
 * internally within the ioqueue.
 */
typedef enum pj_ioqueue_operation_e
{
    PJ_IOQUEUE_OP_NONE          = 0,    /**&lt; No operation.          */
    PJ_IOQUEUE_OP_READ          = 1,    /**&lt; read() operation.      */
    PJ_IOQUEUE_OP_RECV          = 2,    /**&lt; recv() operation.      */
    PJ_IOQUEUE_OP_RECV_FROM     = 4,    /**&lt; recvfrom() operation.  */
    PJ_IOQUEUE_OP_WRITE         = 8,    /**&lt; write() operation.     */
    PJ_IOQUEUE_OP_SEND          = 16,   /**&lt; send() operation.      */
    PJ_IOQUEUE_OP_SEND_TO       = 32,   /**&lt; sendto() operation.    */
#if defined(PJ_HAS_TCP) &amp;&amp; PJ_HAS_TCP != 0
    PJ_IOQUEUE_OP_ACCEPT        = 64,   /**&lt; accept() operation.    */
    PJ_IOQUEUE_OP_CONNECT       = 128   /**&lt; connect() operation.   */
#endif  /* PJ_HAS_TCP */
} pj_ioqueue_operation_e;
</code></pre>
<p>众多read_operation会挂在key中<code>struct read_operation   read_list;</code> 上通过<code>key_has_pending_read</code> 判断是否有pending的read操作</p>
<p>具体流程：</p>
<p>先看key read_list上有没有pending_read,有的话，从read_list取出，根据read_list的read_op确定读入大小，pj_sock_recvfrom接受数据的函数，将数据读入到read_op中，最后调用on_read_complete，回调函数已在pj_ioqueue_register_sock2时设置过，传入read_op</p>
<pre><code class="language-c">(*h-&gt;cb.on_read_complete)(h, 
                                      (pj_ioqueue_op_key_t*)read_op,
                                      bytes_read);
</code></pre>
<h3 id="ioqueue_dispatch_write_event写操作"><a class="header" href="#ioqueue_dispatch_write_event写操作">ioqueue_dispatch_write_event写操作</a></h3>
<p>与ioqueue_dispatch_read_event相似，先看write_operation</p>
<pre><code class="language-c">struct write_operation
{
    PJ_DECL_LIST_MEMBER(struct write_operation);
    pj_ioqueue_operation_e  op;

    char                   *buf;
    pj_size_t               size;
    pj_ssize_t              written;
    unsigned                flags;
    pj_sockaddr_in          rmt_addr;
    int                     rmt_addrlen;
};
</code></pre>
<p>众多write_operation会挂在key中<code>struct write_operation  write_list;</code> 上通过<code>key_has_pending_write</code> 判断是否有pending的write操作</p>
<p>具体流程：</p>
<p>先看key write_list上有没有pending_write,有的话，从write_list取出，根据write_list的 write_op确定写大小，要写入的数据，将数据写入调用pj_sock_send函数Transmit data to the socket.，最后调用on_write_complete，回调函数已在pj_ioqueue_register_sock2时设置过，传入write_op</p>
<pre><code class="language-c">if (h-&gt;cb.on_write_complete &amp;&amp; !IS_CLOSING(h)) {
                (*h-&gt;cb.on_write_complete)(h, 
                                           (pj_ioqueue_op_key_t*)write_op,
                                           write_op-&gt;written);
            }
</code></pre>
<h3 id="on_rx_rtp-读取操作"><a class="header" href="#on_rx_rtp-读取操作">on_rx_rtp 读取操作</a></h3>
<p>on_rx_rtp是被下面调用</p>
<pre><code class="language-c">(*h-&gt;cb.on_read_complete)(h, 
                                      (pj_ioqueue_op_key_t*)read_op,
                                      bytes_read);
</code></pre>
<p>这里有一个很有意思的问题，就是read_op 在on_rx_rtp中竟然没有使用，下面来分析一下原因</p>
<pre><code>udp = (struct transport_udp*) pj_ioqueue_get_user_data(key);

</code></pre>
<p>我们的read_op是从readlist中取出的，readlist对于读操作添加是依靠pj_ioqueue_recvfrom函数，在data is not immediately available时将read_op加入readlist</p>
<pre><code class="language-c">read_op-&gt;op = PJ_IOQUEUE_OP_RECV_FROM;
read_op-&gt;buf = buffer;
read_op-&gt;size = *length;
read_op-&gt;flags = flags;
read_op-&gt;rmt_addr = addr;
read_op-&gt;rmt_addrlen = addrlen;

pj_ioqueue_lock_key(key);
/* Check again. Handle may have been closed after the previous check
 * in multithreaded app. If we add bad handle to the set it will
 * corrupt the ioqueue set. See #913
 */
if (IS_CLOSING(key)) {
    pj_ioqueue_unlock_key(key);
    return PJ_ECANCELLED;
}
pj_list_insert_before(&amp;key-&gt;read_list, read_op);
ioqueue_add_to_set(key-&gt;ioqueue, key, READABLE_EVENT);
</code></pre>
<p>这里read_op-&gt;buf = buffer;的buffer，来自udp-&gt;rtp_pkt,相当于直接写入了rtp_pkt,所以不用read_op了。</p>
<p>on_rx_rtp是一个while循环，条件如下status来自pj_ioqueue_recvfrom的结果</p>
<pre><code class="language-c">status != PJ_EPENDING &amp;&amp; status != PJ_ECANCELLED &amp;&amp;
             udp-&gt;started
</code></pre>
<h4 id="call_rtp_cb"><a class="header" href="#call_rtp_cb">call_rtp_cb</a></h4>
<p>在while循环里，先执行call_rtp_cb，设置pjmedia_tp_cb_param param;，调用(*cb2)(&amp;param);cb2由transport_attach2-》tp_attach设置为stream.c ::on_rx_rtp。注意param.pkt = udp-&gt;rtp_pkt;，这里rtp_pkt其实就是ioqueue_dispatch_read_event中read_op-&gt;buf中读到的数据rtp包</p>
<pre><code class="language-c">/* Call RTP cb. */
static void call_rtp_cb(struct transport_udp *udp, pj_ssize_t bytes_read, 
                        pj_bool_t *rem_switch)
{
    void (*cb)(void*,void*,pj_ssize_t);
    void (*cb2)(pjmedia_tp_cb_param*);
    void *user_data;

    cb = udp-&gt;rtp_cb;
    cb2 = udp-&gt;rtp_cb2;
    user_data = udp-&gt;user_data;

    if (cb2) {
        pjmedia_tp_cb_param param;

        param.user_data = user_data;
        param.pkt = udp-&gt;rtp_pkt;
        param.size = bytes_read;
        param.src_addr = &amp;udp-&gt;rtp_src_addr;
        param.rem_switch = PJ_FALSE;
        (*cb2)(&amp;param);
        if (rem_switch)
            *rem_switch = param.rem_switch;
    } else if (cb) {
        (*cb)(user_data, udp-&gt;rtp_pkt, bytes_read);
    }
}
</code></pre>
<p>param.user_data = user_data;  注意这个user_data，是pjmedia_stream *stream</p>
<h4 id="pj_ioqueue_recvfrom"><a class="header" href="#pj_ioqueue_recvfrom">pj_ioqueue_recvfrom</a></h4>
<p>接下来是调用pj_ioqueue_recvfrom，至于为什么明明ioqueue_dispatch_read_event已经读取了数据，此时还在读取数据，是因为可能有新的rtp包到达，pj_ioqueue_recvfrom查看有没有到达的包，如果有就调用pj_sock_recvfrom继续读读到udp-&gt;rtp_pkt，如果没有加到readlist中，返回PJ_EPENDING，结束on_rx_rtp中的while循环。</p>
<h3 id="on_rx_rtpcb2"><a class="header" href="#on_rx_rtpcb2">on_rx_rtp::cb2</a></h3>
<p>Stream.c中的回调 tp_attach中设置该回调</p>
<p>该函数处理接收到的rtp包, 解析成payload和head</p>
<p>Put "good" packet to jitter buffer，需要先把payload解析成frame，再把frame放入jitter buffer</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="全流程思考.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="epoll学习.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="全流程思考.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="epoll学习.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
